name: Vibe Legal Alpha 0.2
description: AI-Powered Contract Redlining - Stateful Holistic Architecture
host: WORD
api_set: {}
script:
  content: |
    /**
     * VIBE LEGAL - AI-Powered Contract Redlining Engine
     * 
     * Enhanced - Structured Reasoning + Claude (Anthropic) API Support (planned)
     * 
     * https://github.com/sarturko-maker/vibe-legal
     * GNU General Public License
     */

    declare var diff_match_patch: any;
    declare var React: any;
    declare var ReactDOM: any;

    // ==========================================
    // PROVIDER CONFIGURATION
    // ==========================================

    type AIProvider = "gemini" | "claude";

    interface ProviderConfig {
        provider: AIProvider;
        geminiApiKey: string;
        claudeApiKey: string;
        geminiModel: string;
        claudeModel: string;
    }

    let providerConfig: ProviderConfig = {
        provider: "gemini",
        geminiApiKey: "",
        claudeApiKey: "",
        geminiModel: "gemini-2.0-flash-exp",
        claudeModel: "claude-sonnet-4-20250514"
    };

    function getCurrentApiKey(): string {
        return providerConfig.provider === "gemini" 
            ? providerConfig.geminiApiKey 
            : providerConfig.claudeApiKey;
    }

    function getCurrentModel(): string {
        return providerConfig.provider === "gemini"
            ? providerConfig.geminiModel
            : providerConfig.claudeModel;
    }

    // ==========================================
    // TRACK CHANGES AUTHOR SYSTEM
    // ==========================================

    type AuthorMode = "auto" | "vibe" | "custom";

    interface AuthorSettings {
        mode: AuthorMode;
        customName: string;
        detectedAuthor: string | null;
    }

    let authorSettings: AuthorSettings = {
        mode: "auto",
        customName: "",
        detectedAuthor: null
    };

    function getTrackChangeAuthor(): string {
        switch (authorSettings.mode) {
            case "auto":
                return authorSettings.detectedAuthor || "Vibe AI";
            case "vibe":
                return "Vibe AI";
            case "custom":
                return authorSettings.customName.trim() || "Vibe AI";
            default:
                return "Vibe AI";
        }
    }

    async function detectDocumentAuthor(context: Word.RequestContext): Promise<string | null> {
        try {
            const properties = context.document.properties;
            properties.load("lastAuthor, author");
            await context.sync();
            
            const detected = properties.lastAuthor?.trim() || properties.author?.trim() || null;
            
            if (detected) {
                authorSettings.detectedAuthor = detected;
            }
            
            return detected;
        } catch (e) {
            logWarn(" Could not read document author:", e);
            return null;
        }
    }

    // ==========================================
    // CONTEXT CACHING SYSTEM - Configuration
    // ==========================================

    const CACHE_CONFIG = {
        maxChangelogEntries: 10,
        maxChangelogChars: 5000,
        cacheTTL: 3600000,
        minCacheChars: 10000
    };

    // OOXML Namespace for proper Track Changes rendering
    const WORD_NS = "http://schemas.openxmlformats.org/wordprocessingml/2006/main";

    // DEBUG MODE: Set to true for verbose console logging, false for production
    const DEBUG = false;
    
    // Production-safe logger - only outputs when DEBUG is true
    // console.error always outputs for critical errors
    const log = (...args: any[]) => { if (DEBUG) log("", ...args); };
    const logWarn = (...args: any[]) => { if (DEBUG) logWarn("", ...args); };

    interface ChangeEntry {
        type: "INSERT" | "MODIFY";
        description: string;
        content?: string;
        timestamp: Date;
    }

    interface CacheState {
        cacheId: string | null;
        createdAt: Date | null;
        changelog: ChangeEntry[];
    }

    let cacheState: CacheState = {
        cacheId: null,
        createdAt: null,
        changelog: []
    };

    function stripMarkdownFormatting(text: string): string {
        if (!text) return "";
        return text
            .replace(/\*\*(.+?)\*\*/g, "$1")
            .replace(/\*(.+?)\*/g, "$1")
            .replace(/__(.+?)__/g, "$1")
            .replace(/`(.+?)`/g, "$1")
            .replace(/^#+\s*/gm, "")
            .replace(/^[-*]\s+/gm, "")
            // SPILLOVER FIX: Convert ALL newlines to single space to prevent paragraph breaks
            .replace(/\n+/g, " ")
            .replace(/\s+/g, " ")  // Collapse multiple spaces
            .trim();
    }

    // ==========================================
    // NUMBERED LIST HANDLING - ENHANCED
    // ==========================================

    /**
     * Detects if paragraph OOXML contains numbered list properties.
     * Uses multiple detection methods for reliability.
     */
    function hasNumberingInOxml(xmlDoc: Document): boolean {
        // Method 1: Direct tag name (works in most cases)
        if (xmlDoc.getElementsByTagName("w:numPr").length > 0) return true;
        
        // Method 2: Namespace-aware (for properly namespaced XML)
        const WORD_NS = "http://schemas.openxmlformats.org/wordprocessingml/2006/main";
        try {
            if (xmlDoc.getElementsByTagNameNS(WORD_NS, "numPr").length > 0) return true;
        } catch (e) { /* Ignore if not supported */ }
        
        // Method 3: Search through pPr elements for numPr children
        const pPrs = xmlDoc.getElementsByTagName("w:pPr");
        for (let i = 0; i < pPrs.length; i++) {
            const children = pPrs[i].childNodes;
            for (let j = 0; j < children.length; j++) {
                const nodeName = (children[j] as Element).nodeName || "";
                if (nodeName === "w:numPr" || nodeName.endsWith(":numPr")) {
                    return true;
                }
            }
        }
        
        return false;
    }

    /**
     * Strips leading numbering that AI might have added to its response.
     * Call this when you know the original text was from a numbered list.
     */
    function stripAiAddedNumbering(text: string): string {
        const patterns = [
            /^\s*\d+[.\)]\s+/,           // "1. " or "1) "
            /^\s*\(\d+\)\s+/,             // "(1) "
            /^\s*\([a-z]\)\s+/i,          // "(a) " or "(A) "
            /^\s*[a-z][.\)]\s+/i,         // "a. " or "a) "
            /^\s*\([ivxlcdm]+\)\s+/i,     // "(i) " roman numerals
            /^\s*[ivxlcdm]+[.\)]\s+/i,    // "i. " roman numerals
            /^\s*[-*]\s+/,                // Markdown-style bullets
        ];
        
        for (const pattern of patterns) {
            if (pattern.test(text)) {
                return text.replace(pattern, '');
            }
        }
        
        return text;
    }

    /**
     * Enhanced text sanitization for numbered list items.
     */
    function sanitizeForNumberedList(originalText: string, aiResponse: string, wasNumberedList: boolean): string {
        let result = sanitizeAiResponse(aiResponse);
        
        if (wasNumberedList) {
            // Check if AI added numbering that wasn't in original
            const originalHasNumber = /^\s*(\d+[.\)]|\([a-z\d]\)|[a-z][.\)])/i.test(originalText);
            
            if (!originalHasNumber) {
                // Original didn't start with a number, so strip any AI added
                result = stripAiAddedNumbering(result);
            }
        }
        
        return result;
    }

    // ==========================================
    // LIST NUMBERING INHERITANCE
    // ==========================================

    /**
     * Extracts numPr (numbering properties) from a paragraph's OOXML.
     * Returns the numId and ilvl needed to join the same list.
     */
    function extractNumPrFromOxml(oxml: string): { numId: string; ilvl: string } | null {
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(oxml, "text/xml");
        
        // Try direct tag lookup (works in most cases)
        let numPr = xmlDoc.getElementsByTagName("w:numPr")[0] as Element;
        
        // Also try namespace-aware lookup
        if (!numPr) {
            const WORD_NS = "http://schemas.openxmlformats.org/wordprocessingml/2006/main";
            try {
                numPr = xmlDoc.getElementsByTagNameNS(WORD_NS, "numPr")[0] as Element;
            } catch (e) { /* Ignore */ }
        }
        
        if (numPr) {
            // DOM-based extraction (preferred)
            const numIdEl = numPr.getElementsByTagName("w:numId")[0] as Element;
            const ilvlEl = numPr.getElementsByTagName("w:ilvl")[0] as Element;
            
            const numId = numIdEl?.getAttribute("w:val");
            const ilvl = ilvlEl?.getAttribute("w:val") || "0";
            
            if (numId) {
                log(" DOM Extracted numPr: numId=" + numId + ", ilvl=" + ilvl);
                return { numId, ilvl };
            }
        }
        
        // REGEX FALLBACK: Handle namespace aliasing (w14:numPr) and AlternateContent wrapping
        // This catches cases where DOM fails due to Word version differences
        const numIdMatch = oxml.match(/<w(?:14)?:numId[^>]*w:val="(\d+)"/);
        const ilvlMatch = oxml.match(/<w(?:14)?:ilvl[^>]*w:val="(\d+)"/);
        
        if (numIdMatch) {
            const numId = numIdMatch[1];
            const ilvl = ilvlMatch ? ilvlMatch[1] : "0";
            log(" REGEX Extracted numPr: numId=" + numId + ", ilvl=" + ilvl);
            return { numId, ilvl };
        }
        
        return null;
    }

    /**
     * Injects numPr into a paragraph's OOXML to make it join a numbered list.
     */
    function injectNumPrIntoOxml(oxml: string, numId: string, ilvl: string): string {
        const NS_W = "http://schemas.openxmlformats.org/wordprocessingml/2006/main";
        
        const parser = new DOMParser();
        const serializer = new XMLSerializer();
        const xmlDoc = parser.parseFromString(oxml, "text/xml");
        
        // Find the paragraph
        let pNode = xmlDoc.getElementsByTagName("w:p")[0] as Element;
        if (!pNode) return oxml;
        
        // Find or create pPr
        let pPr = pNode.getElementsByTagName("w:pPr")[0] as Element;
        
        if (!pPr) {
            pPr = xmlDoc.createElementNS(NS_W, "w:pPr");
            pNode.insertBefore(pPr, pNode.firstChild);
        }
        
        // Remove existing numPr if present
        const existingNumPr = pPr.getElementsByTagName("w:numPr")[0];
        if (existingNumPr) {
            pPr.removeChild(existingNumPr);
        }
        
        // Create new numPr with proper namespace
        const numPrEl = xmlDoc.createElementNS(NS_W, "w:numPr");
        
        const ilvlEl = xmlDoc.createElementNS(NS_W, "w:ilvl");
        ilvlEl.setAttributeNS(NS_W, "w:val", ilvl);
        numPrEl.appendChild(ilvlEl);
        
        const numIdEl = xmlDoc.createElementNS(NS_W, "w:numId");
        numIdEl.setAttributeNS(NS_W, "w:val", numId);
        numPrEl.appendChild(numIdEl);
        
        // Insert numPr after pStyle (if present) or as first child
        const pStyle = pPr.getElementsByTagName("w:pStyle")[0];
        if (pStyle && pStyle.nextSibling) {
            pPr.insertBefore(numPrEl, pStyle.nextSibling);
        } else if (pStyle) {
            pPr.appendChild(numPrEl);
        } else {
            pPr.insertBefore(numPrEl, pPr.firstChild);
        }
        
        log(" Injected numPr: numId=" + numId + ", ilvl=" + ilvl);
        return serializer.serializeToString(xmlDoc);
    }

    /**
     * Strips numPr from a paragraph's OOXML to make it a standalone styled paragraph.
     * Used for list_level: 0 (styled heading) where we don't want inherited list numbering.
     */
    function stripNumPrFromOxml(oxml: string): string {
        // Use regex to strip numPr - handles all namespace variants
        const stripped = oxml
            .replace(/<w:numPr>[\s\S]*?<\/w:numPr>/g, "")
            .replace(/<w14:numPr>[\s\S]*?<\/w14:numPr>/g, "");
        
        log(" Stripped numPr from OXML for styled heading");
        return stripped;
    }

    // ==========================================
    // AUTO-SCROLL UTILITY
    // ==========================================

    /**
     * Scrolls Word document to show the specified range.
     * SAFETY: Only use when all operation targets are pre-resolved via explicit IDs.
     */
    async function scrollToRange(range: Word.Range, context: Word.RequestContext): Promise<void> {
        try {
            range.select(Word.SelectionMode.select);
            await context.sync();
            log(" Scrolled to change");
        } catch (e) {
            log(" Scroll failed (non-critical):", e);
        }
    }

    /**
     * Brief delay between scroll operations for visual effect.
     */
    function scrollDelay(ms: number = 150): Promise<void> {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    // ==========================================
    // CONTRACT MAP SYSTEM - Semantic Document Understanding
    // ==========================================

    type ClauseCategory = 
        | "recitals" | "definitions" | "confidentiality" | "permitted_use" | "permitted_disclosure"
        | "return_of_materials" | "term_termination" | "representations_warranties" | "indemnification"
        | "limitation_of_liability" | "intellectual_property" | "non_compete" | "non_solicitation"
        | "governing_law" | "dispute_resolution" | "notices" | "assignment" | "severability"
        | "entire_agreement" | "amendment" | "waiver" | "counterparts" | "signatures" | "other";

    interface Party {
        name: string;
        role: "discloser" | "recipient" | "licensor" | "licensee" | "employer" | "employee" | "buyer" | "seller" | "party_a" | "party_b" | "other";
        definedAs: string;
        paragraphId: number;
    }

    interface DefinedTerm {
        term: string;
        definition: string;
        paragraphId: number;
        crossReferences: number[];
    }

    interface Obligation {
        obligor: string;
        type: "shall" | "shall_not" | "may" | "must" | "will";
        action: string;
        conditions: string | null;
    }

    interface RiskFlag {
        type: "one_sided" | "missing_cap" | "perpetual" | "broad_definition" | "unusual_term" | "missing_standard_clause";
        severity: "low" | "medium" | "high";
        description: string;
    }

    // NEW: Paragraph type classification for Continuous Coordinate System
    type ParagraphType = 'heading' | 'body' | 'empty' | 'signature' | 'definition';

    interface ParagraphEntry {
        id: number;                    // 1-based paragraph ID
        type: ParagraphType;
        fingerprint: string;           // First 30 chars normalized for validation
        sectionId: string | null;      // Which clause/section owns this paragraph
        embedding?: number[];          // Future: semantic search vector
    }

    interface ContractClause {
        id: string;
        number: string | null;
        title: string;
        category: ClauseCategory;
        startParagraphId: number;
        endParagraphId: number;
        summary: string;
        obligations: Obligation[];
        risks: RiskFlag[];
        children?: ContractClause[];   // Nested sub-clauses for hierarchy
        parentId?: string;             // Reference to parent clause
        embedding?: number[];          // Future: semantic search vector
    }

    interface CrossReference {
        fromParagraphId: number;
        referenceText: string;
        toClauseId: string | null;
    }

    interface ContractMap {
        documentType: "nda" | "msa" | "sow" | "employment" | "license" | "purchase" | "lease" | "other";
        variant: string | null;
        effectiveDate: string | null;
        parties: Party[];
        definitions: DefinedTerm[];
        clauses: ContractClause[];
        crossReferences: CrossReference[];
        structureType: "numbered" | "titled" | "mixed" | "unstructured";
        numberingFormat: string | null;
        generatedAt: Date;
        
        // NEW: Continuous Coordinate System fields
        totalParagraphCount: number;          // For staleness validation
        contentChecksum: string;              // Lightweight hash for change detection
        paragraphRegistry: ParagraphEntry[];  // Full coverage Light Map (kept internal, never sent to AI in full)
    }

    interface ContractMapState {
        map: ContractMap | null;
        documentHash: string | null;
        generatedAt: Date | null;
        isAnalyzing: boolean;
        totalParagraphCount: number | null;   // NEW: cached paragraph count for quick validation
    }

    // Global contract map state
    let contractMapState: ContractMapState = {
        map: null,
        documentHash: null,
        generatedAt: null,
        isAnalyzing: false,
        totalParagraphCount: null
    };

    // ==========================================
    // DELTA MANAGER - Provider-Agnostic Change Tracking
    // ==========================================
    
    interface DeltaOperation {
        id: string;
        type: "INSERT" | "MODIFY" | "DELETE";
        timestamp: Date;
        paragraphId: number;  // Live ID at time of operation
        originalParaId: number;  // ID in Cached Coordinate System (source of truth)
        idShift: number;  // +1 for INSERT, -1 for DELETE, 0 for MODIFY
        originalContent?: string;
        newContent?: string;
        metadata?: {
            clauseNumber?: string;
            sectionId?: string;
        };
    }

    interface DeltaManagerState {
        operations: DeltaOperation[];
        baselineHash: string;
        baselineParagraphCount: number;
        baselineProvider: "gemini" | "claude" | null;
        createdAt: Date | null;
        lastUpdatedAt: Date | null;
    }

    // DeltaManager singleton
    const deltaManager: DeltaManagerState = {
        operations: [],
        baselineHash: "",
        baselineParagraphCount: 0,
        baselineProvider: null,
        createdAt: null,
        lastUpdatedAt: null
    };

    // DeltaManager methods - Use Reverse Coordinate Translation
    // All delta entries use CACHED COORDINATE SYSTEM as source of truth
    
    function deltaRecordInsert(liveParagraphId: number, content: string, metadata?: { clauseNumber?: string; sectionId?: string }): void {
        // Convert Live ID to Original ID (Cached Coordinate System)
        const originalId = liveIdToOriginalId(liveParagraphId);
        
        deltaManager.operations.push({
            id: `delta_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            type: "INSERT",
            timestamp: new Date(),
            paragraphId: liveParagraphId,  // Keep Live ID for reference
            originalParaId: originalId,     // Source of truth
            idShift: +1,                    // INSERT shifts subsequent IDs by +1
            newContent: content,
            metadata
        });
        deltaManager.lastUpdatedAt = new Date();
        log(`[DeltaManager] INSERT recorded: Live P${liveParagraphId} → Original P${originalId} (shift +1)`);
    }

    function deltaRecordModify(liveParagraphId: number, originalContent: string, newContent: string): void {
        // Convert Live ID to Original ID (Cached Coordinate System)
        const originalId = liveIdToOriginalId(liveParagraphId);
        
        deltaManager.operations.push({
            id: `delta_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            type: "MODIFY",
            timestamp: new Date(),
            paragraphId: liveParagraphId,
            originalParaId: originalId,
            idShift: 0,  // MODIFY doesn't shift IDs
            originalContent,
            newContent
        });
        deltaManager.lastUpdatedAt = new Date();
        log(`[DeltaManager] MODIFY recorded: Live P${liveParagraphId} → Original P${originalId} (no shift)`);
    }

    function deltaRecordDelete(liveParagraphId: number, originalContent: string): void {
        // Convert Live ID to Original ID (Cached Coordinate System)
        const originalId = liveIdToOriginalId(liveParagraphId);
        
        deltaManager.operations.push({
            id: `delta_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            type: "DELETE",
            timestamp: new Date(),
            paragraphId: liveParagraphId,
            originalParaId: originalId,
            idShift: -1,  // DELETE shifts subsequent IDs by -1
            originalContent
        });
        deltaManager.lastUpdatedAt = new Date();
        log(`[DeltaManager] DELETE recorded: Live P${liveParagraphId} → Original P${originalId} (shift -1)`);
    }

    function deltaGetTextBlock(): string {
        if (deltaManager.operations.length === 0) return "";
        
        const lines = ["[DELTA UPDATES SINCE CACHE]"];
        for (const op of deltaManager.operations) {
            if (op.type === "INSERT") {
                lines.push(`- INSERTED at P${op.paragraphId}: "${op.newContent?.substring(0, 100)}..."`);
            } else if (op.type === "MODIFY") {
                lines.push(`- MODIFIED P${op.paragraphId}: "${op.originalContent?.substring(0, 50)}..." → "${op.newContent?.substring(0, 50)}..."`);
            } else if (op.type === "DELETE") {
                lines.push(`- DELETED P${op.paragraphId}: "${op.originalContent?.substring(0, 50)}..."`);
            }
        }
        return lines.join("\n");
    }

    function deltaEstimateTokens(): number {
        // Rough estimate: 4 chars per token
        return Math.ceil(deltaGetTextBlock().length / 4);
    }

    function deltaFlatten(): void {
        deltaManager.operations = [];
        deltaManager.createdAt = new Date();
        deltaManager.lastUpdatedAt = new Date();
        log("[DeltaManager] Flattened - all deltas cleared");
    }

    /**
     * COORDINATE TRANSLATION: Convert Live ID → Original ID (Cached Coordinate System)
     * Use when RECORDING a delta - the Live ID from Word must be translated to Original.
     */
    function liveIdToOriginalId(liveId: number): number {
        let originalId = liveId;
        // Apply REVERSE shifts (work backwards through operations)
        for (let i = deltaManager.operations.length - 1; i >= 0; i--) {
            const entry = deltaManager.operations[i];
            // If this operation affected IDs at or before our target, reverse its shift
            if (entry.originalParaId <= originalId && entry.idShift !== 0) {
                originalId -= entry.idShift;
            }
        }
        return originalId;
    }

    /**
     * COORDINATE TRANSLATION: Convert Original ID → Live ID
     * Use when APPLYING an operation - the cached ID must be translated to current Live ID.
     */
    function originalIdToLiveId(originalId: number): number {
        let liveId = originalId;
        // Apply forward shifts
        for (const entry of deltaManager.operations) {
            // If this operation occurred at or before our target, apply its shift
            if (entry.originalParaId <= liveId && entry.idShift !== 0) {
                liveId += entry.idShift;
            }
        }
        return liveId;
    }

    /**
     * Get cumulative ID shift at a given original paragraph ID.
     */
    function getCumulativeShift(originalId: number): number {
        let shift = 0;
        for (const entry of deltaManager.operations) {
            if (entry.originalParaId <= originalId && entry.idShift !== 0) {
                shift += entry.idShift;
            }
        }
        return shift;
    }

    function deltaSetBaseline(hash: string, paragraphCount: number, provider: "gemini" | "claude"): void {
        deltaManager.baselineHash = hash;
        deltaManager.baselineParagraphCount = paragraphCount;
        deltaManager.baselineProvider = provider;
        deltaManager.createdAt = new Date();
        deltaManager.operations = [];
        log("[DeltaManager] New baseline set for", provider, "with", paragraphCount, "paragraphs");
    }

    const MAX_DELTA_OPERATIONS = 20;
    const MAX_DELTA_TOKEN_ESTIMATE = 2000;

    function deltaNeedsFlatten(): boolean {
        return deltaManager.operations.length > MAX_DELTA_OPERATIONS || 
               deltaEstimateTokens() > MAX_DELTA_TOKEN_ESTIMATE;
    }

    // Simple hash for document change detection
    function simpleHash(str: string): string {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash;
        }
        return hash.toString(36);
    }

    /**
     * Heuristic clause detection V2 - Continuous Coordinate System
     * 
     * Key features:
     * 1. Full document coverage (no dead zones)
     * 2. Preamble/Epilogue implicit sections
     * 3. Orphan paragraph detection
     * 4. Hierarchy closure for nested clauses
     */
    function detectClausesHeuristic(paragraphs: ParagraphSnapshot[]): {
        clauses: ContractClause[];
        paragraphRegistry: ParagraphEntry[];
    } {
        const clauses: ContractClause[] = [];
        const paragraphRegistry: ParagraphEntry[] = [];
        let clauseId = 0;
        
        // Helper: Create fingerprint for validation
        function createFingerprint(text: string): string {
            return text.substring(0, 30).toLowerCase().replace(/\s+/g, ' ').trim();
        }
        
        // Helper: Classify paragraph type
        function classifyParagraph(p: ParagraphSnapshot): ParagraphType {
            if (!p.text || p.text.trim().length === 0) return 'empty';
            if (/^in witness|^agreed|^executed|signature/i.test(p.text)) return 'signature';
            if (/^["']?[A-Z][^"']*["']?\s+(means|shall mean|refers to)/i.test(p.text)) return 'definition';
            if (isClauseHeading(p)) return 'heading';
            return 'body';
        }
        
        // Category detection based on title keywords
        function detectCategory(text: string): ClauseCategory {
            const t = text.toLowerCase();
            if (/confiden|non-disclosure|nda/i.test(t)) return "confidentiality";
            if (/defin|interpret/i.test(t)) return "definitions";
            if (/term|duration|period|expir/i.test(t)) return "term_termination";
            if (/govern|law|jurisdic/i.test(t)) return "governing_law";
            if (/indemn/i.test(t)) return "indemnification";
            if (/liabil|limit|cap|damage/i.test(t)) return "limitation_of_liability";
            if (/intellect|ip|patent|copyright|trademark/i.test(t)) return "intellectual_property";
            if (/represent|warrant/i.test(t)) return "representations_warranties";
            if (/notice/i.test(t)) return "notices";
            if (/assign/i.test(t)) return "assignment";
            if (/sever/i.test(t)) return "severability";
            if (/entire|integrat/i.test(t)) return "entire_agreement";
            if (/waiv/i.test(t)) return "waiver";
            if (/amend|modif/i.test(t)) return "amendment";
            if (/counterpart/i.test(t)) return "counterparts";
            if (/dispute|arbitrat|mediat/i.test(t)) return "dispute_resolution";
            if (/non-comp|noncomp|compete/i.test(t)) return "non_compete";
            if (/non-solic|nonsolic|solicit/i.test(t)) return "non_solicitation";
            if (/return|destroy/i.test(t)) return "return_of_materials";
            if (/permitted.*use|use.*permitted|purpose/i.test(t)) return "permitted_use";
            if (/permitted.*disclos|disclos.*permitted|except/i.test(t)) return "permitted_disclosure";
            if (/^whereas|^recitals|^background/i.test(t)) return "recitals";
            if (/^in witness|^agreed|^executed|signature/i.test(t)) return "signatures";
            return "other";
        }
        
        // Detect numbered patterns
        function extractClauseNumber(text: string): string | null {
            const patterns = [
                /^(Section\s+\d+(\.\d+)*)/i,
                /^(Article\s+[IVX]+)/i,
                /^((?:\d+\.)+\d*)\s/,
                /^(\d+)\.\s/,
                /^\((\d+)\)\s/,
            ];
            for (const p of patterns) {
                const match = text.match(p);
                if (match) return match[1].trim();
            }
            return null;
        }
        
        // Detect if paragraph is a heading
        function isClauseHeading(p: ParagraphSnapshot): boolean {
            if (/^(\d+\.?\s+|\(\d+\)\s*|Section\s+\d+|Article\s+[IVX]+)/i.test(p.text)) return true;
            if (p.styleId.toLowerCase().includes("heading")) return true;
            if (p.fmt.allCaps && p.text.length < 50) return true;
            if (p.fmt.bold && p.text.length < 60 && /^[A-Z]/.test(p.text)) return true;
            if (/^WHEREAS|^RECITALS|^BACKGROUND|^IN WITNESS/i.test(p.text)) return true;
            return false;
        }
        
        // Helper: Parse hierarchy level from clause number (e.g., "5.1.2" → 3)
        function getHierarchyLevel(number: string | null): number {
            if (!number) return 0;
            const parts = number.replace(/^(Section|Article)\s*/i, '').split('.');
            return parts.length;
        }
        
        // ==========================================
        // PASS 1: Build basic clause list + full registry
        // ==========================================
        let currentClause: ContractClause | null = null;
        let firstHeadingIdx = -1;
        
        for (let i = 0; i < paragraphs.length; i++) {
            const p = paragraphs[i];
            const pType = classifyParagraph(p);
            
            // Add to registry (every paragraph is registered)
            paragraphRegistry.push({
                id: p.id,
                type: pType,
                fingerprint: createFingerprint(p.text),
                sectionId: null  // Will be filled in pass 2
            });
            
            if (pType === 'heading') {
                if (firstHeadingIdx === -1) firstHeadingIdx = i;
                
                // Close previous clause
                if (currentClause) {
                    currentClause.endParagraphId = paragraphs[i - 1]?.id || currentClause.startParagraphId;
                    clauses.push(currentClause);
                }
                
                // Start new clause
                clauseId++;
                const number = extractClauseNumber(p.text) || p.clauseRef;
                const title = p.text.replace(/^[\d.()]+\s*/, '').substring(0, 50);
                
                currentClause = {
                    id: `clause_${clauseId}`,
                    number: number,
                    title: title || `Clause ${clauseId}`,
                    category: detectCategory(p.text),
                    startParagraphId: p.id,
                    endParagraphId: p.id,
                    summary: "",
                    obligations: [],
                    risks: []
                };
            }
        }
        
        // Close final clause
        if (currentClause) {
            currentClause.endParagraphId = paragraphs[paragraphs.length - 1]?.id || currentClause.startParagraphId;
            clauses.push(currentClause);
        }
        
        // ==========================================
        // PASS 2: Create Preamble (before first heading)
        // ==========================================
        if (firstHeadingIdx > 0) {
            const preamble: ContractClause = {
                id: "section_preamble",
                number: null,
                title: "Preamble",
                category: "recitals",
                startParagraphId: 1,
                endParagraphId: paragraphs[firstHeadingIdx - 1].id,
                summary: "Introductory text before first clause",
                obligations: [],
                risks: []
            };
            clauses.unshift(preamble);
        }
        
        // ==========================================
        // PASS 3: Detect orphan paragraphs (gaps between clauses)
        // ==========================================
        const sortedClauses = [...clauses].sort((a, b) => a.startParagraphId - b.startParagraphId);
        const orphanSections: ContractClause[] = [];
        let orphanCount = 0;
        
        for (let i = 0; i < sortedClauses.length - 1; i++) {
            const current = sortedClauses[i];
            const next = sortedClauses[i + 1];
            
            // Check for gap
            if (current.endParagraphId + 1 < next.startParagraphId) {
                orphanCount++;
                orphanSections.push({
                    id: `orphan_${orphanCount}`,
                    number: null,
                    title: "Uncategorized Text",
                    category: "other",
                    startParagraphId: current.endParagraphId + 1,
                    endParagraphId: next.startParagraphId - 1,
                    summary: "Text between clauses",
                    obligations: [],
                    risks: []
                });
            }
        }
        
        // Add orphan sections to clauses list
        clauses.push(...orphanSections);
        
        // ==========================================
        // PASS 4: Fill sectionId in paragraph registry
        // ==========================================
        const allSections = [...clauses].sort((a, b) => a.startParagraphId - b.startParagraphId);
        
        for (const entry of paragraphRegistry) {
            for (const section of allSections) {
                if (entry.id >= section.startParagraphId && entry.id <= section.endParagraphId) {
                    entry.sectionId = section.id;
                    break;
                }
            }
        }
        
        // ==========================================
        // PASS 5: Hierarchy closure (extend parents to include children)
        // ==========================================
        // Build hierarchy from numbering
        const clausesByNumber = new Map<string, ContractClause>();
        for (const clause of clauses) {
            if (clause.number) {
                clausesByNumber.set(clause.number, clause);
            }
        }
        
        // For each clause, find parent and link
        for (const clause of clauses) {
            if (!clause.number) continue;
            
            // Try to find parent (e.g., for "5.1", parent is "5")
            const parts = clause.number.split('.');
            if (parts.length > 1) {
                const parentNumber = parts.slice(0, -1).join('.');
                const parent = clausesByNumber.get(parentNumber);
                if (parent) {
                    clause.parentId = parent.id;
                    if (!parent.children) parent.children = [];
                    parent.children.push(clause);
                    
                    // Extend parent's endParagraphId if child extends further
                    if (clause.endParagraphId > parent.endParagraphId) {
                        parent.endParagraphId = clause.endParagraphId;
                    }
                }
            }
        }
        
        // Sort clauses by startParagraphId for consistent output
        clauses.sort((a, b) => a.startParagraphId - b.startParagraphId);
        
        return { clauses, paragraphRegistry };
    }

    /**
     * AI-powered deep contract analysis.
     * Calls the AI to build a complete contract map with parties, definitions, etc.
     */
    async function analyzeContractWithAI(
        apiKey: string,
        model: string,
        fullText: string,
        heuristicClauses: ContractClause[],
        provider: "gemini" | "claude"
    ): Promise<ContractMap | null> {
        const backtick = String.fromCharCode(96);
        
        const prompt = "You are a legal document analyzer. Parse this contract and return a detailed JSON structure.\n\n" +
            "=== HEURISTIC PRE-ANALYSIS ===\n" +
            "I've already detected these clause boundaries (verify and correct if needed):\n" +
            JSON.stringify(heuristicClauses.slice(0, 20), null, 2) + "\n\n" +
            "=== INSTRUCTIONS ===\n\n" +
            "1. DOCUMENT TYPE: Identify the contract type and variant\n" +
            "   - Types: nda, msa, sow, employment, license, purchase, lease, other\n" +
            "   - Variants: one-way, mutual, employee, contractor, saas, perpetual, etc.\n\n" +
            "2. PARTIES: For each party identify:\n" +
            "   - Their actual name (company or person)\n" +
            "   - Their role in the agreement\n" +
            "   - How they're defined/referred to in the document (definedAs)\n" +
            "   - The paragraph ID where first introduced\n\n" +
            "3. DEFINED TERMS: Extract key defined terms\n" +
            "   - The term itself\n" +
            "   - A brief definition (max 100 chars)\n" +
            "   - The paragraph where defined\n\n" +
            "4. CLAUSES: For each clause from the heuristic analysis:\n" +
            "   - Verify/correct the category\n" +
            "   - Write a one-sentence summary (max 80 chars)\n\n" +
            "5. STRUCTURE: Note the document's numbering/heading format\n\n" +
            "=== OUTPUT FORMAT ===\n" +
            "Return ONLY valid JSON (no markdown, no " + backtick + backtick + backtick + "):\n\n" +
            "{\n" +
            '    "documentType": "nda",\n' +
            '    "variant": "one-way",\n' +
            '    "effectiveDate": "2024-01-15",\n' +
            '    "parties": [...],\n' +
            '    "definitions": [...],\n' +
            '    "clauses": [...],\n' +
            '    "structureType": "numbered",\n' +
            '    "numberingFormat": "1."\n' +
            "}\n\n" +
            "=== DOCUMENT TEXT (FIRST 15000 CHARS) ===\n" +
            fullText.substring(0, 15000);

        try {
            let responseText = "";
            
            if (provider === "gemini") {
                const cleanModel = (model || "gemini-2.0-flash-exp").replace(/^models\//, "");
                const url = `https://generativelanguage.googleapis.com/v1beta/models/${cleanModel}:generateContent?key=${apiKey}`;
                
                const response = await fetch(url, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }],
                        generationConfig: { responseMimeType: "application/json" }
                    })
                });
                
                const data = await response.json();
                responseText = data.candidates?.[0]?.content?.parts?.[0]?.text?.trim() || "";
            } else {
                const response = await fetch("https://api.anthropic.com/v1/messages", {
                    method: "POST",
                    headers: {
                        "x-api-key": apiKey,
                        "anthropic-version": "2023-06-01",
                        "anthropic-dangerous-direct-browser-access": "true",
                        "content-type": "application/json"
                    },
                    body: JSON.stringify({
                        model: model || "claude-sonnet-4-20250514",
                        max_tokens: 4096,
                        messages: [{ role: "user", content: prompt }]
                    })
                });
                
                const data = await response.json();
                responseText = data.content?.[0]?.text?.trim() || "";
            }
            
            const parsed = tryParseJSON(responseText);
            if (!parsed) return null;
            
            // Merge AI analysis with heuristic clause structure
            const mergedClauses = heuristicClauses.map(hc => {
                const aiClause = parsed.clauses?.find((ac: any) => ac.id === hc.id);
                return {
                    ...hc,
                    category: aiClause?.category || hc.category,
                    summary: aiClause?.summary || ""
                };
            });
            
            return {
                documentType: parsed.documentType || "other",
                variant: parsed.variant || null,
                effectiveDate: parsed.effectiveDate || null,
                parties: parsed.parties || [],
                definitions: (parsed.definitions || []).map((d: any) => ({
                    ...d,
                    crossReferences: []
                })),
                clauses: mergedClauses,
                crossReferences: [],
                structureType: parsed.structureType || "unstructured",
                numberingFormat: parsed.numberingFormat || null,
                generatedAt: new Date()
            };
        } catch (e) {
            console.error("[ContractMap] AI analysis failed:", e);
            return null;
        }
    }

    /**
     * Build contract map context section for router prompts.
     */
    function buildContractMapContext(contractMap: ContractMap | null): string {
        if (!contractMap) return "";
        
        const partiesSection = contractMap.parties.length > 0
            ? "PARTIES:\n" + contractMap.parties.map(p => "- " + p.name + " (" + p.role + ') - referred to as "' + p.definedAs + '"').join('\n')
            : '';
        
        const definitionsSection = contractMap.definitions.length > 0
            ? "KEY DEFINED TERMS:\n" + contractMap.definitions.slice(0, 10).map(d => '- "' + d.term + '" [P' + d.paragraphId + ']').join('\n')
            : '';
        
        const clausesSection = contractMap.clauses.length > 0
            ? "CLAUSE STRUCTURE:\n" + contractMap.clauses.slice(0, 15).map(c => 
                "- " + (c.number || '') + " " + c.title + " [P" + c.startParagraphId + "-" + c.endParagraphId + "] (" + c.category + ")" + (c.summary ? ': ' + c.summary : '')
              ).join('\n')
            : '';
        
        let result = "\n=== CONTRACT INTELLIGENCE ===\n";
        result += "Document Type: " + contractMap.documentType;
        if (contractMap.variant) result += " (" + contractMap.variant + ")";
        result += "\nStructure: " + contractMap.structureType;
        if (contractMap.numberingFormat) result += ", format: " + contractMap.numberingFormat;
        result += "\n\n" + partiesSection;
        result += "\n\n" + definitionsSection;
        result += "\n\n" + clausesSection;
        result += "\n\n=== SEMANTIC GUIDANCE ===\n";
        result += '- "make mutual" -> both parties should have reciprocal obligations\n';
        result += '- "Discloser/Recipient" -> use definedAs values from parties above\n';
        result += '- "add clause after X" -> use clause structure to find location_id\n';
        result += '- References to "Section N" -> map to paragraph IDs using clauses structure\n';
        return result;
    }

    /**
     * Ensure contract map is generated (with caching).
     */
    async function ensureContractMap(
        apiKey: string,
        model: string,
        fullText: string,
        paragraphs: ParagraphSnapshot[],
        provider: "gemini" | "claude"
    ): Promise<ContractMap | null> {
        const currentHash = simpleHash(fullText);
        const currentParagraphCount = paragraphs.length;
        
        // Staleness validation: check both hash AND paragraph count
        if (contractMapState.map && 
            contractMapState.documentHash === currentHash &&
            contractMapState.totalParagraphCount === currentParagraphCount) {
            return contractMapState.map;
        }
        
        // Force refresh if paragraph count changed (Earthquake Effect mitigation)
        if (contractMapState.totalParagraphCount !== null && 
            contractMapState.totalParagraphCount !== currentParagraphCount) {
            logWarn("[ContractMap] Paragraph count changed from", 
                contractMapState.totalParagraphCount, "to", currentParagraphCount, 
                "- invalidating cache");
        }
        
        contractMapState.isAnalyzing = true;
        
        try {
            // Phase 1: Quick heuristic pass (now returns clauses + paragraphRegistry)
            const { clauses: heuristicClauses, paragraphRegistry } = detectClausesHeuristic(paragraphs);
            
            // Phase 2: AI deep analysis (skip for very short docs)
            let fullMap: ContractMap | null = null;
            if (fullText.length > 500) {
                fullMap = await analyzeContractWithAI(apiKey, model, fullText, heuristicClauses, provider);
            }
            
            if (!fullMap) {
                // Fallback: use heuristic-only map
                fullMap = {
                    documentType: "other",
                    variant: null,
                    effectiveDate: null,
                    parties: [],
                    definitions: [],
                    clauses: heuristicClauses,
                    crossReferences: [],
                    structureType: "unstructured",
                    numberingFormat: null,
                    generatedAt: new Date(),
                    totalParagraphCount: currentParagraphCount,
                    contentChecksum: currentHash,
                    paragraphRegistry: paragraphRegistry
                };
            } else {
                // Enrich AI map with Continuous Coordinate System fields
                fullMap.totalParagraphCount = currentParagraphCount;
                fullMap.contentChecksum = currentHash;
                fullMap.paragraphRegistry = paragraphRegistry;
            }
            
            contractMapState = {
                map: fullMap,
                documentHash: currentHash,
                generatedAt: new Date(),
                isAnalyzing: false,
                totalParagraphCount: currentParagraphCount
            };
            
            log("[ContractMap] Built with", heuristicClauses.length, "clauses,",
                paragraphRegistry.length, "paragraphs covered");
            
            return fullMap;
        } catch (e) {
            contractMapState.isAnalyzing = false;
            console.error("[ContractMap] ensureContractMap failed:", e);
            return null;
        }
    }
    
    // ==========================================
    // CASCADING SEARCH STRATEGY - Topic Definitions V2
    // Context-Aware Disambiguation
    // ==========================================

    interface TopicDefinition {
        primary: string;
        
        // POSITIVE SIGNALS (increase confidence)
        coreTerms: string[];           // Must have at least one of these (high weight)
        supportingTerms: string[];     // Nice to have (medium weight)
        bodySignals: string[];         // Phrases in clause body (medium weight)
        questionPatterns: RegExp[];    // Plain-language patterns (medium weight)
        
        // NEGATIVE SIGNALS (decrease confidence)
        negativeTerms: string[];       // If present, likely wrong topic
        ambiguousTerms: string[];      // Only count if co-occurring with core terms
        excludePatterns: RegExp[];     // Patterns that indicate WRONG topic
        
        // CO-OCCURRENCE REQUIREMENTS
        minCoreTerms: number;          // Minimum core terms required (default 1)
        cooccurrenceBoost: number;     // Bonus for multiple terms together
    }

    const TOPIC_DEFINITIONS: Record<string, TopicDefinition> = {
        "insurance": {
            primary: "insurance",
            coreTerms: ["insurance", "insurer", "insured", "underwriting", "premium", "public liability", "professional indemnity", "employer's liability", "product liability"],
            supportingTerms: ["coverage", "policy", "claims", "indemnity", "protection", "cover", "certificate"],
            negativeTerms: ["data protection", "privacy policy", "acceptable use", "company policy", "internal policy", "service coverage", "geographic coverage", "network coverage", "warranty claims", "intellectual property", "scope of"],
            ambiguousTerms: ["policy", "coverage", "claims", "protection", "indemnity"],
            excludePatterns: [/data\s+protection/i, /privacy\s+policy/i, /acceptable\s+use/i, /company\s+polic/i, /internal\s+polic/i, /service\s+coverage/i, /scope\s+of\s+(work|service)/i, /warranty\s+claim/i, /IP\s+claim/i],
            bodySignals: ["shall maintain insurance", "adequate insurance cover", "minimum level of indemnity", "insurance certificate", "proof of insurance", "named insured", "additional insured", "insurance requirements"],
            questionPatterns: [/what (insurance|coverage) (should|must|shall)/i, /insurance requirements/i],
            minCoreTerms: 1, cooccurrenceBoost: 20
        },
        "confidentiality": {
            primary: "confidentiality",
            coreTerms: ["confidential", "confidentiality", "non-disclosure", "nda", "trade secret", "proprietary information"],
            supportingTerms: ["disclose", "disclosure", "secret", "sensitive", "private"],
            negativeTerms: ["data protection", "privacy policy", "public disclosure"],
            ambiguousTerms: ["private", "sensitive", "disclose"],
            excludePatterns: [/data\s+protection/i, /privacy\s+(policy|notice)/i, /public\s+disclosure/i, /freedom\s+of\s+information/i],
            bodySignals: ["shall not disclose", "keep confidential", "receiving party", "disclosing party", "confidential information"],
            questionPatterns: [/keep(ing)?.*(secret|confidential|private)/i, /what (can|cannot).*(share|disclose)/i],
            minCoreTerms: 1, cooccurrenceBoost: 15
        },
        "termination": {
            primary: "termination",
            coreTerms: ["termination", "terminate", "expiry", "expiration"],
            supportingTerms: ["end", "cancel", "cancellation", "walk away", "exit", "wind up", "cessation"],
            negativeTerms: [], ambiguousTerms: ["end", "cancel"], excludePatterns: [],
            bodySignals: ["may terminate", "shall terminate", "upon termination", "notice of termination", "right to terminate", "termination for cause"],
            questionPatterns: [/when (can|does|will).*(end|terminate|expire|walk away)/i, /how (to|do we) (end|terminate|exit)/i],
            minCoreTerms: 1, cooccurrenceBoost: 15
        },
        "limitation_of_liability": {
            primary: "limitation of liability",
            coreTerms: ["limitation of liability", "limit of liability", "liability cap", "liability limit", "maximum liability", "aggregate liability", "total liability", "cap on liability"],
            supportingTerms: ["shall not exceed", "in no event", "consequential damages", "indirect damages", "special damages", "exclusion of liability"],
            negativeTerms: ["liability insurance", "public liability", "employer's liability"],
            ambiguousTerms: ["liability", "damages", "cap", "limit"],
            excludePatterns: [/liability\s+insurance/i, /public\s+liability/i, /employer'?s?\s+liability/i, /product\s+liability\s+insurance/i],
            bodySignals: ["total liability shall not exceed", "aggregate liability", "in no event shall", "exclude liability for"],
            questionPatterns: [/cap(s)? on (liability|damages|what)/i, /maximum.*(liable|owe|pay)/i],
            minCoreTerms: 1, cooccurrenceBoost: 20
        },
        "indemnification": {
            primary: "indemnification",
            coreTerms: ["indemnify", "indemnification", "hold harmless", "defend and indemnify", "indemnified party", "indemnifying party"],
            supportingTerms: ["indemnity", "third party claims", "losses", "damages", "reimburse"],
            negativeTerms: ["indemnity insurance", "professional indemnity", "public liability"],
            ambiguousTerms: ["indemnity", "losses", "damages"],
            excludePatterns: [/indemnity\s+insurance/i, /professional\s+indemnity/i, /insurance.*indemnity/i],
            bodySignals: ["shall indemnify", "hold harmless", "defend, indemnify", "indemnification obligations"],
            questionPatterns: [/who (pays|is responsible) if/i, /protection (against|from) claims/i],
            minCoreTerms: 1, cooccurrenceBoost: 15
        },
        "governing_law": {
            primary: "governing law",
            coreTerms: ["governing law", "jurisdiction", "applicable law", "venue"],
            supportingTerms: ["courts", "legal system", "laws of"],
            negativeTerms: [], ambiguousTerms: ["courts"], excludePatterns: [],
            bodySignals: ["governed by", "construed in accordance", "exclusive jurisdiction", "courts of", "laws of England", "laws of the State"],
            questionPatterns: [/which (law|legal system|courts)/i, /where (to sue|disputes.*heard)/i],
            minCoreTerms: 1, cooccurrenceBoost: 15
        },
        "dispute_resolution": {
            primary: "dispute resolution",
            coreTerms: ["dispute", "arbitration", "mediation", "litigation", "resolution"],
            supportingTerms: ["disagreement", "conflict", "controversy"],
            negativeTerms: [], ambiguousTerms: ["conflict"], excludePatterns: [],
            bodySignals: ["shall be resolved", "binding arbitration", "mediation first", "dispute resolution procedure", "escalation"],
            questionPatterns: [/how (to|do we) (resolve|handle|settle).*(dispute|disagreement)/i, /what happens if we (disagree|can't agree)/i],
            minCoreTerms: 1, cooccurrenceBoost: 15
        },
        "payment": {
            primary: "payment",
            coreTerms: ["payment", "invoice", "billing"],
            supportingTerms: ["price", "fee", "fees", "cost", "charge", "compensation", "remuneration"],
            negativeTerms: [], ambiguousTerms: ["fee", "cost", "charge"], excludePatterns: [],
            bodySignals: ["shall pay", "within.*days of invoice", "payment terms", "late payment", "interest on overdue"],
            questionPatterns: [/how (much|do we pay)/i, /when (is|are) payment(s)? due/i, /what (does it|will it) cost/i],
            minCoreTerms: 1, cooccurrenceBoost: 15
        },
        "force_majeure": {
            primary: "force majeure",
            coreTerms: ["force majeure", "act of god"],
            supportingTerms: ["beyond control", "unforeseeable", "extraordinary", "unavoidable", "impossibility"],
            negativeTerms: [], ambiguousTerms: [], excludePatterns: [],
            bodySignals: ["neither party shall be liable", "events beyond.*control", "pandemic", "war", "natural disaster", "government action"],
            questionPatterns: [/what (if|happens).*(can't|cannot) (perform|deliver)/i, /events (outside|beyond) (our|your|either party's) control/i],
            minCoreTerms: 1, cooccurrenceBoost: 15
        }
    };

    /**
     * Gets the topic definition, with fallback to basic definition.
     */
    function getTopicDefinition(topicKey: string): TopicDefinition {
        const normalized = topicKey.toLowerCase().replace(/[^a-z]/g, '_');
        
        // Try exact match
        if (TOPIC_DEFINITIONS[normalized]) {
            return TOPIC_DEFINITIONS[normalized];
        }
        
        // Try partial match
        for (const [key, def] of Object.entries(TOPIC_DEFINITIONS)) {
            if (key.includes(normalized) || normalized.includes(key)) {
                return def;
            }
        }
        
        // Fallback: create basic definition from the topic string
        return {
            primary: topicKey,
            coreTerms: [topicKey],
            supportingTerms: [],
            bodySignals: [],
            questionPatterns: [],
            negativeTerms: [],
            ambiguousTerms: [],
            excludePatterns: [],
            minCoreTerms: 1,
            cooccurrenceBoost: 15
        };
    }

    // ==========================================
    // CONTEXT-AWARE SCORING SYSTEM
    // ==========================================

    interface CandidateScore {
        paragraphId: number;
        headingText: string;
        clauseNumber: string | null;
        
        // Scoring breakdown
        coreTermsFound: string[];
        supportingTermsFound: string[];
        negativeTermsFound: string[];
        bodySignalsFound: string[];
        
        // Calculated scores
        baseScore: number;
        cooccurrenceBonus: number;
        negativePenalty: number;
        finalScore: number;
        
        // Metadata
        method: string;
        confidence: "high" | "medium" | "low" | "rejected";
    }

    /**
     * Scores a candidate heading against a topic definition.
     * Returns detailed breakdown for debugging.
     */
    function scoreCandidate(
        headingText: string,
        bodyText: string,  // First ~200 chars of clause body
        topicDef: TopicDefinition
    ): { score: number; breakdown: Partial<CandidateScore> } {
        
        const textLower = headingText.toLowerCase();
        const bodyLower = bodyText.toLowerCase();
        const combinedText = textLower + " " + bodyLower;
        
        // ==========================================
        // STEP 1: Check for EXCLUSION patterns first
        // ==========================================
        for (const pattern of topicDef.excludePatterns || []) {
            if (pattern.test(headingText) || pattern.test(bodyText)) {
                // Silently reject - pattern match indicates wrong topic
                return {
                    score: -1,  // Explicitly rejected
                    breakdown: {
                        confidence: "rejected",
                        negativeTermsFound: [pattern.toString()]
                    }
                };
            }
        }
        
        // ==========================================
        // STEP 2: Find NEGATIVE terms
        // ==========================================
        const negativeTermsFound: string[] = [];
        for (const term of topicDef.negativeTerms || []) {
            if (combinedText.includes(term.toLowerCase())) {
                negativeTermsFound.push(term);
            }
        }
        
        // If negative terms found, apply heavy penalty
        const negativePenalty = negativeTermsFound.length * 40;
        
        // ==========================================
        // STEP 3: Find CORE terms
        // ==========================================
        const coreTermsFound: string[] = [];
        for (const term of topicDef.coreTerms) {
            const termRegex = new RegExp("\\b" + escapeRegex(term) + "\\b", "i");
            if (termRegex.test(headingText) || termRegex.test(bodyText)) {
                coreTermsFound.push(term);
            }
        }
        
        // Check minimum core terms requirement
        const minRequired = topicDef.minCoreTerms || 1;
        if (coreTermsFound.length < minRequired) {
            // Not enough core terms - check if we have supporting terms
            // If ONLY ambiguous terms matched, reject
            
            let hasNonAmbiguousMatch = false;
            for (const term of topicDef.supportingTerms || []) {
                const isAmbiguous = (topicDef.ambiguousTerms || []).includes(term);
                const termRegex = new RegExp("\\b" + escapeRegex(term) + "\\b", "i");
                
                if (termRegex.test(headingText)) {
                    if (!isAmbiguous) {
                        hasNonAmbiguousMatch = true;
                        break;
                    }
                }
            }
            
            if (!hasNonAmbiguousMatch && coreTermsFound.length === 0) {
                // Silently reject - no log spam
                return {
                    score: 0,
                    breakdown: {
                        confidence: "rejected",
                        coreTermsFound: [],
                        negativeTermsFound
                    }
                };
            }
        }
        
        // ==========================================
        // STEP 4: Find SUPPORTING terms
        // ==========================================
        const supportingTermsFound: string[] = [];
        for (const term of topicDef.supportingTerms || []) {
            const termRegex = new RegExp("\\b" + escapeRegex(term) + "\\b", "i");
            if (termRegex.test(headingText) || termRegex.test(bodyText)) {
                // Only count ambiguous terms if we have core terms
                const isAmbiguous = (topicDef.ambiguousTerms || []).includes(term);
                if (!isAmbiguous || coreTermsFound.length > 0) {
                    supportingTermsFound.push(term);
                }
            }
        }
        
        // ==========================================
        // STEP 5: Find BODY SIGNALS
        // ==========================================
        const bodySignalsFound: string[] = [];
        for (const signal of topicDef.bodySignals || []) {
            if (bodyLower.includes(signal.toLowerCase())) {
                bodySignalsFound.push(signal);
            }
        }
        
        // ==========================================
        // STEP 6: Calculate final score
        // ==========================================
        
        // Base score from term matches
        let baseScore = 0;
        
        // Core terms: 40 points each (high value)
        baseScore += coreTermsFound.length * 40;
        
        // Supporting terms: 15 points each (medium value)
        baseScore += supportingTermsFound.length * 15;
        
        // Body signals: 20 points each (good confirmation)
        baseScore += bodySignalsFound.length * 20;
        
        // Question pattern match: 25 points
        for (const pattern of topicDef.questionPatterns || []) {
            if (pattern.test(headingText)) {
                baseScore += 25;
                break;
            }
        }
        
        // Co-occurrence bonus: reward multiple matches
        const totalMatches = coreTermsFound.length + supportingTermsFound.length;
        const cooccurrenceBonus = totalMatches > 1 
            ? (totalMatches - 1) * (topicDef.cooccurrenceBoost || 15)
            : 0;
        
        // Calculate final score
        const finalScore = Math.max(0, baseScore + cooccurrenceBonus - negativePenalty);
        
        // Determine confidence level
        let confidence: CandidateScore["confidence"] = "low";
        if (finalScore >= 80 && coreTermsFound.length >= 1) {
            confidence = "high";
        } else if (finalScore >= 50) {
            confidence = "medium";
        } else if (finalScore > 0) {
            confidence = "low";
        } else {
            confidence = "rejected";
        }
        
        return {
            score: finalScore,
            breakdown: {
                coreTermsFound,
                supportingTermsFound,
                negativeTermsFound,
                bodySignalsFound,
                baseScore,
                cooccurrenceBonus,
                negativePenalty,
                finalScore,
                confidence
            }
        };
    }

    /**
     * Enhanced heading detection that handles:
     * - Auto-numbered lists where number isn't in text
     * - All-caps text (robust check)
     * - Question-style headings
     * - Short title-case phrases
     */
    function detectClauseHeadingEnhanced(text: string, p: Word.Paragraph): boolean {
        const cleanText = text.trim();
        
        if (cleanText.length === 0) return false;
        if (cleanText.length > 150) return false; // Headings are short
        
        // SIGNAL 1: Manual numbering in text
        if (/^(\d+\.?\s+|\(\d+\)\s*|Section\s+\d+|Article\s+[IVX]+)/i.test(cleanText)) {
            return true;
        }
        
        // SIGNAL 2: Top-level list item (catches "17 INSURANCE" where 17 is auto-generated)
        if (p.isListItem) {
            try {
                const level = p.listItem.level;
                if (level <= 1 && cleanText.length < 100) {
                    return true; // Top-level list items with short text = headings
                }
            } catch (e) {}
        }
        
        // SIGNAL 3: All caps (robust check - only compare letters)
        const lettersOnly = cleanText.replace(/[^a-zA-Z]/g, '');
        if (lettersOnly.length >= 3 && lettersOnly.length < 50) {
            if (lettersOnly === lettersOnly.toUpperCase()) {
                return true;
            }
        }
        
        // SIGNAL 4: Question-style heading
        if (/^(what|when|how|who|where|why|can|does|will|should)\s/i.test(cleanText) && 
            cleanText.endsWith('?') && 
            cleanText.length < 80) {
            return true;
        }
        
        // SIGNAL 5: Short title-case phrase (3 words or fewer, starts with caps)
        if (/^[A-Z][a-z]+(\s+[A-Za-z]+){0,4}$/.test(cleanText) && cleanText.length < 50) {
            return true;
        }
        
        // SIGNAL 6: Standard legal section markers
        if (/^(WHEREAS|RECITALS|BACKGROUND|IN WITNESS|SCHEDULE|ANNEX|EXHIBIT|APPENDIX)/i.test(cleanText)) {
            return true;
        }
        
        return false;
    }

    /**
     * Asks the AI to find a clause by semantic meaning.
     * Used when lexical search fails.
     */
    async function findClauseByAI(
        context: Word.RequestContext,
        paragraphs: Word.ParagraphCollection,
        topicName: string,
        apiKey: string,
        model?: string
    ): Promise<{ paragraphId: number; clauseTitle: string } | null> {
        
        // Build a condensed structure map for the AI
        // Include paragraph ID, clause number (if any), and first 60 chars
        const structureLines: string[] = [];
        
        for (let i = 0; i < paragraphs.items.length; i++) {
            const p = paragraphs.items[i];
            const text = (p.text || "").trim();
            
            if (text.length < 5) continue;
            
            // Only include headings and first few paragraphs of each section
            const isHeading = detectClauseHeadingEnhanced(text, p);
            
            if (isHeading || structureLines.length < 100) {
                let clauseNum = "";
                if (p.isListItem) {
                    try {
                        clauseNum = p.listItem.listString || "";
                    } catch (e) {}
                }
                
                const prefix = clauseNum ? `[${clauseNum}]` : `[P${i + 1}]`;
                structureLines.push(`${prefix} ${text.substring(0, 80)}`);
            }
        }
        
        const structureMap = structureLines.slice(0, 150).join("\n");
        
        const prompt = "You are analyzing a contract structure to find where \"" + topicName + "\" is discussed.\n\n" +
            "DOCUMENT STRUCTURE:\n" + structureMap + "\n\n" +
            "YOUR TASK: Find the clause/section that discusses \"" + topicName + "\" or related concepts.\n\n" +
            "IMPORTANT:\n" +
            "- Look for semantic matches, not just the word \"" + topicName + "\"\n" +
            "- \"" + topicName + "\" might be called something different\n" +
            "- Return the paragraph number where this topic is discussed\n\n" +
            "Respond with ONLY a JSON object:\n" +
            "{\n" +
            "    \"found\": true/false,\n" +
            "    \"paragraphId\": <number>,\n" +
            "    \"clauseNumber\": \"<string or null>\",\n" +
            "    \"reasoning\": \"<brief explanation>\"\n" +
            "}";

        try {
            let responseText = "";
            
            if (providerConfig.provider === "claude") {
                const response = await fetch("https://api.anthropic.com/v1/messages", {
                    method: "POST",
                    headers: {
                        "x-api-key": apiKey,
                        "anthropic-version": "2023-06-01",
                        "anthropic-dangerous-direct-browser-access": "true",
                        "content-type": "application/json"
                    },
                    body: JSON.stringify({
                        model: model || "claude-sonnet-4-20250514",
                        max_tokens: 500,
                        messages: [{ role: "user", content: prompt }]
                    })
                });
                const data = await response.json();
                responseText = data.content?.[0]?.text?.trim() || "";
            } else {
                const cleanModel = (model || "gemini-2.0-flash-exp").replace(/^models\//, "");
                const url = `https://generativelanguage.googleapis.com/v1beta/models/${cleanModel}:generateContent?key=${apiKey}`;
                
                const response = await fetch(url, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }],
                        generationConfig: { responseMimeType: "application/json" }
                    })
                });
                const data = await response.json();
                responseText = data.candidates?.[0]?.content?.parts?.[0]?.text?.trim() || "";
            }
            
            // Parse AI response
            const parsed = tryParseJSON(responseText);
            
            if (parsed && parsed.found && parsed.paragraphId) {
                log(" AI semantic search found:", parsed.reasoning);
                
                // Validate the paragraph ID exists
                const idx = parsed.paragraphId - 1;
                if (idx >= 0 && idx < paragraphs.items.length) {
                    return {
                        paragraphId: parsed.paragraphId,
                        clauseTitle: parsed.clauseNumber 
                            ? `Clause ${parsed.clauseNumber}` 
                            : paragraphs.items[idx].text?.substring(0, 100) || "Found by AI"
                    };
                }
            }
            
            return null;
        } catch (e) {
            console.error("[Vibe] AI semantic search error:", e);
            return null;
        }
    }

    interface ClauseSearchResult {
        paragraphId: number;
        clauseTitle: string;
        confidence: number;      // 0-100
        method: "heading_exact" | "heading_synonym" | "heading_question" | 
                "body_peek" | "ai_semantic" | "fallback" |
                "context_aware_high" | "context_aware_medium" | "context_aware";
    }

    /**
     * Cascading search for clause by topic.
     * Tries fast lexical methods first, falls back to AI semantic search.
     */
    /**
     * Context-aware topic search V2 that:
     * 1. Collects ALL candidates (doesn't return early)
     * 2. Scores each with disambiguation logic
     * 3. Returns the highest-confidence match
     */
    async function findClauseByTopicCascading(
        context: Word.RequestContext,
        paragraphs: Word.ParagraphCollection,
        topicKey: string,
        apiKey?: string,
        model?: string
    ): Promise<ClauseSearchResult | null> {
        
        const topicDef = getTopicDefinition(topicKey);
        log(" Context-aware search for:", topicDef.primary);
        
        // Load paragraph data
        paragraphs.load("text, isListItem, style");
        await context.sync();
        
        for (let i = 0; i < paragraphs.items.length; i++) {
            if (paragraphs.items[i].isListItem) {
                paragraphs.items[i].listItem.load("level, listString");
            }
        }
        await context.sync();
        
        // ==========================================
        // COLLECT ALL CANDIDATES (don't return early!)
        // ==========================================
        const allCandidates: CandidateScore[] = [];
        
        for (let i = 0; i < paragraphs.items.length; i++) {
            const p = paragraphs.items[i];
            const headingText = (p.text || "").trim();
            
            if (headingText.length === 0 || headingText.length > 150) continue;
            
            // Check if this looks like a heading
            if (!detectClauseHeadingEnhanced(headingText, p)) continue;
            
            // Get clause number
            let clauseNumber: string | null = null;
            if (p.isListItem) {
                try {
                    clauseNumber = (p.listItem.listString || "").replace(/[\.\s]+$/, '').trim() || null;
                } catch (e) {}
            }
            
            // Get body text (next 1-3 paragraphs, up to 300 chars)
            let bodyText = "";
            for (let j = i + 1; j < Math.min(i + 4, paragraphs.items.length); j++) {
                const nextP = paragraphs.items[j];
                const nextText = (nextP.text || "").trim();
                
                // Stop if we hit another heading
                if (detectClauseHeadingEnhanced(nextText, nextP)) break;
                
                bodyText += " " + nextText;
                if (bodyText.length > 300) break;
            }
            bodyText = bodyText.substring(0, 300).trim();
            
            // Score this candidate using context-aware scoring
            const { score, breakdown } = scoreCandidate(headingText, bodyText, topicDef);
            
            // Skip rejected candidates
            if (score <= 0 || breakdown.confidence === "rejected") {
                continue;
            }
            
            log(" Candidate P" + (i + 1) + ": '" + headingText.substring(0, 40) + 
                        "' → score " + score + " (" + breakdown.confidence + ")");
            
            allCandidates.push({
                paragraphId: i + 1,
                headingText: headingText,
                clauseNumber: clauseNumber,
                coreTermsFound: breakdown.coreTermsFound || [],
                supportingTermsFound: breakdown.supportingTermsFound || [],
                negativeTermsFound: breakdown.negativeTermsFound || [],
                bodySignalsFound: breakdown.bodySignalsFound || [],
                baseScore: breakdown.baseScore || 0,
                cooccurrenceBonus: breakdown.cooccurrenceBonus || 0,
                negativePenalty: breakdown.negativePenalty || 0,
                finalScore: score,
                method: "context_aware",
                confidence: breakdown.confidence || "low"
            } as CandidateScore);
        }
        
        log(" Total candidates found:", allCandidates.length);
        
        // ==========================================
        // RANK AND SELECT BEST CANDIDATE
        // ==========================================
        if (allCandidates.length > 0) {
            // Sort by finalScore descending
            allCandidates.sort((a, b) => b.finalScore - a.finalScore);
            
            const best = allCandidates[0];
            
            // Log top 3 for debugging
            log(" Top candidates:");
            allCandidates.slice(0, 3).forEach((c, idx) => {
                log("  " + (idx + 1) + ". P" + c.paragraphId + " '" + c.headingText.substring(0, 30) + 
                            "' score=" + c.finalScore + " core=" + (c.coreTermsFound?.join(",") || "none"));
            });
            
            // Only accept if confidence is at least medium
            if (best.confidence === "high" || best.confidence === "medium") {
                const endOfSection = findEndOfClauseSection(paragraphs, best.paragraphId - 1, best.clauseNumber);
                
                return {
                    paragraphId: endOfSection,
                    clauseTitle: best.headingText.substring(0, 100),
                    confidence: best.finalScore,
                    method: ("context_aware_" + best.confidence) as ClauseSearchResult["method"]
                };
            }
            
            log(" Best candidate has low confidence, trying AI fallback...");
        }
        
        // ==========================================
        // AI FALLBACK (if lexical search insufficient)
        // ==========================================
        if (apiKey && allCandidates.length === 0) {
            log(" No lexical matches, trying AI semantic search...");
            
            const aiResult = await findClauseByAI(context, paragraphs, topicDef.primary, apiKey, model);
            if (aiResult) {
                return {
                    ...aiResult,
                    confidence: 40,
                    method: "ai_semantic"
                };
            }
        }
        
        // ==========================================
        // LAST RESORT: Return low-confidence match if we have one
        // ==========================================
        if (allCandidates.length > 0) {
            const fallback = allCandidates[0];
            log(" Returning low-confidence fallback: P" + fallback.paragraphId);
            
            const endOfSection = findEndOfClauseSection(paragraphs, fallback.paragraphId - 1, fallback.clauseNumber);
            return {
                paragraphId: endOfSection,
                clauseTitle: fallback.headingText.substring(0, 100),
                confidence: fallback.finalScore,
                method: "fallback"
            };
        }
        
        log(" All methods exhausted. No clause found for: " + topicDef.primary);
        return null;
    }

    /**
     * Helper: Escape regex special characters
     */
    function escapeRegex(str: string): string {
        return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }

    /**
     * Helper: Find the end of a clause section
     */
    function findEndOfClauseSection(paragraphs: Word.ParagraphCollection, startIdx: number, clauseNumber: string | null): number {
        // Simple heuristic: scan until next heading or end of doc
        // Start from the paragraph AFTER the heading
        let i = startIdx + 1;
        
        while (i < paragraphs.items.length) {
            const p = paragraphs.items[i];
            const text = (p.text || "").trim();
            
            if (text.length > 0) {
                // If we encounter another heading, stop
                if (detectClauseHeadingEnhanced(text, p)) {
                    // Try to be smart: if it's a sub-clause (e.g. 12.1 inside 12), continue
                    // But for safety, let's just stop at any major heading
                    return i; // Return the index of the start of the NEXT section (so insert BEFORE it)
                }
            }
            i++;
        }
        
        return paragraphs.items.length; // End of document
    }

    interface TextSpan {
        charStart: number;
        charEnd: number;
        textElement: Element;
        runElement: Element;
        paragraph: Element;
        container: Element;
        rPr: Element | null;
    }

    function applyRedlineToOxml(
        oxml: string,
        originalText: string,
        modifiedText: string
    ): { oxml: string; hasChanges: boolean } {
        const parser = new DOMParser();
        const serializer = new XMLSerializer();

        let xmlDoc;
        try {
            xmlDoc = parser.parseFromString(oxml, "text/xml");
        } catch (e) {
            console.error("[Engine] Failed to parse OXML:", e);
            return { oxml, hasChanges: false };
        }

        // ENHANCED: Use robust numbering detection
        const hasNumbering = hasNumberingInOxml(xmlDoc);
        
        // ENHANCED: Clean up AI response for numbered lists
        const cleanModifiedText = hasNumbering 
            ? sanitizeForNumberedList(originalText, modifiedText, true)
            : sanitizeAiResponse(modifiedText);

        if (cleanModifiedText.trim() === originalText.trim()) {
            return { oxml, hasChanges: false };
        }

        // Count paragraphs in OXML
        const allParagraphs = xmlDoc.getElementsByTagName("w:p");
        const oxmlParaCount = allParagraphs.length;
        
        // Count paragraphs in modified text (split by newlines)
        const modParas = cleanModifiedText.split(/\n/).filter(p => p.trim().length > 0);
        const modParaCount = modParas.length;

        // PARAGRAPH-AWARE MODE DETECTION
        // Use paragraph-aware mode when:
        // 1. Original has multiple paragraphs (>= 3)
        // 2. Paragraph count differs significantly (structure is changing)
        const isMultiParagraph = oxmlParaCount >= 3;
        const structureChanging = Math.abs(oxmlParaCount - modParaCount) >= 1;
        
        if (isMultiParagraph && structureChanging && hasNumbering) {
            log("[Engine] Using PARAGRAPH-AWARE mode: " + oxmlParaCount + " original paras, " + modParaCount + " modified paras");
            return applyParagraphAwareMode(xmlDoc, originalText, cleanModifiedText, serializer);
        }

        // EXPANDED DETECTION: Tables, Numbered Lists, OR Complex Structures
        const tables = xmlDoc.getElementsByTagName("w:tbl");
        const hasTables = tables.length > 0;
        
        // Other complex structures that need preservation
        const hasBookmarks = xmlDoc.getElementsByTagName("w:bookmarkStart").length > 0;
        const hasFields = xmlDoc.getElementsByTagName("w:fldChar").length > 0;
        const hasFootnotes = xmlDoc.getElementsByTagName("w:footnoteReference").length > 0;
        const hasEndnotes = xmlDoc.getElementsByTagName("w:endnoteReference").length > 0;
        const hasComments = xmlDoc.getElementsByTagName("w:commentRangeStart").length > 0;
        
        const needsSurgicalMode = 
            hasTables || 
            hasNumbering ||
            hasBookmarks ||
            hasFields ||
            hasFootnotes ||
            hasEndnotes ||
            hasComments;

        // Use surgical mode for any complex structure to preserve formatting
        if (needsSurgicalMode) {
            return applySurgicalMode(xmlDoc, originalText, cleanModifiedText, serializer);
        } else {
            return applyReconstructionMode(xmlDoc, originalText, cleanModifiedText, serializer);
        }
    }

    /**
     * Post-processes diffs to enforce whole-word boundaries for replacements.
     * 
     * Problem: diff_match_patch shares common character prefixes/suffixes.
     * Example: "Recipient" → "Receiving Party" becomes:
     *   [Equal: "Rec"], [Delete: "ipient"], [Insert: "eiving Party"]
     * 
     * Solution: Move shared prefix "Rec" to DELETE only (not INSERT, since
     * the AI already provided the complete replacement text).
     * Result: [Delete: "Recipient"], [Insert: "Receiving Party"]
     */
    function cleanupDiffsToWords(diffs: [number, string][]): [number, string][] {
        if (diffs.length < 2) return diffs;
        
        const isWordChar = (c: string) => /[a-zA-Z0-9]/.test(c);
        
        // Work on a copy to avoid mutation issues
        const workingDiffs: [number, string][] = diffs.map(d => [d[0], d[1]]);
        const result: [number, string][] = [];
        
        for (let i = 0; i < workingDiffs.length; i++) {
            const [op, text] = workingDiffs[i];
            
            if (op === 0) {
                // EQUAL segment
                let equalText = text;
                
                // Pattern: [EQUAL: "...Rec"] [DELETE: "ipient"] [INSERT: "eiving Party"]
                // We need: [EQUAL: "..."] [DELETE: "Recipient"] [INSERT: "Receiving Party"]
                // So we add shared prefix to BOTH DELETE and INSERT
                
                // Check if next is a DELETE that starts with word chars
                // and this EQUAL ends with word chars (shared word prefix)
                if (i + 1 < workingDiffs.length && workingDiffs[i + 1][0] === -1) {
                    const deleteText = workingDiffs[i + 1][1];
                    
                    if (equalText.length > 0 && isWordChar(equalText.slice(-1)) &&
                        deleteText.length > 0 && isWordChar(deleteText[0])) {
                        
                        // Find the word at the end of EQUAL
                        let wordStart = equalText.length;
                        while (wordStart > 0 && isWordChar(equalText[wordStart - 1])) {
                            wordStart--;
                        }
                        const sharedPrefix = equalText.substring(wordStart);
                        
                        if (sharedPrefix.length > 0) {
                            // DUAL-EXPANSION FIX: Move shared prefix to DELETE
                            workingDiffs[i + 1] = [-1, sharedPrefix + deleteText];
                            
                            // Check if there's an INSERT following the DELETE
                            if (i + 2 < workingDiffs.length && workingDiffs[i + 2][0] === 1) {
                                const insertText = workingDiffs[i + 2][1];
                                if (insertText.length > 0 && isWordChar(insertText[0])) {
                                    // Normal case: Add prefix to existing INSERT
                                    workingDiffs[i + 2] = [1, sharedPrefix + insertText];
                                }
                            } else {
                                // DUAL-EXPANSION FIX (CRITICAL): No INSERT follows!
                                // This is the case like "laws" -> "law" where:
                                // - DELETE was just "s" (now expanded to "laws")
                                // - We need to INSERT "law" to preserve the unchanged portion
                                // CREATE an INSERT with the sharedPrefix (the unchanged part)
                                log("[DualExpansion] No INSERT follows DELETE - creating INSERT for: " + sharedPrefix);
                                
                                // Insert a new INSERT operation right after DELETE
                                workingDiffs.splice(i + 2, 0, [1, sharedPrefix]);
                            }
                            
                            equalText = equalText.substring(0, wordStart);
                        }
                    }
                }
                
                // Handle suffix: [DELETE: ...word] [INSERT: ...word] [EQUAL: "rest..."]
                // Check if previous was INSERT ending in word char and we start with word char
                if (result.length > 0 && equalText.length > 0) {
                    const lastResult = result[result.length - 1];
                    
                    if (lastResult[0] === 1 && lastResult[1].length > 0 && 
                        isWordChar(lastResult[1].slice(-1)) && isWordChar(equalText[0])) {
                        
                        // Find the word at the start of EQUAL
                        let wordEnd = 0;
                        while (wordEnd < equalText.length && isWordChar(equalText[wordEnd])) {
                            wordEnd++;
                        }
                        const sharedSuffix = equalText.substring(0, wordEnd);
                        
                        if (sharedSuffix.length > 0) {
                            // Add suffix to INSERT
                            result[result.length - 1] = [1, lastResult[1] + sharedSuffix];
                            
                            // Also add to DELETE if it's right before the INSERT
                            if (result.length >= 2 && result[result.length - 2][0] === -1) {
                                const prevDelete = result[result.length - 2][1];
                                if (prevDelete.length > 0 && isWordChar(prevDelete.slice(-1))) {
                                    result[result.length - 2] = [-1, prevDelete + sharedSuffix];
                                }
                            }
                            
                            equalText = equalText.substring(wordEnd);
                        }
                    }
                }
                
                if (equalText.length > 0) {
                    result.push([0, equalText]);
                }
            } else {
                result.push([op, text]);
            }
        }
        
        // Second pass: merge adjacent same-type operations
        const merged: [number, string][] = [];
        for (const [op, text] of result) {
            if (text.length === 0) continue;
            
            if (merged.length > 0 && merged[merged.length - 1][0] === op) {
                merged[merged.length - 1] = [op, merged[merged.length - 1][1] + text];
            } else {
                merged.push([op, text]);
            }
        }
        
        return merged;
    }

    /**
     * PARAGRAPH-AWARE MODE for multi-paragraph clause amendments.
     * 
     * Unlike surgical mode (which preserves paragraph structure), this mode:
     * 1. Splits original and modified text into paragraphs
     * 2. Uses similarity matching to pair paragraphs
     * 3. Applies character-level diffs to matched paragraphs
     * 4. Wraps deleted paragraphs in w:del (preserving structure for track changes)
     * 5. Inserts new paragraphs with w:ins wrapper
     * 
     * This allows proper "delete entire sub-clause" behavior.
     */
    function applyParagraphAwareMode(
        xmlDoc: Document,
        originalText: string,
        modifiedText: string,
        serializer: XMLSerializer
    ): { oxml: string; hasChanges: boolean } {
        const allParagraphs = Array.from(xmlDoc.getElementsByTagName("w:p"));
        if (allParagraphs.length === 0) {
            logWarn("[Engine] No paragraphs found in OXML");
            return { oxml: serializer.serializeToString(xmlDoc), hasChanges: false };
        }

        // Extract text from each paragraph in the OXML
        const oxmlParaTexts: string[] = [];
        const oxmlParaElements: Element[] = [];
        
        for (const p of allParagraphs) {
            let paraText = "";
            const runs = p.getElementsByTagName("w:t");
            for (let i = 0; i < runs.length; i++) {
                paraText += runs[i].textContent || "";
            }
            oxmlParaTexts.push(paraText.trim());
            oxmlParaElements.push(p as Element);
        }

        // Split modified text into paragraphs (by newline)
        const modifiedParas = modifiedText.split(/\n/).map(p => p.trim()).filter(p => p.length > 0);
        
        log("[Engine] Paragraph-aware mode: " + oxmlParaTexts.length + " original, " + modifiedParas.length + " modified");

        // ==========================================================
        // ID ECHO PROTOCOL: PRIMARY MATCHING STRATEGY
        // If modified text contains <P#> tags, use them for deterministic matching
        // ==========================================================
        const hasIdTags = /<P\d+>/.test(modifiedText);
        
        interface ParaMatch {
            origIdx: number;
            modIdx: number;
            score: number;
        }
        
        const matches: ParaMatch[] = [];
        const usedOrig = new Set<number>();
        const usedMod = new Set<number>();
        
        if (hasIdTags) {
            log("[Engine] ID Echo Protocol: parsing ID tags for deterministic matching");
            
            // Parse tagged text: <P38>content</P38>
            const tagPattern = /<P(\d+)>([\s\S]*?)<\/P\1>/g;
            let tagMatch;
            const modifiedById = new Map<number, { idx: number; content: string }>();
            
            // First, extract all tagged content
            let modIdx = 0;
            while ((tagMatch = tagPattern.exec(modifiedText)) !== null) {
                const paraId = parseInt(tagMatch[1], 10);
                const content = tagMatch[2].trim();
                modifiedById.set(paraId, { idx: modIdx, content });
                modIdx++;
            }
            
            log("[Engine] Found " + modifiedById.size + " tagged paragraphs in modified text");
            
            // Match by ID: OXML paragraph index corresponds to ID (1-indexed)
            // Note: We don't know the actual IDs in the OXML, but we can match by order
            // The caller should have ensured IDs align with paragraph positions
            for (const [paraId, modInfo] of modifiedById.entries()) {
                // Try to find this ID in original paragraphs
                // Since we don't have explicit IDs in OXML, match by position if within range
                const origIdx = paraId - 1; // Convert 1-indexed to 0-indexed
                
                if (origIdx >= 0 && origIdx < oxmlParaTexts.length) {
                    matches.push({ origIdx, modIdx: modInfo.idx, score: 1.0 });
                    usedOrig.add(origIdx);
                    usedMod.add(modInfo.idx);
                    log("[Engine] ID match: P" + paraId + " → OXML[" + origIdx + "]");
                }
            }
            
            log("[Engine] ID Echo matched " + matches.length + " paragraphs deterministically");
        }
        
        // ==========================================================
        // FALLBACK: Fuzzy similarity matching (when no ID tags present)
        // ==========================================================
        if (!hasIdTags || matches.length === 0) {
            log("[Engine] Using fuzzy similarity matching (no ID tags or no matches)");
            
            const matchThreshold = 0.3; // 30% similarity needed
            
            function normalizeForComparison(text: string): string {
                return text
                    .replace(/^\s*\d+(\.\d+)*\.?\s*/g, '')
                    .replace(/^\s*\([a-z]\)\s*/gi, '')
                    .replace(/^\s*[a-z]\)\s*/gi, '')
                    .replace(/\*\*(.+?)\*\*/g, '$1')
                    .toLowerCase()
                    .trim();
            }
            
            function similarity(a: string, b: string): number {
                if (!a || !b) return 0;
                const aNorm = normalizeForComparison(a);
                const bNorm = normalizeForComparison(b);
                if (aNorm === bNorm) return 1.0;
                if (!aNorm || !bNorm) return 0;
                
                const aWords = new Set(aNorm.split(/\s+/).filter(w => w.length > 2));
                const bWords = new Set(bNorm.split(/\s+/).filter(w => w.length > 2));
                if (aWords.size === 0 || bWords.size === 0) return 0;
                
                let overlap = 0;
                for (const word of aWords) {
                    if (bWords.has(word)) overlap++;
                }
                return overlap / Math.max(aWords.size, bWords.size);
            }
            
            // Build match matrix
            const allScores: ParaMatch[] = [];
            for (let i = 0; i < oxmlParaTexts.length; i++) {
                if (usedOrig.has(i)) continue;
                for (let j = 0; j < modifiedParas.length; j++) {
                    if (usedMod.has(j)) continue;
                    const score = similarity(oxmlParaTexts[i], modifiedParas[j]);
                    if (score >= matchThreshold) {
                        allScores.push({ origIdx: i, modIdx: j, score });
                    }
                }
            }
            
            allScores.sort((a, b) => {
                if (b.score !== a.score) return b.score - a.score;
                return (a.origIdx + a.modIdx) - (b.origIdx + b.modIdx);
            });

            for (const m of allScores) {
                if (!usedOrig.has(m.origIdx) && !usedMod.has(m.modIdx)) {
                    matches.push(m);
                    usedOrig.add(m.origIdx);
                    usedMod.add(m.modIdx);
                }
            }
        }

        log("[Engine] Matched " + matches.length + " paragraph pairs");

        // STEP 2: Process each original paragraph
        let hasChanges = false;
        
        for (let i = 0; i < oxmlParaElements.length; i++) {
            const p = oxmlParaElements[i];
            const match = matches.find(m => m.origIdx === i);
            
            if (!match) {
                // This paragraph is DELETED - wrap all runs in w:del
                log("[Engine] Deleting paragraph " + i + ": " + oxmlParaTexts[i].substring(0, 40) + "...");
                wrapParagraphContentInDel(xmlDoc, p);
                hasChanges = true;
            } else {
                // This paragraph is MATCHED - apply character-level diff
                const modText = modifiedParas[match.modIdx];
                const origText = oxmlParaTexts[i];
                
                if (modText.trim() !== origText.trim()) {
                    log("[Engine] Modifying paragraph " + i);
                    applyCharacterDiffToParagraph(xmlDoc, p, origText, modText);
                    hasChanges = true;
                }
                // else: unchanged, leave as-is
            }
        }

        // STEP 3: Handle NEW paragraphs (in modified but not in original)
        // For simplicity, append new paragraphs after the last matched paragraph
        const newParaIndices: number[] = [];
        for (let j = 0; j < modifiedParas.length; j++) {
            if (!usedMod.has(j)) {
                newParaIndices.push(j);
            }
        }

        if (newParaIndices.length > 0) {
            log("[Engine] " + newParaIndices.length + " new paragraphs to insert");
            const lastPara = oxmlParaElements[oxmlParaElements.length - 1];
            const lastParaParent = lastPara.parentNode;
            
            // Get reference rPr from last paragraph for styling
            let refRPr: Element | null = null;
            const lastRuns = lastPara.getElementsByTagName("w:r");
            if (lastRuns.length > 0) {
                refRPr = lastRuns[0].getElementsByTagName("w:rPr")[0] as Element || null;
            }

            for (const idx of newParaIndices) {
                const newText = modifiedParas[idx];
                const newP = createInsertedParagraph(xmlDoc, newText, refRPr);
                if (lastParaParent && lastPara.nextSibling) {
                    lastParaParent.insertBefore(newP, lastPara.nextSibling);
                } else if (lastParaParent) {
                    lastParaParent.appendChild(newP);
                }
                hasChanges = true;
            }
        }

        return { oxml: serializer.serializeToString(xmlDoc), hasChanges };
    }

    /**
     * Wraps all text content in a paragraph with w:del (deletion track change).
     * Uses createElementNS for proper namespace binding to ensure Word renders Track Changes.
     */
    function wrapParagraphContentInDel(xmlDoc: Document, p: Element): void {
        const runs = Array.from(p.getElementsByTagName("w:r"));
        
        for (const r of runs) {
            // Skip if already in a del wrapper
            if (r.parentNode?.nodeName === "w:del") continue;
            
            const parent = r.parentNode;
            if (!parent) continue;
            
            // Convert w:t to w:delText (namespace-compliant)
            const textNodes = r.getElementsByTagName("w:t");
            for (let i = 0; i < textNodes.length; i++) {
                const t = textNodes[i];
                const delText = xmlDoc.createElementNS(WORD_NS, "w:delText");
                delText.textContent = t.textContent;
                delText.setAttribute("xml:space", "preserve");
                t.parentNode?.replaceChild(delText, t);
            }
            
            // Wrap run in w:del (namespace-compliant)
            const delWrapper = xmlDoc.createElementNS(WORD_NS, "w:del");
            delWrapper.setAttribute("w:id", Math.floor(Math.random() * 10000).toString());
            delWrapper.setAttribute("w:author", getTrackChangeAuthor());
            delWrapper.setAttribute("w:date", new Date().toISOString());
            
            parent.insertBefore(delWrapper, r);
            delWrapper.appendChild(r);
        }
    }

    /**
     * Apply character-level diff to a single paragraph's content.
     */
    function applyCharacterDiffToParagraph(xmlDoc: Document, p: Element, origText: string, modText: string): void {
        // Collect all text runs
        const runs = Array.from(p.getElementsByTagName("w:r"));
        if (runs.length === 0) return;
        
        // Get reference rPr from first run
        const refRPr = runs[0].getElementsByTagName("w:rPr")[0] as Element || null;
        
        // Build parent reference
        const firstRun = runs[0];
        const parent = firstRun.parentNode;
        if (!parent) return;
        
        // Remove all existing runs
        for (const r of runs) {
            if (r.parentNode) r.parentNode.removeChild(r);
        }
        
        // Compute diff
        const dmp = new diff_match_patch();
        const diffs = dmp.diff_main(origText, modText);
        dmp.diff_cleanupSemantic(diffs);
        const cleanedDiffs = cleanupDiffsToWords(diffs);
        
        // Build new runs from diff
        for (const [op, text] of cleanedDiffs) {
            if (text.length === 0) continue;
            
            if (op === 0) {
                // EQUAL - plain text
                const run = createTextRun(xmlDoc, text, refRPr, false);
                parent.appendChild(run);
            } else if (op === -1) {
                // DELETE
                const delRun = createTextRun(xmlDoc, text, refRPr, true);
                const delWrapper = createTrackChange(xmlDoc, "del", delRun);
                parent.appendChild(delWrapper);
            } else if (op === 1) {
                // INSERT
                const insRun = createTextRun(xmlDoc, text, refRPr, false);
                const insWrapper = createTrackChange(xmlDoc, "ins", insRun);
                parent.appendChild(insWrapper);
            }
        }
    }

    /**
     * NAMESPACE SAFETY: Wrap OXML fragment in proper package structure.
     * Prevents "InvalidArgument" errors from insertOoxml by including
     * all required namespace declarations.
     */
    function wrapInOoxmlPackage(xmlContent: string): string {
        // Check if already wrapped
        if (xmlContent.includes('pkg:package') || xmlContent.includes('xmlns:w=')) {
            return xmlContent;
        }
        
        const header = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>';
        const pkgOpen = '<pkg:package xmlns:pkg="http://schemas.microsoft.com/office/2006/xmlPackage">';
        const partOpen = '<pkg:part pkg:name="/word/document.xml" pkg:contentType="application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml">';
        const dataOpen = '<pkg:xmlData>';
        const docOpen = '<w:document xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:w14="http://schemas.microsoft.com/office/word/2010/wordml">';
        const bodyOpen = '<w:body>';
        const bodyClose = '</w:body>';
        const docClose = '</w:document>';
        const dataClose = '</pkg:xmlData>';
        const partClose = '</pkg:part>';
        const pkgClose = '</pkg:package>';
        
        return header + pkgOpen + partOpen + dataOpen + docOpen + bodyOpen + xmlContent + bodyClose + docClose + dataClose + partClose + pkgClose;
    }

    /**
     * Create a new paragraph with inserted text (wrapped in w:ins).
     */
    function createInsertedParagraph(xmlDoc: Document, text: string, refRPr: Element | null): Element {
        const p = xmlDoc.createElement("w:p");
        
        // Create text run
        const r = xmlDoc.createElement("w:r");
        if (refRPr) {
            r.appendChild(refRPr.cloneNode(true));
        }
        const t = xmlDoc.createElement("w:t");
        t.textContent = text;
        t.setAttribute("xml:space", "preserve");
        r.appendChild(t);
        
        // Wrap in w:ins
        const insWrapper = xmlDoc.createElement("w:ins");
        insWrapper.setAttribute("w:id", Math.floor(Math.random() * 10000).toString());
        insWrapper.setAttribute("w:author", getTrackChangeAuthor());
        insWrapper.setAttribute("w:date", new Date().toISOString());
        insWrapper.appendChild(r);
        
        p.appendChild(insWrapper);
        return p;
    }

    /**
     * Process paragraph operations from AI (KEEP/AMEND/DELETE/INSERT_AFTER).
     * 
     * @param operations - Array of { id: "P1595", action: "AMEND", new_text?: "..." }
     * @param lookup - Paragraph lookup map { 1: Word.Paragraph, 2: Word.Paragraph, ... }
     * @param context - Word.RequestContext
     * @returns Number of changes applied
     */
    async function processParaOperations(
        operations: any[],
        lookup: { [key: number]: Word.Paragraph },
        context: Word.RequestContext
    ): Promise<number> {
        let changeCount = 0;
        
        // Sort operations: DELETE last (top-down), INSERT_AFTER before DELETE
        // Process in order: KEEP → AMEND → INSERT_AFTER → DELETE
        const keepOps = operations.filter(op => op.action === "KEEP");
        const amendOps = operations.filter(op => op.action === "AMEND");
        const insertOps = operations.filter(op => op.action === "INSERT_AFTER");
        const deleteOps = operations.filter(op => op.action === "DELETE");
        
        // Process ordered ops
        const orderedOps = [...keepOps, ...amendOps, ...insertOps, ...deleteOps];
        
        for (const op of orderedOps) {
            try {
                // Extract paragraph ID number - handle both "P1595" string and 1595 number
                const idStr = String(op.id || "");
                const idMatch = idStr.match(/P?(\d+)/i);
                if (!idMatch) {
                    logWarn(" Invalid paragraph ID:", op.id);
                    continue;
                }
                const paraId = parseInt(idMatch[1], 10);
                const para = lookup[paraId];
                
                if (!para) {
                    logWarn(" Paragraph not found:", paraId);
                    continue;
                }
                
                if (op.action === "KEEP") {
                    // No operation needed
                    log(" KEEP P" + paraId);
                    continue;
                }
                
                if (op.action === "AMEND") {
                    // Flexible property extraction for new text
                    const newTextRaw = op.new_text || op.newText || op.text || op.amended_text;
                    
                    if (!newTextRaw) {
                        logWarn(" AMEND P" + paraId + ": missing new_text property", op);
                        continue;
                    }
                    
                    log(" AMEND P" + paraId);
                    
                    // Get current paragraph text and OXML
                    para.load("text");
                    const paraOxml = para.getOoxml();
                    await context.sync();
                    
                    const originalText = para.text.trim();
                    const newText = sanitizeAiResponse(newTextRaw);
                    
                    log(" AMEND P" + paraId + " - Original: " + originalText.substring(0, 50) + "...");
                    log(" AMEND P" + paraId + " - New: " + newText.substring(0, 50) + "...");
                    
                    if (originalText === newText) {
                        log(" AMEND P" + paraId + ": no changes detected");
                        continue;
                    }
                    
                    // Apply character-level diff
                    const parser = new DOMParser();
                    const serializer = new XMLSerializer();
                    const xmlDoc = parser.parseFromString(paraOxml.value, "text/xml");
                    
                    const pElements = xmlDoc.getElementsByTagName("w:p");
                    if (pElements.length > 0) {
                        applyCharacterDiffToParagraph(xmlDoc, pElements[0] as Element, originalText, newText);
                        
                        // Replace paragraph content
                        const newOxml = serializer.serializeToString(xmlDoc);
                        para.insertOoxml(newOxml, Word.InsertLocation.replace);
                        await context.sync();
                        changeCount++;
                        log(" AMEND P" + paraId + ": applied successfully");
                        
                        // AUTO-SCROLL: Show the amended paragraph
                        const amendedRange = para.getRange();
                        await scrollToRange(amendedRange, context);
                        await scrollDelay(150);
                        
                        // Record delta for ID tracking (AMEND = no shift)
                        deltaRecordModify(paraId, originalText, newText);
                    }
                }
                
                if (op.action === "DELETE") {
                    log(" DELETE P" + paraId + (op.reason ? " (" + op.reason + ")" : ""));
                    
                    // Get paragraph OXML
                    const paraOxml = para.getOoxml();
                    await context.sync();
                    
                    // Wrap content in w:del
                    const parser = new DOMParser();
                    const serializer = new XMLSerializer();
                    const xmlDoc = parser.parseFromString(paraOxml.value, "text/xml");
                    
                    const pElements = xmlDoc.getElementsByTagName("w:p");
                    if (pElements.length > 0) {
                        wrapParagraphContentInDel(xmlDoc, pElements[0] as Element);
                        
                        const newOxml = serializer.serializeToString(xmlDoc);
                        para.insertOoxml(newOxml, Word.InsertLocation.replace);
                        await context.sync();
                        changeCount++;
                        
                        // Record delta for ID tracking (DELETE = shift -1)
                        deltaRecordDelete(paraId, para.text || "");
                    }
                }
                
                if (op.action === "INSERT_AFTER") {
                    // Flexible property extraction for new text
                    const newTextRaw = op.new_text || op.newText || op.text;
                    
                    if (!newTextRaw) {
                        logWarn(" INSERT_AFTER P" + paraId + ": missing new_text property", op);
                        continue;
                    }
                    
                    log(" INSERT_AFTER P" + paraId);
                    
                    const cleanText = sanitizeAiResponse(newTextRaw);
                    
                    // Use insertParagraph which is more reliable than insertOoxml for new paragraphs
                    // The track change will be recorded by Word if track changes is on
                    const newPara = para.insertParagraph(cleanText, Word.InsertLocation.after);
                    newPara.load("text");
                    await context.sync();
                    
                    log(" INSERT_AFTER P" + paraId + ": inserted new paragraph");
                    changeCount++;
                    
                    // Record delta for ID tracking (INSERT = shift +1)
                    deltaRecordInsert(paraId + 1, cleanText);
                }
                
            } catch (e) {
                console.error("[Vibe] Para operation error:", op.id, op.action, e);
            }
        }
        
        return changeCount;
    }

    function applySurgicalMode(xmlDoc, originalText, modifiedText, serializer) {
        let fullText = "";
        const textSpans: TextSpan[] = [];

        const allParagraphs = Array.from(xmlDoc.getElementsByTagName("w:p"));
        
        // SAFETY: Backup pPr (especially numPr) before modification
        const pPrBackup = new Map<number, Element>();
        allParagraphs.forEach((p: Element, idx) => {
            const pPr = p.getElementsByTagName("w:pPr")[0];
            if (pPr) {
                pPrBackup.set(idx, pPr.cloneNode(true) as Element);
            }
        });

        allParagraphs.forEach((p: Element, pIndex) => {
            const container = p.parentNode as Element;

            Array.from(p.childNodes).forEach(child => {
                if (child.nodeName === "w:r") {
                    const r = child as Element;
                    const rPr = r.getElementsByTagName("w:rPr")[0] || null;
                    Array.from(r.childNodes).forEach(rc => {
                        if (rc.nodeName === "w:t") {
                            const t = rc as Element;
                            const text = t.textContent || "";
                            if (text.length > 0) {
                                textSpans.push({ charStart: fullText.length, charEnd: fullText.length + text.length, textElement: t, runElement: r, paragraph: p, container, rPr });
                                fullText += text;
                            }
                        }
                    });
                } else if (child.nodeName === "w:hyperlink") {
                    Array.from(child.childNodes).forEach(hc => {
                        if (hc.nodeName === "w:r") {
                            const r = hc as Element;
                            const rPr = r.getElementsByTagName("w:rPr")[0] || null;
                            Array.from(r.childNodes).forEach(rc => {
                                if (rc.nodeName === "w:t") {
                                    const t = rc as Element;
                                    const text = t.textContent || "";
                                    if (text.length > 0) {
                                        textSpans.push({ charStart: fullText.length, charEnd: fullText.length + text.length, textElement: t, runElement: r, paragraph: p, container, rPr });
                                        fullText += text;
                                    }
                                }
                            });
                        }
                    });
                }
            });
            if (pIndex < allParagraphs.length - 1) fullText += "\n";
        });

        const dmp = new diff_match_patch();
        const diffs = dmp.diff_main(fullText, modifiedText);
        dmp.diff_cleanupSemantic(diffs);
        
        // Post-process to ensure whole-word replacements
        const wordCleanedDiffs = cleanupDiffsToWords(diffs);

        let currentPos = 0;
        const processedSpans = new Set();

        for (const diff of wordCleanedDiffs) {
            const [op, text] = diff;
            if (op === 0) {
                currentPos += text.length;
            } else if (op === -1) {
                processDelete(xmlDoc, textSpans, currentPos, currentPos + text.length, processedSpans);
                currentPos += text.length;
            } else if (op === 1) {
                const textWithoutNewlines = text.replace(/\n/g, ' ');
                if (textWithoutNewlines.trim().length > 0) {
                    processInsert(xmlDoc, textSpans, currentPos, textWithoutNewlines, processedSpans);
                }
            }
        }

        // SAFETY: Restore pPr/numPr if accidentally removed during processing
        const updatedParagraphs = Array.from(xmlDoc.getElementsByTagName("w:p"));
        updatedParagraphs.forEach((p: Element, idx) => {
            const currentPPr = p.getElementsByTagName("w:pPr")[0];
            const backupPPr = pPrBackup.get(idx);
            
            if (!currentPPr && backupPPr) {
                // pPr was removed - restore it
                logWarn("[Engine] Restoring lost pPr for paragraph", idx);
                p.insertBefore(backupPPr, p.firstChild);
            } else if (currentPPr && backupPPr) {
                // Ensure numPr wasn't stripped
                const currentNumPr = currentPPr.getElementsByTagName("w:numPr")[0];
                const backupNumPr = backupPPr.getElementsByTagName("w:numPr")[0];
                
                if (!currentNumPr && backupNumPr) {
                    logWarn("[Engine] Restoring lost numPr for paragraph", idx);
                    currentPPr.insertBefore(backupNumPr.cloneNode(true), currentPPr.firstChild);
                }
            }
        });

        return { oxml: serializer.serializeToString(xmlDoc), hasChanges: true };
    }

    function processDelete(xmlDoc, textSpans, startPos, endPos, processedSpans) {
        const affectedSpans = textSpans.filter(s => s.charEnd > startPos && s.charStart < endPos);

        for (const span of affectedSpans) {
            if (processedSpans.has(span.textElement)) continue;

            const deleteStart = Math.max(0, startPos - span.charStart);
            const deleteEnd = Math.min(span.charEnd - span.charStart, endPos - span.charStart);

            const originalText = span.textElement.textContent || "";
            const beforeText = originalText.substring(0, deleteStart);
            const deletedText = originalText.substring(deleteStart, deleteEnd);
            const afterText = originalText.substring(deleteEnd);

            if (deletedText.length === 0) continue;

            const parent = span.runElement.parentNode;
            if (!parent) continue;

            if (beforeText.length === 0 && afterText.length === 0) {
                const delRun = createTextRun(xmlDoc, deletedText, span.rPr, true);
                const delWrapper = createTrackChange(xmlDoc, 'del', delRun);
                parent.insertBefore(delWrapper, span.runElement);
                parent.removeChild(span.runElement);
            } else {
                if (beforeText.length > 0) {
                    const beforeRun = createTextRun(xmlDoc, beforeText, span.rPr, false);
                    parent.insertBefore(beforeRun, span.runElement);
                }
                const delRun = createTextRun(xmlDoc, deletedText, span.rPr, true);
                const delWrapper = createTrackChange(xmlDoc, 'del', delRun);
                parent.insertBefore(delWrapper, span.runElement);
                if (afterText.length > 0) {
                    const afterRun = createTextRun(xmlDoc, afterText, span.rPr, false);
                    parent.insertBefore(afterRun, span.runElement);
                }
                parent.removeChild(span.runElement);
            }
            processedSpans.add(span.textElement);
        }
    }

    function processInsert(xmlDoc, textSpans, pos, text, processedSpans) {
        let targetSpan = textSpans.find(s => pos >= s.charStart && pos < s.charEnd);

        if (!targetSpan && pos > 0) {
            targetSpan = textSpans.find(s => pos === s.charEnd);
        }

        if (!targetSpan && pos > 0) {
            targetSpan = textSpans.find(s => s.charEnd <= pos);
            if (!targetSpan && textSpans.length > 0) {
                const before = textSpans.filter(s => s.charEnd <= pos);
                if (before.length > 0) {
                    targetSpan = before[before.length - 1];
                }
            }
        }

        if (!targetSpan && textSpans.length > 0) {
            targetSpan = textSpans[textSpans.length - 1];
        }

        if (targetSpan) {
            const rPr = targetSpan.rPr;
            const insRun = createTextRun(xmlDoc, text, rPr, false);
            const insWrapper = createTrackChange(xmlDoc, 'ins', insRun);
            const parent = targetSpan.runElement.parentNode;
            if (parent) parent.insertBefore(insWrapper, targetSpan.runElement.nextSibling);
        }
    }

    // RECONSTRUCTION MODE (Restored from Legacy Vibe 3.3 Stable)
    function applyReconstructionMode(xmlDoc, originalText, modifiedText, serializer) {
        const body = xmlDoc.getElementsByTagName("w:body")[0] || xmlDoc.documentElement;
        const paragraphs = Array.from(xmlDoc.getElementsByTagName("w:p"));

        if (paragraphs.length === 0) return { oxml: serializer.serializeToString(xmlDoc), hasChanges: false };

        let originalFullText = "";
        const propertyMap = [];
        const paragraphMap = [];
        const sentinelMap = [];
        const referenceMap = new Map();
        const tokenToCharMap = new Map();
        let nextCharCode = 0xe000;

        const uniqueContainers = new Set();
        const replacementContainers = new Map();

        paragraphs.forEach((p, pIndex) => {
            const pStart = originalFullText.length;
            const children = Array.from(p.childNodes);

            children.forEach((child) => {
                if (child.nodeName === "w:r") {
                    const r = child;
                    const rPr = r.getElementsByTagName("w:rPr")[0] || null;
                    const runChildren = Array.from(r.childNodes);

                    runChildren.forEach((rc) => {
                        if (rc.nodeName === "w:t") {
                            const textContent = rc.textContent || "";
                            if (textContent.length > 0) {
                                propertyMap.push({
                                    start: originalFullText.length,
                                    end: originalFullText.length + textContent.length,
                                    rPr: rPr,
                                });
                                originalFullText += textContent;
                            }
                        } else if (["w:drawing", "w:pict", "w:object", "w:fldChar", "w:instrText"].includes(rc.nodeName)) {
                            const rcElement = rc;
                            const txbxContent = rcElement.getElementsByTagName("w:txbxContent")[0];
                            const hasTextBox = rc.nodeName === "w:pict" && !!txbxContent;

                            if (hasTextBox) {
                                sentinelMap.push({
                                    start: originalFullText.length,
                                    node: rc,
                                    isTextBox: true,
                                    originalContainer: txbxContent,
                                });
                                originalFullText += "\uFFFC";
                                propertyMap.push({ start: originalFullText.length - 1, end: originalFullText.length, rPr: rPr });
                            } else {
                                sentinelMap.push({ start: originalFullText.length, node: rc });
                                originalFullText += "\uFFFC";
                                propertyMap.push({ start: originalFullText.length - 1, end: originalFullText.length, rPr: rPr });
                            }
                        } else if (rc.nodeName === "w:footnoteReference" || rc.nodeName === "w:endnoteReference") {
                            const ref = rc;
                            const id = ref.getAttribute("w:id");
                            if (id) {
                                const type = rc.nodeName === "w:footnoteReference" ? "FN" : "EN";
                                const tokenString = `{{__${type}_${id}__}}`;
                                const char = String.fromCharCode(nextCharCode++);
                                referenceMap.set(char, rc);
                                tokenToCharMap.set(tokenString, char);
                                originalFullText += char;
                                propertyMap.push({ start: originalFullText.length - 1, end: originalFullText.length, rPr: rPr });
                            }
                        }
                    });
                } else if (child.nodeName === "w:hyperlink") {
                    const h = child;
                    const hChildren = Array.from(h.childNodes);
                    hChildren.forEach((hc) => {
                        if (hc.nodeName === "w:r") {
                            const r = hc;
                            const rPr = r.getElementsByTagName("w:rPr")[0] || null;
                            const texts = Array.from(r.getElementsByTagName("w:t"));
                            texts.forEach((t) => {
                                const textContent = t.textContent || "";
                                if (textContent.length > 0) {
                                    propertyMap.push({
                                        start: originalFullText.length,
                                        end: originalFullText.length + textContent.length,
                                        rPr: rPr,
                                        wrapper: h,
                                    });
                                    originalFullText += textContent;
                                }
                            });
                        }
                    });
                } else if (["w:sdt", "w:oMath", "m:oMath", "w:bookmarkStart", "w:bookmarkEnd"].includes(child.nodeName)) {
                    sentinelMap.push({ start: originalFullText.length, node: child });
                    originalFullText += "\uFFFC";
                }
            });

            if (pIndex < paragraphs.length - 1) {
                originalFullText += "\n";
            }

            const pEnd = originalFullText.length;
            const pPr = p.getElementsByTagName("w:pPr")[0] || null;
            const container = p.parentNode;
            if (container) uniqueContainers.add(container);

            paragraphMap.push({
                start: pStart,
                end: pEnd,
                pPr: pPr,
                container: container || body,
            });
        });

        let processedModifiedText = modifiedText || "";

        tokenToCharMap.forEach((char, tokenString) => {
            const escapedToken = tokenString.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
            processedModifiedText = processedModifiedText.replace(new RegExp(escapedToken, "g"), char);
        });

        const dmp = new diff_match_patch();
        const diffs = dmp.diff_main(originalFullText, processedModifiedText);
        dmp.diff_cleanupSemantic(diffs);
        
        // Post-process to ensure whole-word replacements
        const wordCleanedDiffs = cleanupDiffsToWords(diffs);

        const containerFragments = new Map();
        uniqueContainers.forEach((c) => containerFragments.set(c, xmlDoc.createDocumentFragment()));
        if (!containerFragments.has(body)) containerFragments.set(body, xmlDoc.createDocumentFragment());

        const getParagraphInfo = (index) => {
            const match = paragraphMap.find((m) => index >= m.start && index < m.end);
            if (!match && paragraphMap.length > 0) {
                const last = paragraphMap[paragraphMap.length - 1];
                return { pPr: last.pPr, container: last.container };
            }
            return match ? { pPr: match.pPr, container: match.container } : { pPr: null, container: body };
        };

        const createNewParagraph = (pPr) => {
            const newP = xmlDoc.createElement("w:p");
            if (pPr) newP.appendChild(pPr.cloneNode(true));
            return newP;
        };

        let startInfo = getParagraphInfo(0);
        let currentParagraph = createNewParagraph(startInfo.pPr);
        let currentContainer = startInfo.container;
        let currentFragment = containerFragments.get(currentContainer);
        if (currentFragment) currentFragment.appendChild(currentParagraph);

        let currentOriginalIndex = 0;
        const usedReferenceTokens = new Set();

        const getRunProperties = (index) => {
            const match = propertyMap.find((m) => index >= m.start && index < m.end);
            return match ? { rPr: match.rPr, wrapper: match.wrapper } : { rPr: null };
        };

        const appendTextToCurrent = (text, type, rPr, wrapper, baseIndex) => {
            const parts = text.split(/([\n\uFFFC]|[\uE000-\uF8FF])/);
            let localOffset = 0;

            parts.forEach((part) => {
                if (part === "\n") {
                    if (type !== "delete") {
                        let pPr = null;
                        let targetContainer = currentContainer;

                        if (type === "equal") {
                            const lookupIndex = baseIndex + localOffset + 1;
                            const info = getParagraphInfo(lookupIndex);
                            pPr = info.pPr;
                            targetContainer = info.container;
                        } else {
                            const info = getParagraphInfo(baseIndex);
                            pPr = info.pPr;
                            targetContainer = info.container;
                        }

                        currentParagraph = createNewParagraph(pPr);
                        if (targetContainer !== currentContainer) {
                            currentContainer = targetContainer;
                            currentFragment = containerFragments.get(currentContainer);
                        }
                        if (currentFragment) currentFragment.appendChild(currentParagraph);
                    }
                    localOffset += 1;
                } else if (part === "\uFFFC") {
                    const sentinelIndex = baseIndex + localOffset;
                    const sentinel = sentinelMap.find((s) => s.start === sentinelIndex);

                    if (sentinel) {
                        const clone = sentinel.node.cloneNode(true);
                        if (sentinel.isTextBox && sentinel.originalContainer) {
                            const newContainer = clone.getElementsByTagName("w:txbxContent")[0];
                            if (newContainer) {
                                while (newContainer.firstChild) newContainer.removeChild(newContainer.firstChild);
                                replacementContainers.set(sentinel.originalContainer, newContainer);
                            }
                        }
                        if (sentinel.node.nodeName === "w:r" || sentinel.node.parentNode?.nodeName === "w:r") {
                            const run = xmlDoc.createElement("w:r");
                            if (rPr) run.appendChild(rPr.cloneNode(true));
                            run.appendChild(clone);
                            currentParagraph.appendChild(run);
                        } else {
                            currentParagraph.appendChild(clone);
                        }
                    }
                    localOffset += 1;
                } else if (referenceMap.has(part)) {
                    if (type !== "delete") {
                        const refNode = referenceMap.get(part);
                        if (refNode) {
                            const clone = refNode.cloneNode(true);
                            const run = xmlDoc.createElement("w:r");
                            if (rPr) run.appendChild(rPr.cloneNode(true));
                            run.appendChild(clone);
                            currentParagraph.appendChild(run);
                            let tokenString = "";
                            tokenToCharMap.forEach((c, t) => {
                                if (c === part) tokenString = t;
                            });
                            usedReferenceTokens.add(tokenString);
                        }
                    }
                    localOffset += part.length;
                } else if (part.length > 0) {
                    const run = xmlDoc.createElement("w:r");
                    if (rPr) run.appendChild(rPr.cloneNode(true));

                    let parent = currentParagraph;
                    if (wrapper) {
                        const wrapperClone = wrapper.cloneNode(false);
                        parent = wrapperClone;
                        currentParagraph.appendChild(wrapperClone);
                    }

                    const t = type === "delete" ? xmlDoc.createElement("w:delText") : xmlDoc.createElement("w:t");
                    t.setAttribute("xml:space", "preserve");
                    t.textContent = part;

                    run.appendChild(t);

                    if (type === "delete") {
                        const del = xmlDoc.createElement("w:del");
                        del.setAttribute("w:id", Math.floor(Math.random() * 10000).toString());
                        del.setAttribute("w:author", getTrackChangeAuthor());
                        del.setAttribute("w:date", new Date().toISOString());
                        del.appendChild(run);
                        parent.appendChild(del);
                    } else if (type === "insert") {
                        const ins = xmlDoc.createElement("w:ins");
                        ins.setAttribute("w:id", Math.floor(Math.random() * 10000).toString());
                        ins.setAttribute("w:author", getTrackChangeAuthor());
                        ins.setAttribute("w:date", new Date().toISOString());
                        ins.appendChild(run);
                        parent.appendChild(ins);
                    } else {
                        parent.appendChild(run);
                    }
                    localOffset += part.length;
                }
            });
        };

        for (const diff of wordCleanedDiffs) {
            const [op, text] = diff;
            if (op === 0) {
                let offset = 0;
                while (offset < text.length) {
                    const props = getRunProperties(currentOriginalIndex + offset);
                    const currentPropRange = propertyMap.find(
                        (m) => currentOriginalIndex + offset >= m.start && currentOriginalIndex + offset < m.end,
                    );
                    let length = currentPropRange
                        ? Math.min(currentPropRange.end - (currentOriginalIndex + offset), text.length - offset)
                        : 1;
                    const chunk = text.substring(offset, offset + length);
                    appendTextToCurrent(chunk, "equal", props.rPr || null, props.wrapper, currentOriginalIndex + offset);
                    offset += length;
                }
                currentOriginalIndex += text.length;
            } else if (op === 1) {
                const isStartOfParagraph = paragraphMap.some((p) => p.start === currentOriginalIndex);
                const props =
                    currentOriginalIndex > 0 && !isStartOfParagraph
                        ? getRunProperties(currentOriginalIndex - 1)
                        : getRunProperties(currentOriginalIndex);
                appendTextToCurrent(text, "insert", props.rPr || null, props.wrapper, currentOriginalIndex);
            } else if (op === -1) {
                let offset = 0;
                while (offset < text.length) {
                    const props = getRunProperties(currentOriginalIndex + offset);
                    const currentPropRange = propertyMap.find(
                        (m) => currentOriginalIndex + offset >= m.start && currentOriginalIndex + offset < m.end,
                    );
                    let length = currentPropRange
                        ? Math.min(currentPropRange.end - (currentOriginalIndex + offset), text.length - offset)
                        : 1;
                    const chunk = text.substring(offset, offset + length);
                    appendTextToCurrent(chunk, "delete", props.rPr || null, props.wrapper, currentOriginalIndex + offset);
                    offset += length;
                }
                currentOriginalIndex += text.length;
            }
        }

        paragraphs.forEach((p) => {
            if (p.parentNode) p.parentNode.removeChild(p);
        });

        containerFragments.forEach((fragment, container) => {
            const replacement = replacementContainers.get(container);
            const target = replacement || container;
            target.appendChild(fragment);
        });

        return { oxml: serializer.serializeToString(xmlDoc), hasChanges: true };
    }

    function sanitizeAiResponse(text) {
        let cleaned = text;
        cleaned = cleaned.replace(/^(Here is the redline:|Here is the text:|Sure, I can help:|Here's the updated text:)\s*/i, "");
        cleaned = cleaned.replace(/\$\\text\{/g, "").replace(/\}\$/g, "");
        cleaned = cleaned.replace(/\$([^0-9\n]+?)\$/g, "$1");
        return cleaned;
    }

    // ==========================================
    // SELECTION TRACK CHANGES HANDLER
    // ==========================================

    async function getAcceptedSelectionText(context: Word.RequestContext): Promise<{ text: string; oxml: string }> {
        const selection = context.document.getSelection();
        const oxmlResult = selection.getOoxml();
        await context.sync();
        
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(oxmlResult.value, "text/xml");
        
        const deletions = xmlDoc.getElementsByTagName("w:del");
        while (deletions.length > 0) {
            deletions[0].parentNode?.removeChild(deletions[0]);
        }
        
        const delTexts = xmlDoc.getElementsByTagName("w:delText");
        while (delTexts.length > 0) {
            delTexts[0].parentNode?.removeChild(delTexts[0]);
        }
        
        const insertions = xmlDoc.getElementsByTagName("w:ins");
        while (insertions.length > 0) {
            const ins = insertions[0];
            const parent = ins.parentNode;
            while (ins.firstChild) {
                parent?.insertBefore(ins.firstChild, ins);
            }
            parent?.removeChild(ins);
        }
        
        const paragraphs = xmlDoc.getElementsByTagName("w:p");
        let acceptedText = "";
        
        for (let p = 0; p < paragraphs.length; p++) {
            const textElements = paragraphs[p].getElementsByTagName("w:t");
            let paragraphText = "";
            for (let t = 0; t < textElements.length; t++) {
                paragraphText += textElements[t].textContent || "";
            }
            if (paragraphText.length > 0) {
                acceptedText += paragraphText + "\n";
            }
        }
        
        return {
            text: acceptedText.trim(),
            oxml: oxmlResult.value
        };
    }

    // ==========================================
    // CONTEXT CACHING SYSTEM - Functions
    // ==========================================

    async function createGeminiCache(apiKey: string, model: string, fullDocumentText: string): Promise<string> {
        const cleanModel = (model || "gemini-2.0-flash-exp").replace(/^models\//, "");
        
        // DIAGNOSTIC: Log what's being cached
        log(" CACHE DIAGNOSTIC: Creating cache with " + fullDocumentText.length + " chars");
        log(" CACHE DIAGNOSTIC: First 200 chars: " + fullDocumentText.substring(0, 200));
        log(" CACHE DIAGNOSTIC: Last 200 chars: " + fullDocumentText.substring(fullDocumentText.length - 200));
        
        const url = `https://generativelanguage.googleapis.com/v1beta/cachedContents?key=${apiKey}`;
        
        const response = await fetch(url, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                model: `models/${cleanModel}`,
                displayName: `vibe-legal-${Date.now()}`,
                contents: [{
                    parts: [{ text: fullDocumentText }],
                    role: "user"
                }],
                systemInstruction: {
                    parts: [{ 
                        text: "You are Vibe Legal, an AI legal contract analyst. The document above is a legal contract loaded for your reference. Understand this document deeply: Identify the parties and their roles. Note all defined terms and their meanings. Understand liability caps, indemnities, and risk allocation. Recognize the document structure and clause organization. Note governing law and dispute resolution provisions. You will receive instructions with a CURRENT STRUCTURE MAP showing paragraph IDs. Always use those IDs for any location references - they reflect the live document state."
                    }]
                },
                ttl: `${CACHE_CONFIG.cacheTTL / 1000}s`
            })
        });
        
        if (!response.ok) {
            const error = await response.json();
            const errorMsg = error.error?.message || "Failed to create cache";
            console.error("[Vibe] Cache creation failed:", response.status, errorMsg);
            const lowerMsg = errorMsg.toLowerCase();
            if ((lowerMsg.includes("model") && lowerMsg.includes("not support")) ||
                lowerMsg.includes("does not support caching") ||
                lowerMsg.includes("cachedcontent is not supported")) {
                throw new Error("ModelDoesNotSupportCaching");
            }
            throw new Error(errorMsg);
        }
        
        const data = await response.json();
        log(" CACHE DIAGNOSTIC: Cache created successfully:", data.name);
        return data.name;
    }

    async function deleteGeminiCache(apiKey: string, cacheId: string): Promise<void> {
        if (!cacheId) return;
        
        try {
            const url = `https://generativelanguage.googleapis.com/v1beta/${cacheId}?key=${apiKey}`;
            await fetch(url, { method: "DELETE" });
        } catch (e) {
            logWarn(" Failed to delete cache:", e);
        }
    }

    function isCacheExpired(): boolean {
        if (!cacheState.createdAt) return true;
        return Date.now() - cacheState.createdAt.getTime() > CACHE_CONFIG.cacheTTL;
    }

    async function ensureCache(apiKey: string, model: string, fullDocumentText: string): Promise<{ cacheId: string | null; error?: string }> {
        // Claude doesn't support caching - always return null
        if (providerConfig.provider === "claude") {
            return { cacheId: null };
        }
        
        if (cacheState.cacheId && !isCacheExpired()) {
            return { cacheId: cacheState.cacheId };
        }
        
        if (fullDocumentText.length < CACHE_CONFIG.minCacheChars) {
            cacheState = { cacheId: null, createdAt: null, changelog: [] };
            return { cacheId: null };
        }
        
        try {
            const cacheId = await createGeminiCache(apiKey, model, fullDocumentText);
            cacheState = {
                cacheId,
                createdAt: new Date(),
                changelog: []
            };
            return { cacheId };
        } catch (e) {
            const errorMsg = (e as Error).message;
            
            if (errorMsg === "ModelDoesNotSupportCaching") {
                logWarn(" Model does not support caching, using direct mode");
                cacheState = { cacheId: null, createdAt: null, changelog: [] };
                return { cacheId: null, error: "This model doesn't support caching. Using Direct Mode." };
            }
            
            if (errorMsg.toLowerCase().includes("too small")) {
                logWarn(" Document too small for caching, using direct mode");
                cacheState = { cacheId: null, createdAt: null, changelog: [] };
                return { cacheId: null };
            }
            
            logWarn(" Context caching unavailable:", errorMsg);
            cacheState = { cacheId: null, createdAt: null, changelog: [] };
            return { cacheId: null, error: `Cache failed: ${errorMsg}. Using Direct Mode.` };
        }
    }

    function logChange(type: "INSERT" | "MODIFY", description: string, content?: string): void {
        const entry: ChangeEntry = {
            type,
            description,
            content: content ? content.substring(0, 2000) : undefined,
            timestamp: new Date()
        };
        
        cacheState.changelog.push(entry);
    }

    function shouldRefreshCache(): boolean {
        if (cacheState.changelog.length >= CACHE_CONFIG.maxChangelogEntries) {
            return true;
        }
        
        const totalChars = cacheState.changelog.reduce(
            (sum, e) => sum + (e.content?.length || 0) + e.description.length, 
            0
        );
        
        return totalChars >= CACHE_CONFIG.maxChangelogChars;
    }

    async function refreshCache(apiKey: string, model: string, fullDocumentText: string): Promise<{ success: boolean; error?: string }> {
        // Claude doesn't support caching
        if (providerConfig.provider === "claude") {
            cacheState = { cacheId: null, createdAt: null, changelog: [] };
            return { success: true };
        }
        
        
        if (cacheState.cacheId) {
            await deleteGeminiCache(apiKey, cacheState.cacheId);
        }
        
        if (fullDocumentText.length < CACHE_CONFIG.minCacheChars) {
            cacheState = { cacheId: null, createdAt: null, changelog: [] };
            return { success: true };
        }
        
        try {
            const cacheId = await createGeminiCache(apiKey, model, fullDocumentText);
            cacheState = {
                cacheId,
                createdAt: new Date(),
                changelog: []
            };
            return { success: true };
        } catch (e) {
            const errorMsg = (e as Error).message;
            
            if (errorMsg === "ModelDoesNotSupportCaching") {
                logWarn(" Model does not support caching");
                cacheState = { cacheId: null, createdAt: null, changelog: [] };
                return { success: false, error: "This model doesn't support caching. Using Direct Mode." };
            }
            
            if (errorMsg.toLowerCase().includes("too small")) {
                logWarn(" Document too small for caching, using direct mode");
                cacheState = { cacheId: null, createdAt: null, changelog: [] };
                return { success: true };
            }
            
            logWarn(" Cache refresh failed:", errorMsg);
            cacheState = { cacheId: null, createdAt: null, changelog: [] };
            return { success: false, error: `Cache failed: ${errorMsg}. Using Direct Mode.` };
        }
    }

    function buildChangelogSection(): string {
        if (cacheState.changelog.length === 0) {
            return "";
        }
        
        const entries = cacheState.changelog.map((c, i) => {
            const contentPreview = c.content ? ` Content: "${c.content.substring(0, 100)}..."` : "";
            return `[${i + 1}] ${c.type}: ${c.description}${contentPreview}`;
        }).join("\n");
        
        return "\nCHANGES SINCE CONTEXT WAS LOADED:\n" + entries + "\n\nIMPORTANT: The above changes are MORE RECENT than your cached knowledge. When these topics are relevant, trust this changelog over your cached memory.";
    }

    function getCacheStatus(): "loaded" | "loading" | "direct" {
        if (providerConfig.provider === "claude") return "direct";
        if (cacheState.cacheId && !isCacheExpired()) return "loaded";
        if (cacheState.cacheId === null && cacheState.createdAt === null) return "direct";
        return "loading";
    }

    // ==========================================
    // QUESTION DETECTION SYSTEM
    // ==========================================

    function isQuestionIntent(prompt: string): boolean {
        const p = prompt.trim();
        
        // FIRST: Check if it's clearly an ACTION request (takes priority over question patterns)
        // This prevents "Can you change..." from being classified as a question
        const actionPatterns = [
            // "Can you [action verb]..." patterns
            /^can you (change|modify|update|edit|fix|correct|amend|revise)/i,
            /^can you (add|insert|include|create|draft|write)/i,
            /^can you (delete|remove|strike|redline)/i,
            /^can you (make|convert|turn|transform)/i,
            /^can you (strengthen|weaken|soften|clarify)/i,
            
            // "Please [action]..." patterns
            /^(please\s+)?(change|modify|update|edit|fix|correct|amend|revise)\s/i,
            /^(please\s+)?(add|insert|include|create|draft|write)\s/i,
            /^(please\s+)?(delete|remove|strike)\s/i,
            /^(please\s+)?(make|convert|turn|transform)\s/i,
            
            // Direct action commands
            /^(change|modify|update|add|insert|delete|remove|make|set|put)\s/i,
            
            // Specific value changes (strong indicator of action)
            /\b(change|set|update|modify)\b.*\b(to|at)\s+(ny|new york|california|texas|delaware)/i,
            /\b(change|set|update|modify)\b.*\b(to|at)\s+\$[\d,]+/i,
            /\b(change|set|update|modify)\b.*\b(to|at)\s+\d+\s*(days?|years?|months?|weeks?)/i,
            
            // "Make this..." patterns (actions, not questions)
            /^make (this|it|the)/i,
        ];
        
        // If any action pattern matches, it's NOT a question
        if (actionPatterns.some(pattern => pattern.test(p))) {
            return false;
        }
        
        // THEN: Check question patterns (only if not an action)
        const questionPatterns = [
            // Interrogative words
            /^(what|who|where|when|why|how|which)\s/i,
            
            // Ends with question mark
            /\?$/,
            
            // Explanation requests
            /^(tell me|explain|describe|summarize|analyze|review|assess|evaluate|compare)/i,
            /^can you (explain|tell|describe|summarize|analyze|review|check|assess)/i,
            
            // "Is/Are/Does..." questions (but NOT "is this mutual" style requests)
            /^(is this|is it|are there|does this|does it)\s.*(balanced|fair|reasonable|risky|compliant|enforceable|valid)/i,
            
            // Assessment language
            /(balanced|fair|reasonable|standard|typical|unusual|risky|favorable|unfavorable)\?/i,
            /(compliant|enforceable|valid|binding)\?/i,
            
            // List/Find requests
            /^(find|show|list|identify|highlight|point out)\s.*(issues?|problems?|clauses?|terms?)/i,
            
            // "What are/is the..." patterns
            /(what are the|what is the|who is|who are)/i,
        ];
        
        return questionPatterns.some(pattern => pattern.test(p));
    }

    // ==========================================
    // INSERT INTENT DETECTION
    // ==========================================

    /**
     * Detects if the user wants to INSERT something, even if text is selected.
     * This takes priority over modification intent.
     */
    function isInsertIntent(prompt: string): boolean {
        const p = prompt.toLowerCase();
        
        // Strong insert signals - these should ALWAYS trigger insert mode
        const insertPatterns = [
            /\b(add|insert|include|create|draft|write)\s+(a\s+)?(new\s+)?(clause|section|paragraph|provision|article)/i,
            /\b(add|insert)\s+(clause|section)\s*\d/i,  // "add clause 4.1.3"
            /\bcan you add\b/i,
            /\bplease add\b/i,
            /\badd\s+.*(obliging|requiring|stating|providing)/i,  // "add X obliging the supplier..."
            /\binsert\s+(after|before|following)/i,
            /\badd\s+(after|before|following)/i,
        ];
        
        return insertPatterns.some(pattern => pattern.test(p));
    }

    /**
     * Extracts a clause reference from user prompt (e.g., "4.1.3" from "add clause 4.1.3")
     */
    function extractClauseReferenceFromPrompt(prompt: string): string | null {
        // Match patterns like "clause 4.1.3", "section 2.3", "4.1.3"
        const patterns = [
            /clause\s+(\d+(?:\.\d+)*)/i,
            /section\s+(\d+(?:\.\d+)*)/i,
            /article\s+(\d+(?:\.\d+)*)/i,
            /after\s+(\d+(?:\.\d+)+)/i,   // "after 4.1.2"
            /\b(\d+\.\d+(?:\.\d+)?)\b/,   // Standalone like "4.1.3"
        ];
        
        for (const pattern of patterns) {
            const match = prompt.match(pattern);
            if (match) {
                return match[1];
            }
        }
        return null;
    }

    // ==========================================
    // TOPIC-BASED INSERTION DETECTION
    // ==========================================

    interface TopicMatch {
        topic: string;
        category: string;
        keywords: string[];
    }

    /**
     * Extracts the likely topic/category from a user's insertion request.
     */
    function extractTopicFromPrompt(prompt: string): TopicMatch | null {
        const p = prompt.toLowerCase();
        
        const topicPatterns = [
            {
                category: "confidentiality",
                topic: "confidentiality",
                patterns: [/\b(confidential|nda|non-disclosure|secrecy)\b/i],
                keywords: ["confidential", "nda", "non-disclosure", "secrecy"]
            },
            {
                category: "term_termination",
                topic: "termination",
                patterns: [/\b(terminat|expir|end the agreement|cancel)\b/i],
                keywords: ["termination", "terminate", "expiry", "cancel"]
            },
            {
                category: "indemnification",
                topic: "indemnification",
                patterns: [/\b(indemn|hold harmless)\b/i],
                keywords: ["indemnity", "indemnification", "indemnify"]
            },
            {
                category: "limitation_of_liability",
                topic: "liability",
                patterns: [/\b(liabil|damage cap|limit.*liab)\b/i],
                keywords: ["liability", "damages", "cap", "limitation"]
            },
            {
                category: "intellectual_property",
                topic: "intellectual property",
                patterns: [/\b(intellect|ip rights|patent|copyright|trademark|licence|license)\b/i],
                keywords: ["intellectual property", "IP", "patent", "copyright"]
            },
            {
                category: "governing_law",
                topic: "governing law",
                patterns: [/\b(govern.*law|jurisdic|choice of law)\b/i],
                keywords: ["governing law", "jurisdiction", "venue"]
            },
            {
                category: "dispute_resolution",
                topic: "dispute resolution",
                patterns: [/\b(dispute|arbitrat|mediat)\b/i],
                keywords: ["dispute", "arbitration", "mediation"]
            },
            {
                category: "notices",
                topic: "notices",
                patterns: [/\b(notice|notif)\b/i],
                keywords: ["notice", "notification"]
            },
            {
                category: "assignment",
                topic: "assignment",
                patterns: [/\b(assign|transfer|novate)\b/i],
                keywords: ["assignment", "transfer"]
            },
            {
                category: "representations_warranties",
                topic: "warranties",
                patterns: [/\b(represent|warrant|guarant)\b/i],
                keywords: ["representation", "warranty", "guarantee"]
            },
            {
                category: "insurance",
                topic: "insurance",
                patterns: [/\b(insurance|insur|coverage|policy|public liability|professional indemnity)\b/i],
                keywords: ["insurance", "coverage", "policy", "public liability"]
            },
            {
                category: "payment",
                topic: "payment",
                patterns: [/\b(payment|price|fee|invoice|billing)\b/i],
                keywords: ["payment", "price", "fee", "invoice"]
            },
            {
                category: "force_majeure",
                topic: "force majeure",
                patterns: [/\b(force majeure|act of god|beyond.*control)\b/i],
                keywords: ["force majeure", "act of god"]
            },
            {
                category: "non_compete",
                topic: "non-compete",
                patterns: [/\b(non-comp|noncomp|compete|competition)\b/i],
                keywords: ["non-compete", "competition"]
            },
            {
                category: "non_solicitation",
                topic: "non-solicitation",
                patterns: [/\b(non-solic|nonsolic|solicit|poach)\b/i],
                keywords: ["non-solicitation", "solicitation"]
            },
            {
                category: "definitions",
                topic: "definitions",
                patterns: [/\b(defin.*term|meaning of)\b/i],
                keywords: ["definition", "defined term"]
            },
        ];
        
        for (const topicDef of topicPatterns) {
            for (const pattern of topicDef.patterns) {
                if (pattern.test(p)) {
                    log(" Detected topic: " + topicDef.topic);
                    return {
                        topic: topicDef.topic,
                        category: topicDef.category,
                        keywords: topicDef.keywords
                    };
                }
            }
        }
        
        return null;
    }

    /**
     * Searches the FULL document for clauses matching a topic.
     * Returns the best insertion point (end of the matching clause section).
     */
    async function findClauseByTopic(
        context: Word.RequestContext,
        paragraphs: Word.ParagraphCollection,
        topic: TopicMatch
    ): Promise<{ paragraphId: number; clauseTitle: string } | null> {
        
        paragraphs.load("text, isListItem");
        await context.sync();
        
        // Load listString for list items
        for (let i = 0; i < paragraphs.items.length; i++) {
            if (paragraphs.items[i].isListItem) {
                paragraphs.items[i].listItem.load("listString");
            }
        }
        await context.sync();
        
        // Build keyword regex
        const keywordPattern = new RegExp("\\b(" + topic.keywords.join("|") + ")\\b", "i");
        const topicTitlePattern = new RegExp("^\\s*(\\d+\\.?\\s+)?" + topic.topic, "i");
        
        interface Match {
            paragraphId: number;
            clauseNumber: string | null;
            title: string;
            confidence: number;
        }
        
        const matches: Match[] = [];
        
        for (let i = 0; i < paragraphs.items.length; i++) {
            const p = paragraphs.items[i];
            const text = (p.text || "").trim();
            
            // Check if this looks like a clause heading
            const isHeading = /^(\d+\.?\s+|\(\d+\)\s*|Section\s+\d+|Article\s+[IVX]+)/i.test(text) ||
                              (text === text.toUpperCase() && text.length < 60 && text.length > 3);
            
            if (!isHeading) continue;
            
            // Extract clause number
            let clauseNumber: string | null = null;
            if (p.isListItem) {
                try {
                    clauseNumber = (p.listItem.listString || "").replace(/[\.\s]+$/, '').trim() || null;
                } catch (e) {}
            }
            if (!clauseNumber) {
                const match = text.match(/^(\d+(?:\.\d+)*)/);
                clauseNumber = match ? match[1] : null;
            }
            
            // Check for topic match
            if (topicTitlePattern.test(text)) {
                log(" Found exact title match at P" + (i + 1) + ": " + text.substring(0, 50));
                matches.push({
                    paragraphId: i + 1,
                    clauseNumber: clauseNumber,
                    title: text.substring(0, 100),
                    confidence: 100
                });
            } else if (keywordPattern.test(text)) {
                log(" Found keyword in heading at P" + (i + 1) + ": " + text.substring(0, 50));
                matches.push({
                    paragraphId: i + 1,
                    clauseNumber: clauseNumber,
                    title: text.substring(0, 100),
                    confidence: 50
                });
            }
        }
        
        if (matches.length === 0) {
            log(" No clause found for topic: " + topic.topic);
            return null;
        }
        
        // Sort by confidence, take best
        const bestMatch = matches.sort((a, b) => b.confidence - a.confidence)[0];
        log(" Best match for '" + topic.topic + "': P" + bestMatch.paragraphId);
        
        // Find end of this clause section
        const endOfSection = findEndOfClauseSection(paragraphs, bestMatch.paragraphId - 1, bestMatch.clauseNumber);
        
        return {
            paragraphId: endOfSection,
            clauseTitle: bestMatch.title
        };
    }

    /**
     * Finds the last paragraph of a clause section.
     * SNAP TO BOTTOM: Returns the last NON-EMPTY, LIST-ITEM paragraph
     * instead of the paragraph just before the next heading.
     * This preserves Word's automatic list continuity.
     */
    function findEndOfClauseSection(
        paragraphs: Word.ParagraphCollection,
        startIndex: number,
        clauseNumber: string | null
    ): number {
        if (!clauseNumber) {
            return startIndex + 1;
        }
        
        const clauseLevel = clauseNumber.split('.').length;
        
        // Track the LAST ACTIVE ITEM (non-empty, preferably a list item)
        let lastActiveIndex = startIndex;
        
        for (let i = startIndex + 1; i < paragraphs.items.length; i++) {
            const p = paragraphs.items[i];
            const text = (p.text || "").trim();
            
            // Check if this is a new clause at same or higher level
            let detectedNumber: string | null = null;
            
            if (p.isListItem) {
                try {
                    detectedNumber = (p.listItem.listString || "").replace(/[\.\\s]+$/, '').trim() || null;
                } catch (e) {}
            }
            
            if (!detectedNumber) {
                const match = text.match(/^(\d+(?:\.\d+)*)/);
                detectedNumber = match ? match[1] : null;
            }
            
            if (detectedNumber) {
                const detectedLevel = detectedNumber.split('.').length;
                
                // If we hit a clause at same level or higher, section has ended
                // SNAP TO BOTTOM: Return the LAST ACTIVE item, not this one
                if (detectedLevel <= clauseLevel) {
                    log(" Section " + clauseNumber + " ends at P" + lastActiveIndex + " (snapped from P" + i + ")");
                    return lastActiveIndex;  // Return 1-indexed
                }
            }
            
            // SNAP TO BOTTOM: Track this as the last active item if:
            // 1. It's a list item, OR
            // 2. It's non-empty text (body paragraph)
            if (p.isListItem || text.length > 0) {
                lastActiveIndex = i;
            }
            // Empty paragraphs are skipped - we don't update lastActiveIndex
        }
        
        // End of document - return the last active item we tracked
        log(" Section " + clauseNumber + " extends to end, last active: P" + lastActiveIndex);
        return lastActiveIndex;
    }

    /**
     * Given a clause reference like "4.1.3", find the paragraph ID where we should insert.
     * Searches the FULL document to find the right location.
     */
    async function findInsertionPointForClause(
        context: Word.RequestContext,
        paragraphs: Word.ParagraphCollection,
        targetClauseRef: string
    ): Promise<{ paragraphId: number; foundRef: string; listLevel?: number } | null> {
        // Load isListItem for all paragraphs
        paragraphs.load("text, isListItem");
        await context.sync();
        
        // Load listItem properties (level, listString) for list paragraphs
        for (let i = 0; i < paragraphs.items.length; i++) {
            const p = paragraphs.items[i];
            if (p.isListItem) {
                p.listItem.load("level, listString");
            }
        }
        await context.sync();
        
        // Parse the target reference to understand hierarchy
        // "4.1.3" -> we want to insert after "4.1.2" or at end of "4.1" section
        const parts = targetClauseRef.split('.');
        const lastPart = parseInt(parts[parts.length - 1]);
        
        // Build sibling reference (e.g., "4.1.3" -> "4.1.2")
        const siblingRef = lastPart > 1 
            ? [...parts.slice(0, -1), String(lastPart - 1)].join('.')
            : null;
        
        // Parent reference (e.g., "4.1.3" -> "4.1")
        const parentRef = parts.length > 1 ? parts.slice(0, -1).join('.') : null;
        
        // Normalize for comparison (remove trailing period/space)
        const normalizeRef = (ref: string) => ref.replace(/[\.\s]+$/, '').trim();
        
        log(" Looking for insertion point for " + targetClauseRef);
        log(" Sibling: " + siblingRef + ", Parent: " + parentRef);
        
        let bestMatch: { id: number; foundRef: string; matchType: string; listLevel?: number } | null = null;
        
        for (let i = 0; i < paragraphs.items.length; i++) {
            const p = paragraphs.items[i];
            const text = (p.text || "").trim();
            
            // METHOD 1: Check listItem.listString for automatic numbering
            let detectedNumber: string | null = null;
            let detectedLevel: number | undefined = undefined;
            
            if (p.isListItem) {
                try {
                    const listString = p.listItem.listString;
                    if (listString) {
                        // listString might be "11.4.1.5" or "11.4.1.5." or "(a)" etc.
                        detectedNumber = normalizeRef(listString);
                        detectedLevel = p.listItem.level;
                    }
                } catch (e) {
                    // listString not available (older API or not a numbered list)
                }
            }
            
            // METHOD 2: Fallback to text regex for manual numbering
            if (!detectedNumber) {
                const manualMatch = text.match(/^(\d+(?:\.\d+)*)[\.\s\)]/);
                if (manualMatch) {
                    detectedNumber = normalizeRef(manualMatch[1]);
                }
            }
            
            // Compare detected number against sibling and parent
            if (detectedNumber) {
                const normalizedSibling = siblingRef ? normalizeRef(siblingRef) : null;
                const normalizedParent = parentRef ? normalizeRef(parentRef) : null;
                
                if (normalizedSibling && detectedNumber === normalizedSibling) {
                    log(" Found sibling " + siblingRef + " at paragraph " + (i + 1) + (p.isListItem ? " (auto-list)" : " (manual)"));
                    bestMatch = { 
                        id: i + 1, 
                        foundRef: siblingRef, 
                        matchType: 'sibling',
                        listLevel: detectedLevel
                    };
                    // Continue searching to find the LAST paragraph of this clause
                } else if (normalizedParent && detectedNumber === normalizedParent && !bestMatch) {
                    log(" Found parent " + parentRef + " at paragraph " + (i + 1));
                    bestMatch = { 
                        id: i + 1, 
                        foundRef: parentRef, 
                        matchType: 'parent',
                        listLevel: detectedLevel
                    };
                }
                
                // Track subsequent paragraphs that are part of the sibling section
                if (bestMatch && bestMatch.matchType === 'sibling') {
                    // Check if this paragraph is a DIFFERENT numbered item
                    if (detectedNumber !== normalizeRef(siblingRef!)) {
                        const detectedParts = detectedNumber.split('.');
                        const siblingParts = siblingRef!.split('.');
                        
                        // If we hit a clause at same or higher level, stop
                        // (e.g., found 11.4.1.6 or 11.4.2 or 11.5 while looking after 11.4.1.5)
                        if (detectedParts.length <= siblingParts.length) {
                            log(" End of sibling section before paragraph " + (i + 1));
                            break;
                        }
                    }
                    
                    // SNAP TO BOTTOM: Only update if this is an ACTIVE paragraph
                    // Skip empty paragraphs to maintain list continuity
                    if (p.isListItem || text.length > 0) {
                        bestMatch = { 
                            id: i + 1, 
                            foundRef: bestMatch.foundRef, 
                            matchType: 'sibling_content',
                            listLevel: bestMatch.listLevel
                        };
                    }
                }
            } else {
                // No detected number - but still track if this is part of sibling content
                // SNAP TO BOTTOM: Only update if paragraph is non-empty (continuation paragraph)
                if (bestMatch && bestMatch.matchType === 'sibling' && text.length > 0 && !p.isListItem) {
                    // This is a body paragraph within the sibling section, track it
                    bestMatch = { 
                        id: i + 1, 
                        foundRef: bestMatch.foundRef, 
                        matchType: 'sibling_content',
                        listLevel: bestMatch.listLevel
                    };
                }
            }
        }
        
        if (bestMatch) {
            return { 
                paragraphId: bestMatch.id, 
                foundRef: bestMatch.foundRef,
                listLevel: bestMatch.listLevel
            };
        }
        
        return null;
    }

    // ==========================================
    // AI-FIRST NAVIGATION: Anchor Resolution
    // ==========================================

    interface NavigationAnchor {
        target_number?: string;   // e.g., "17" or "17.1"
        target_title?: string;    // e.g., "Insurance"
        position?: string;        // "end" | "start" | "after_item_N"
    }

    /**
     * Resolves an AI-provided navigation anchor to a live paragraph ID.
     * Uses the ContractMap to find the section, then applies Snap to Bottom.
     * 
     * @returns Paragraph ID to insert after, or null if resolution fails
     */
    function resolveAnchorToLiveID(
        navigation: NavigationAnchor,
        contractMap: ContractMap | null,
        paragraphs: Word.ParagraphCollection
    ): number | null {
        let matchedClause: ContractClause | null = null;
        
        // Try ContractMap first if available
        if (contractMap && contractMap.clauses && contractMap.clauses.length > 0) {
            const clauses = contractMap.clauses;
            
            // PRIORITY 1: Match by section number
            if (navigation.target_number) {
                // Coerce to string to handle numbers or strings from AI
                const targetNum = String(navigation.target_number).replace(/\.$/, '').trim();
                matchedClause = clauses.find(c => {
                    const clauseNum = (c.clauseNumber || "").replace(/\.$/, '').trim();
                    return clauseNum === targetNum || clauseNum.startsWith(targetNum + ".");
                }) || null;
                
                if (matchedClause) {
                    log(" resolveAnchor: Matched by number '" + targetNum + "' → " + matchedClause.title);
                }
            }
            
            // PRIORITY 2: Match by title (fuzzy)
            if (!matchedClause && navigation.target_title) {
                const targetTitle = navigation.target_title.toLowerCase();
                matchedClause = clauses.find(c => {
                    const clauseTitle = (c.title || "").toLowerCase();
                    return clauseTitle.includes(targetTitle) || targetTitle.includes(clauseTitle);
                }) || null;
                
                if (matchedClause) {
                    log(" resolveAnchor: Matched by title '" + navigation.target_title + "' → Clause " + matchedClause.clauseNumber);
                }
            }
        }
        
        // RESILIENT LOCATOR: Validate result or fall back to live text scan
        let startParagraphId = matchedClause?.paragraphRange?.start || matchedClause?.paragraphId || 0;
        let endParagraphId = matchedClause?.paragraphRange?.end || startParagraphId;
        
        // If ContractMap returned invalid ID (0 or undefined), do a LIVE TEXT SCAN
        if (startParagraphId === 0 || !matchedClause) {
            log(" resolveAnchor: ContractMap failed (P0/undefined), falling back to live text scan");
            
            const targetText = (navigation.target_title || navigation.target_number || "").toLowerCase().trim();
            if (targetText && paragraphs && paragraphs.items) {
                for (let i = 0; i < paragraphs.items.length; i++) {
                    const pText = (paragraphs.items[i].text || "").toLowerCase();
                    // Match if paragraph contains target text or starts with target number
                    if (pText.includes(targetText) || 
                        (navigation.target_number && pText.startsWith(navigation.target_number))) {
                        startParagraphId = i + 1;  // 1-indexed
                        endParagraphId = i + 1;
                        log(" resolveAnchor: Live scan found match at P" + startParagraphId + 
                            " (" + paragraphs.items[i].text.substring(0, 40) + "...)");
                        break;
                    }
                }
            }
            
            if (startParagraphId === 0) {
                log(" resolveAnchor: No match found for", navigation);
                return null;
            }
        }
        
        // Apply Snap to Bottom: Find last ACTIVE paragraph in the section
        let lastActiveId = endParagraphId;
        
        // Scan from section start to end, tracking last non-empty paragraph
        for (let i = startParagraphId; i <= Math.min(endParagraphId, paragraphs.items.length); i++) {
            const idx = i - 1;  // Convert to 0-indexed
            if (idx >= 0 && idx < paragraphs.items.length) {
                const p = paragraphs.items[idx];
                const text = (p.text || "").trim();
                
                // Track if this is an active paragraph (non-empty or list item)
                if (text.length > 0 || p.isListItem) {
                    lastActiveId = i;
                }
            }
        }
        
        log(" resolveAnchor: Resolved to P" + lastActiveId + " (section " + (matchedClause?.clauseNumber || "unknown") + ", snapped from P" + endParagraphId + ")");
        
        return lastActiveId;
    }

    /**
     * HIERARCHY SNAPPING: Get the depth level of a clause reference.
     * "10" = Level 0 (Container), "10.1" = Level 1 (Leaf), "10.1.1" = Level 2 (Deep)
     */
    function getHierarchyLevel(ref: string): number {
        if (!ref) return 0;
        const cleaned = ref.replace(/\.$/, '').trim();
        return (cleaned.match(/\./g) || []).length;
    }

    /**
     * Check if refA is a parent of refB.
     * "10" is parent of "10.1", "10.1.1", etc.
     */
    function isParentOf(parentRef: string, childRef: string): boolean {
        if (!parentRef || !childRef) return false;
        const parent = parentRef.replace(/\.$/, '').trim();
        const child = childRef.replace(/\.$/, '').trim();
        return child.startsWith(parent + ".");
    }

    /**
     * Check if two refs are siblings (same parent).
     * "10.1" and "10.2" are siblings.
     */
    function areSiblings(refA: string, refB: string): boolean {
        const levelA = getHierarchyLevel(refA);
        const levelB = getHierarchyLevel(refB);
        if (levelA !== levelB || levelA === 0) return false;
        
        // Extract parent (everything before last dot)
        const parentA = refA.substring(0, refA.lastIndexOf('.'));
        const parentB = refB.substring(0, refB.lastIndexOf('.'));
        return parentA === parentB;
    }

    /**
     * Range result for MODIFY operations
     */
    interface ParagraphRange {
        startId: number;
        endId: number;
        headingId?: number;  // First paragraph if it's a heading (may exclude from body)
        clauseNumber?: string;
        clauseTitle?: string;
    }

    /**
     * Resolves an AI-provided navigation anchor to a paragraph RANGE.
     * Used for MODIFY operations to identify which paragraphs to redline.
     * 
     * @returns Range of paragraph IDs, or null if resolution fails
     */
    /**
     * Resolves an AI-provided navigation anchor to a paragraph RANGE.
     * Used for MODIFY operations to identify which paragraphs to redline.
     * @param scope - "NODE" for single-paragraph, "TREE" for section hierarchy
     * @returns Range of paragraph IDs, or null if resolution fails
     */
    function resolveAnchorToRange(
        navigation: NavigationAnchor,
        contractMap: ContractMap | null,
        paragraphs: Word.ParagraphCollection,
        scope: "NODE" | "TREE" = "TREE"  // Default to TREE for backward compatibility
    ): ParagraphRange | null {
        // Normalize helper
        const normalizeRef = (ref: string) => ref ? ref.replace(/\.$/, '').trim() : '';

        // PRIORITY 0: Try ContractMap first (Fastest)
        if (contractMap && contractMap.clauses && contractMap.clauses.length > 0) {
            const clauses = contractMap.clauses;
            let matchedClause: ContractClause | null = null;

            // Match by section number
            if (navigation.target_number) {
                const targetNum = normalizeRef(navigation.target_number);
                matchedClause = clauses.find(c => {
                    const clauseNum = normalizeRef(c.number || "");
                    return clauseNum === targetNum || clauseNum.startsWith(targetNum + ".");
                }) || null;

                if (matchedClause) {
                    // Apply delta shifts to convert cached IDs to live IDs
                    const liveStartId = originalIdToLiveId(matchedClause.startParagraphId);
                    const liveEndId = originalIdToLiveId(matchedClause.endParagraphId);
                    const shift = getCumulativeShift(matchedClause.startParagraphId);
                    
                    log(" resolveRange: ContractMap match by number '" + targetNum + "' → " + matchedClause.title);
                    if (shift !== 0) {
                        log(" resolveRange: Applied delta shift " + (shift > 0 ? "+" : "") + shift + 
                            " (Cached P" + matchedClause.startParagraphId + "-P" + matchedClause.endParagraphId + 
                            " → Live P" + liveStartId + "-P" + liveEndId + ")");
                    }
                    
                    // SCOPE ENFORCEMENT: NODE = single paragraph only
                    const finalEndId = scope === "NODE" ? liveStartId : liveEndId;
                    if (scope === "NODE" && liveStartId !== liveEndId) {
                        log(" resolveRange: Scope NODE - locking to single paragraph P" + liveStartId);
                    }
                    
                    return {
                        startId: liveStartId,
                        endId: finalEndId,
                        clauseNumber: matchedClause.number,
                        clauseTitle: matchedClause.title
                    };
                }
            }
            
            // Match by title (fuzzy)
            if (!matchedClause && navigation.target_title) {
                const targetTitle = navigation.target_title.toLowerCase().substring(0, 50);
                matchedClause = clauses.find(c => {
                    const clauseTitle = (c.title || "").toLowerCase();
                    return clauseTitle.includes(targetTitle) || targetTitle.includes(clauseTitle);
                }) || null;
                
                if (matchedClause) {
                    // Apply delta shifts to convert cached IDs to live IDs
                    const liveStartId = originalIdToLiveId(matchedClause.startParagraphId);
                    const liveEndId = originalIdToLiveId(matchedClause.endParagraphId);
                    const shift = getCumulativeShift(matchedClause.startParagraphId);
                    
                    log(" resolveRange: ContractMap match by title '" + navigation.target_title.substring(0, 30) + "...'");
                    if (shift !== 0) {
                        log(" resolveRange: Applied delta shift " + (shift > 0 ? "+" : "") + shift + 
                            " (Cached P" + matchedClause.startParagraphId + "-P" + matchedClause.endParagraphId + 
                            " → Live P" + liveStartId + "-P" + liveEndId + ")");
                    }
                    
                    // SCOPE ENFORCEMENT: NODE = single paragraph only
                    const finalEndId = scope === "NODE" ? liveStartId : liveEndId;
                    if (scope === "NODE" && liveStartId !== liveEndId) {
                        log(" resolveRange: Scope NODE - locking to single paragraph P" + liveStartId);
                    }
                    
                    return {
                        startId: liveStartId,
                        endId: finalEndId,
                        clauseNumber: matchedClause.number,
                        clauseTitle: matchedClause.title
                    };
                }
            }
        }

        // PRIORITY 1: FALLBACK - Search paragraphs directly (Robust)
        // 🔧 FIX: Also check listItem.listString for auto-numbered lists
        if (navigation.target_number && paragraphs && paragraphs.items) {
            const targetNum = normalizeRef(navigation.target_number);
            // Create a regex that matches "65.1" or "65.1." at start of string
            const pattern = new RegExp("^\\s*" + targetNum.replace(/\./g, "\\.") + "[\\.\\s]", "i");

            log(" resolveRange: Fallback - searching paragraphs for '" + targetNum + "'");

            let startId: number | null = null;
            let endId: number | null = null;

            for (let i = 0; i < paragraphs.items.length; i++) {
                const p = paragraphs.items[i];
                const text = (p.text || "").trim();
                
                // CHECK 1: Is the number in the auto-generated list string?
                let listString: string | null = null;
                if (p.isListItem) {
                    try { 
                        listString = normalizeRef(p.listItem?.listString || ""); 
                    } catch(e) { /* ignore */ }
                }

                // CHECK 2: Is the number in the manual text?
                const textHasNumber = pattern.test(text);
                
                // Did we find the start?
                const isMatch = (listString === targetNum) || textHasNumber;

                if (startId === null && isMatch) {
                    startId = i + 1; // 1-indexed
                    endId = i + 1;
                    log(" resolveRange: Found start at P" + startId + " (List: " + listString + ", Text: " + text.substring(0, 40) + ")");
                    continue;
                }

                // After finding start, extend until next clause at same or higher level
                if (startId !== null) {
                    // HIERARCHY SNAPPING: Use Dot Counter for precise scoping
                    const targetLevel = getHierarchyLevel(targetNum);
                    
                    // Extract clause number from this paragraph
                    let paraClauseNum: string | null = listString;
                    if (!paraClauseNum) {
                        const numMatch = text.match(/^(\d+(?:\.\d+)*)\./);
                        paraClauseNum = numMatch ? numMatch[1] : null;
                    }
                    
                    if (paraClauseNum) {
                        const paraLevel = getHierarchyLevel(paraClauseNum);
                        
                        // Stop conditions based on hierarchy:
                        // 1. Same level sibling (10.1 → stop at 10.2)
                        // 2. Higher level clause (10.1 → stop at 11)
                        // 3. Different branch at same parent level
                        const isSibling = areSiblings(targetNum, paraClauseNum);
                        const isHigherLevel = paraLevel < targetLevel && !isParentOf(paraClauseNum, targetNum);
                        const isNextMajor = paraLevel === 0 && paraClauseNum !== targetNum.split('.')[0];
                        
                        if ((isSibling || isHigherLevel || isNextMajor) && paraClauseNum !== targetNum) {
                            log(" resolveRange: Hierarchy stop at P" + (i + 1) + 
                                " (target=" + targetNum + " L" + targetLevel + 
                                ", found=" + paraClauseNum + " L" + paraLevel + ")");
                            break;
                        }
                        
                        // Include children of target (10 → include 10.1, 10.2)
                        if (isParentOf(targetNum, paraClauseNum) || paraClauseNum === targetNum) {
                            endId = i + 1;
                        }
                    }
                    
                    // Extend range for body text (no clause number)
                    if (!paraClauseNum && text.length > 0) {
                        endId = i + 1;
                    }
                }
            }

            if (startId !== null && endId !== null) {
                log(" resolveRange: Fallback success - P" + startId + " to P" + endId);
                return {
                    startId,
                    endId,
                    clauseNumber: targetNum,
                    clauseTitle: navigation.target_title?.substring(0, 50) || "Unknown"
                };
            }
        }

        // PRIORITY 2: TITLE-BASED FALLBACK - For non-numbered sections like "Preamble"
        if (navigation.target_title && paragraphs && paragraphs.items) {
            const targetTitle = navigation.target_title.toLowerCase().trim();
            log(" resolveRange: Title fallback - searching for '" + targetTitle + "'");
            
            let startId: number | null = null;
            let endId: number | null = null;
            
            for (let i = 0; i < paragraphs.items.length; i++) {
                const p = paragraphs.items[i];
                const text = (p.text || "").trim();
                const textLower = text.toLowerCase();
                
                // Check if this paragraph contains the target title
                const isMatch = textLower.includes(targetTitle) || 
                               targetTitle.includes(textLower) ||
                               textLower.replace(/[^a-z]/g, '').includes(targetTitle.replace(/[^a-z]/g, ''));
                
                if (isMatch && startId === null) {
                    startId = i + 1;  // 1-indexed
                    endId = i + 1;
                    log(" resolveRange: Title match at P" + startId + " (" + text.substring(0, 40) + "...)");
                    continue;
                }
                
                // After finding start, extend until we hit another heading
                if (startId !== null) {
                    // Stop if we hit what looks like a new heading (short, capitalized, or bold-ish)
                    const looksLikeHeading = (text.length < 60 && /^[A-Z]/.test(text) && text.length > 0) ||
                                            p.styleId?.toLowerCase().includes("heading");
                    
                    // Stop if paragraph starts with a number pattern like "1." "1.1" etc.
                    const startsWithNumber = /^\s*\d+\./.test(text);
                    
                    if ((looksLikeHeading || startsWithNumber) && i > startId - 1 + 1) {
                        // Found next section, stop here
                        log(" resolveRange: Title section ends at P" + endId + " (next: " + text.substring(0, 30) + "...)");
                        break;
                    }
                    
                    // Extend range
                    if (text.length > 0) {
                        endId = i + 1;
                    }
                }
            }
            
            if (startId !== null && endId !== null) {
                log(" resolveRange: Title fallback success - P" + startId + " to P" + endId);
                return {
                    startId,
                    endId,
                    clauseNumber: "—",  // No number
                    clauseTitle: navigation.target_title?.substring(0, 50) || "Unknown"
                };
            }
        }

        log(" resolveRange: No match found for", navigation);
        return null;
    }

    /**
     * ID-FIRST ARCHITECTURE: Build document text with paragraph IDs.
     * Format: [P1] First paragraph text\n[P2] Second paragraph text\n...
     * 
     * This enables the Router to return explicit target_id values,
     * eliminating ambiguity in clause resolution.
     * 
     * @param paragraphs - The loaded paragraph collection
     * @param maxParagraphs - Maximum paragraphs to include (default 500)
     * @returns ID-prefixed document string
     */
    function buildDocumentWithIds(
        paragraphs: Word.ParagraphCollection,
        maxParagraphs: number = 500
    ): string {
        const lines: string[] = [];
        const count = Math.min(paragraphs.items.length, maxParagraphs);
        
        for (let i = 0; i < count; i++) {
            const p = paragraphs.items[i];
            const text = (p.text || "").trim();
            
            if (text.length > 0) {
                // Format: [P{1-indexed id}] {text}
                lines.push("[P" + (i + 1) + "] " + text);
            }
        }
        
        if (paragraphs.items.length > maxParagraphs) {
            lines.push("");
            lines.push("[TRUNCATED: Document has " + paragraphs.items.length + " paragraphs. First " + maxParagraphs + " shown.]");
        }
        
        log(" Built document with IDs: " + count + " paragraphs");
        return lines.join("\n");
    }

    /**
     * Builds section context with paragraph IDs for AI consumption.
     * Format: [P{id}] {text} [LEVEL: heading|body|sub-N]
     * 
     * This enables the AI to return per-paragraph instructions:
     * { "id": "P1595", "action": "AMEND", "new_text": "..." }
     */
    function buildSectionContextWithIds(
        range: ParagraphRange,
        paragraphs: Word.ParagraphCollection
    ): string {
        const lines: string[] = [];
        
        lines.push("=== SECTION CONTEXT (ID + STRUCTURE) ===");
        lines.push("LEGEND: {AUTO: Lx} = Word Auto-List Level x. {MANUAL} = Typed number. {TEXT} = Plain text.");
        lines.push("");
        
        for (let i = 0; i < paragraphs.items.length; i++) {
            const paraId = i + 1; // 1-indexed
            
            // Only include paragraphs in range
            if (paraId < range.startId || paraId > range.endId) continue;
            
            const p = paragraphs.items[i];
            const text = (p.text || "").trim();
            if (text.length === 0) continue; // Skip empty paragraphs
            
            // Determine Structure Tag based on Word internals
            let tag = "{TEXT}";
            let listString = "";

            if (p.isListItem) {
                try {
                    const level = p.listItem?.level ?? 0; // 0 = 1., 1 = 1.1, etc.
                    listString = p.listItem?.listString || "";
                    tag = "{AUTO: L" + level + "}";
                } catch(e) {
                    tag = "{AUTO: L?}";
                }
            } else if (/^\d+(\.\d+)*\.?\s/.test(text)) {
                // Typed number like "5.2. Payment terms"
                tag = "{MANUAL}";
            }
            
            const truncatedText = text.length > 120 ? text.substring(0, 120) + "..." : text;
            lines.push("[P" + paraId + "] " + tag + " " + truncatedText);
        }
        
        lines.push("");
        lines.push("=== END SECTION ===");
        
        return lines.join("\n");
    }

    // ==========================================
    // HOLISTIC TRANSFORMATION DETECTION
    // ==========================================

    /**
     * Detects if a prompt requires holistic document transformation.
     * Holistic mode sends the entire document for rewriting to ensure
     * consistent terminology and coherent changes across all sections.
     */
    function isHolisticTransformation(prompt: string): boolean {
        const p = prompt.toLowerCase().trim();
        
        // Patterns that indicate holistic transformation needed
        const holisticPatterns = [
            // Mutual/reciprocal conversions
            /\b(make|convert|change|turn).*(mutual|reciprocal|two-way|bilateral)/i,
            /\b(mutual|reciprocal|two-way|bilateral)\b.*\b(nda|agreement|contract)\b/i,
            
            // Party/role transformations
            /\b(flip|swap|switch|reverse).*(parties|roles|sides)/i,
            /\b(change|convert).*(from|to).*(one-way|two-way)/i,
            /\b(disclos(er|ing)|recipient).*(to|into|become)/i,
            
            // Document type conversions
            /\b(convert|change|turn|transform).*(this|document|agreement).*(to|into|as)/i,
            /\b(restructure|rewrite|recast|remake)\b/i,
            
            // Fundamental nature changes
            /\b(make this|turn this into|convert this to)\s+\w+\s+(agreement|contract|nda)/i,
            /\b(change|modify)\s+the\s+(nature|type|structure)\b/i
        ];
        
        // Patterns that indicate surgical/targeted changes (NOT holistic)
        const surgicalPatterns = [
            /^(add|insert|include|create|draft)\s/i,
            /\b(clause|section|paragraph|provision)\s*(about|for|regarding)/i,
            /\b(liability|indemnity|cap|limit)\s*(to|at)\s*\$?\d/i,
            /^(delete|remove|strike)\s/i,
            /\b(section|paragraph|clause)\s*\d/i,
            /\b(change|modify|update)\s+(the|section|paragraph).*\s+(to|from)\s+\$/i
        ];
        
        const isHolistic = holisticPatterns.some(pattern => pattern.test(p));
        const isSurgical = surgicalPatterns.some(pattern => pattern.test(p));
        
        // Only use holistic mode if it matches holistic patterns and doesn't match surgical patterns
        const result = isHolistic && !isSurgical;
        
        if (result) {
        }
        
        return result;
    }

    // ==========================================
    // CONVERSATION CONTEXT SYSTEM
    // ==========================================

    interface ContextAnalysis {
        includeHistory: boolean;
        relevantEntries: ChangeEntry[];
        referenceType: "none" | "explicit" | "implicit";
    }

    function analyzePromptForReferences(prompt: string, changelog: ChangeEntry[]): ContextAnalysis {
        const explicitPatterns = [
            /same (thing|way|approach|treatment|wording|language)/i,
            /like (before|we did|the previous|earlier|last time)/i,
            /similar(ly)? to (what|how)/i,
            /do that (to|for|with)/i,
            /apply (that|this|the same) to/i,
            /repeat (that|this) for/i,
            /as we did (with|for|to)/i,
            /(also|too|as well)$/i
        ];
        
        const implicitPatterns = [
            /^(and|also|now)\s/i,
            /the other/i,
            /remaining/i,
            /rest of/i
        ];
        
        const hasExplicitReference = explicitPatterns.some(p => p.test(prompt));
        const hasImplicitReference = implicitPatterns.some(p => p.test(prompt));
        
        if (hasExplicitReference) {
            return {
                includeHistory: true,
                relevantEntries: changelog.slice(-3),
                referenceType: "explicit"
            };
        }
        
        if (hasImplicitReference && changelog.length > 0) {
            return {
                includeHistory: true,
                relevantEntries: changelog.slice(-1),
                referenceType: "implicit"
            };
        }
        
        return {
            includeHistory: false,
            relevantEntries: [],
            referenceType: "none"
        };
    }

    function buildContextSection(changelog: ChangeEntry[], analysis: ContextAnalysis): string {
        let completedSection = "";
        if (changelog.length > 0) {
            const completedList = changelog.map((c, i) => 
                `[${i + 1}] ${c.type}: ${c.description}`
            ).join("\n");
            
            completedSection = "COMPLETED CHANGES THIS SESSION:\n" + completedList + "\n";
        }
        
        let referenceSection = "";
        if (analysis.includeHistory && analysis.relevantEntries.length > 0) {
            if (analysis.referenceType === "explicit") {
                const details = analysis.relevantEntries.map(e => {
                    const contentPreview = e.content ? " Content: \"" + e.content.substring(0, 150) + "...\"" : "";
                    return "- " + e.type + " " + e.description + contentPreview;
                }).join("\n");
                
                referenceSection = "\nUSER IS REFERENCING PREVIOUS WORK. Relevant changes:\n" + details + "\n\nApply a similar approach to the current request.";
            } else {
                referenceSection = "\nPOSSIBLE REFERENCE to recent change: " + analysis.relevantEntries[0].description + "\nOnly apply if the user's request clearly relates to this.";
            }
        }
        
        const independenceNote = "\nIMPORTANT: Unless the user explicitly says \"same\", \"like before\", or similar:\n- Treat this request as INDEPENDENT\n- Do NOT apply previous $ amounts, caps, or specific wording to new clauses\n- Do NOT assume connections between different sections\n- The changelog shows what's DONE, not patterns to repeat";

        return completedSection + referenceSection + independenceNote;
    }

    // ==========================================
    // V10.0 DOCUMENT SNAPSHOT (AI-Driven Analysis)
    // ==========================================

    interface ParagraphSnapshot {
        id: number;
        clauseRef: string | null;  // Detected clause number like "3", "3.1", "(a)", etc.
        text: string;
        styleId: string;
        token: string;
        fmt: {
            bold: boolean;
            allCaps: boolean;
            alignment: string;
        };
        list: {
            isListItem: boolean;
            level: number;
            listString: string | null;  // The actual displayed number like "11.4.1.5"
        };
    }

    interface DocumentSnapshot {
        paragraphs: ParagraphSnapshot[];
        totalParagraphs: number;
        lastParagraphId: number;
    }

    async function captureDocumentSnapshot(
        context: Word.RequestContext,
        paragraphs: Word.ParagraphCollection,
        styleCache: Map<string, StyleToken>
    ): Promise<DocumentSnapshot> {

        paragraphs.load("text, style, isListItem, alignment");
        await context.sync();

        // Load listItem properties for list paragraphs (including listString for auto-numbering)
        for (let i = 0; i < paragraphs.items.length; i++) {
            const p = paragraphs.items[i];
            if (p.isListItem) {
                p.listItem.load("level, listString");
            }
        }
        await context.sync();

        const totalParagraphs = paragraphs.items.length;
        const snapshotParagraphs: ParagraphSnapshot[] = [];

        const indicesToCapture = new Set<number>();

        // ==========================================
        // ENHANCED: Capture more paragraphs for better coverage
        // ==========================================
        
        // For small documents (< 100 paragraphs), capture everything
        if (totalParagraphs <= 100) {
            for (let i = 0; i < totalParagraphs; i++) {
                indicesToCapture.add(i);
            }
        } else {
            // For large documents:
            // - First 60 paragraphs (covers preamble, definitions, early clauses)
            for (let i = 0; i < Math.min(60, totalParagraphs); i++) {
                indicesToCapture.add(i);
            }
            
            // - Last 20 paragraphs (signatures, boilerplate)
            for (let i = Math.max(0, totalParagraphs - 20); i < totalParagraphs; i++) {
                indicesToCapture.add(i);
            }
            
            // - Sample every 10th paragraph in the middle (for structure)
            for (let i = 60; i < totalParagraphs - 20; i += 10) {
                indicesToCapture.add(i);
            }
            
            // - Capture any paragraph that looks like a clause heading
            for (let i = 0; i < totalParagraphs; i++) {
                const text = (paragraphs.items[i].text || "").substring(0, 30);
                // Numbered clauses like "4.1", "4.1.2", "Section 5"
                if (/^\d+(\.\d+)*[\.\s\)]/.test(text) || /^(Section|Article|Clause)\s+\d/i.test(text)) {
                    indicesToCapture.add(i);
                }
            }
        }

        const styleNameToToken = new Map<string, string>();
        styleCache.forEach((data, token) => {
            styleNameToToken.set(data.styleName, token);
        });

        // Helper: Extract clause reference from text (e.g., "3.1", "3)", "(a)")
        function extractClauseRef(text: string): string | null {
            const patterns = [
                // "3.1.2 " or "3.1 " - hierarchical numbering
                { regex: /^((?:\d+\.)+\d*)\s/, group: 1 },
                // "3. " - simple numbered clause
                { regex: /^(\d+)\.\s/, group: 1 },
                // "(a) " or "(i) " - lettered/roman sub-clauses
                { regex: /^\(([a-z]|[ivx]+)\)\s/i, group: 1 },
                // "a) " or "i) " - lettered without opening paren
                { regex: /^([a-z]|[ivx]+)\)\s/i, group: 1 },
            ];
            
            for (const p of patterns) {
                const match = text.match(p.regex);
                if (match) {
                    return match[p.group].replace(/\.$/, ''); // Remove trailing period
                }
            }
            return null;
        }

        for (const idx of Array.from(indicesToCapture).sort((a, b) => a - b)) {
            const p = paragraphs.items[idx];
            const text = (p.text || "").substring(0, 100).trim();
            const styleName = p.style || "Normal";
            const token = styleNameToToken.get(styleName) || "S1";

            const isAllCaps = text.length > 0 && text === text.toUpperCase() && /[A-Z]/.test(text);
            const hasBoldPattern = /^\*\*/.test(text) || /^\d+\.\s+[A-Z]/.test(text);

            let listLevel = 0;
            let listString: string | null = null;
            
            if (p.isListItem) {
                try {
                    listLevel = p.listItem.level || 0;
                    // Get the auto-generated number from Word's numbering system
                    listString = p.listItem.listString || null;
                    // Normalize: remove trailing period/space (e.g., "11.4.1.5." -> "11.4.1.5")
                    if (listString) {
                        listString = listString.replace(/[\.\s]+$/, '').trim();
                    }
                } catch (e) {
                    listLevel = 0;
                    listString = null;
                }
            }

            // Prefer listString (auto-numbering) over text regex (manual numbering)
            const clauseRef = listString || extractClauseRef(text);

            snapshotParagraphs.push({
                id: idx + 1,
                clauseRef: clauseRef,
                text: text,
                styleId: styleName,
                token: token,
                fmt: {
                    bold: hasBoldPattern,
                    allCaps: isAllCaps,
                    alignment: p.alignment || "Left"
                },
                list: {
                    isListItem: p.isListItem || false,
                    level: listLevel,
                    listString: listString
                }
            });
        }


        return {
            paragraphs: snapshotParagraphs,
            totalParagraphs: totalParagraphs,
            lastParagraphId: totalParagraphs
        };
    }

    // ==========================================
    // NEIGHBORHOOD CONTEXT - For Context-Aware Insertion
    // ==========================================
    
    interface NeighborhoodContext {
        target: ParagraphSnapshot;
        before: ParagraphSnapshot[];  // Up to 3 paragraphs before
        after: ParagraphSnapshot[];    // Up to 3 paragraphs after
        listContext: {
            isInList: boolean;
            parentIlvl: number;       // ilvl of the target paragraph
            recommendedIlvl: number;  // ilvl to use for new insertion
            numId: string | null;
        } | null;
    }

    /**
     * Fetch the "neighborhood" around a target paragraph for context-aware insertion.
     * Returns ±3 paragraphs to give AI stylistic context.
     */
    function fetchNeighborhood(
        targetId: number, 
        snapshot: DocumentSnapshot
    ): NeighborhoodContext {
        const paragraphs = snapshot.paragraphs;
        const targetIdx = targetId - 1;  // Convert 1-based to 0-based
        
        // Find target in sparse snapshot (may not have all paragraphs for large docs)
        const target = paragraphs.find(p => p.id === targetId);
        
        if (!target) {
            // Target not in snapshot, return minimal context
            return {
                target: { 
                    id: targetId, text: "", styleId: "Normal", token: "T_Normal",
                    clauseRef: null, fmt: { bold: false, allCaps: false, alignment: "Left" },
                    list: { isListItem: false, level: 0, listString: null }
                },
                before: [],
                after: [],
                listContext: null
            };
        }
        
        // Get up to 3 paragraphs before (filter by ID proximity in case of sparse snapshot)
        const before = paragraphs
            .filter(p => p.id < targetId && p.id >= targetId - 3)
            .sort((a, b) => a.id - b.id);
        
        // Get up to 3 paragraphs after
        const after = paragraphs
            .filter(p => p.id > targetId && p.id <= targetId + 3)
            .sort((a, b) => a.id - b.id);
        
        // Calculate list context for smart insertion
        let listContext: NeighborhoodContext['listContext'] = null;
        
        if (target.list.isListItem) {
            const parentIlvl = target.list.level;
            
            // Smart Level Calculation:
            // - If target is a top-level heading (ilvl=0), new item should be first child (ilvl=1)
            // - Otherwise, new item should be a sibling (same ilvl)
            const isTopLevelHeading = parentIlvl === 0 && 
                (target.fmt.bold || target.styleId.toLowerCase().includes("heading"));
            
            const recommendedIlvl = isTopLevelHeading ? 1 : parentIlvl;
            
            listContext = {
                isInList: true,
                parentIlvl,
                recommendedIlvl,
                numId: target.list.listString ? target.list.listString.split('.')[0] : null
            };
        }
        
        return { target, before, after, listContext };
    }

    /**
     * Format neighborhood for AI prompt context
     */
    function formatNeighborhoodForPrompt(neighborhood: NeighborhoodContext): string {
        const lines = ["[CONTEXT: Surrounding paragraphs for style matching]"];
        
        for (const p of neighborhood.before) {
            lines.push(`  BEFORE [${p.id}]: "${p.text.substring(0, 80)}..."`);
        }
        
        lines.push(`  TARGET [${neighborhood.target.id}]: "${neighborhood.target.text.substring(0, 80)}..."`);
        
        for (const p of neighborhood.after) {
            lines.push(`  AFTER [${p.id}]: "${p.text.substring(0, 80)}..."`);
        }
        
        if (neighborhood.listContext) {
            lines.push(`  LIST: ilvl=${neighborhood.listContext.parentIlvl}, recommended=${neighborhood.listContext.recommendedIlvl}`);
        }
        
        return lines.join("\n");
    }

    // ==========================================
    // NETWORK LAYER - Model Fetching
    // ==========================================

    async function fetchModelsFromGoogle(apiKey: string): Promise<any[]> {
        const url = `https://generativelanguage.googleapis.com/v1beta/models?key=${apiKey}`;
        const response = await fetch(url);
        if (!response.ok) throw new Error("Failed to fetch models");
        const data = await response.json();
        
        const allModels = data.models || [];
        
        const textModels = allModels.filter((m: any) => 
            m.supportedGenerationMethods?.includes("generateContent")
        );
        
        const getVersion = (name: string): number => {
            const match = name.match(/gemini-(\d+\.?\d*)/i);
            return match ? parseFloat(match[1]) : 0;
        };
        
        const getTier = (name: string): number => {
            const lower = name.toLowerCase();
            if (lower.includes("pro")) return 3;
            if (lower.includes("flash")) return 2;
            return 1;
        };
        
        const getVariant = (name: string): number => {
            const lower = name.toLowerCase();
            if (lower.includes("latest")) return 4;
            if (lower.includes("002")) return 3;
            if (lower.includes("001")) return 2;
            if (lower.includes("exp")) return 1;
            return 0;
        };
        
        textModels.sort((a: any, b: any) => {
            const aName = a.name || "";
            const bName = b.name || "";
            
            const versionDiff = getVersion(bName) - getVersion(aName);
            if (versionDiff !== 0) return versionDiff;
            
            const tierDiff = getTier(bName) - getTier(aName);
            if (tierDiff !== 0) return tierDiff;
            
            return getVariant(bName) - getVariant(aName);
        });
        
        return textModels;
    }

    // ENHANCEMENT 2B: Claude Model Fetching
    async function fetchModelsFromAnthropic(apiKey: string): Promise<any[]> {
        const url = "https://api.anthropic.com/v1/models";
        const response = await fetch(url, {
            method: "GET",
            headers: {
                "x-api-key": apiKey,
                "anthropic-version": "2023-06-01",
                "anthropic-dangerous-direct-browser-access": "true"
            }
        });
        
        if (!response.ok) throw new Error("Failed to fetch Claude models");
        const data = await response.json();
        
        const models = data.data || [];
        
        // Sort by created_at descending (newest first)
        models.sort((a: any, b: any) => {
            const aDate = new Date(a.created_at || 0).getTime();
            const bDate = new Date(b.created_at || 0).getTime();
            return bDate - aDate;
        });
        
        // Transform to match Gemini format for UI compatibility
        return models.map((m: any) => ({
            name: m.id,
            displayName: m.display_name || m.id
        }));
    }

    // ==========================================
    // GEMINI API CALLS (with Structured Reasoning)
    // ==========================================

    // ENHANCEMENT 1A: Structured Reasoning for Router
    // ENHANCEMENT 3: Terminology-aware routing for complex transformations
    // ENHANCEMENT 4: Contract Map integration for semantic understanding
    async function callGeminiRouter(
        apiKey: string, 
        model: string, 
        prompt: string, 
        styleMenu: string, 
        snapshot: DocumentSnapshot,
        cacheId: string | null,
        isComplexTransformation: boolean = false,
        fullDocumentText: string = "",
        contractMap: ContractMap | null = null,
        deltaText: string = "",           // NEW: Delta updates since cache
        neighborhoodText: string = ""     // NEW: Surrounding context for insertions
    ): Promise<any> {
        if (!apiKey) throw new Error("API Key missing.");
        const cleanModel = (model || "gemini-2.0-flash-exp").replace(/^models\//, "");
        const url = `https://generativelanguage.googleapis.com/v1beta/models/${cleanModel}:generateContent?key=${apiKey}`;

        const backtick = String.fromCharCode(96);
        const snapshotJSON = JSON.stringify(snapshot.paragraphs, null, 2);
        
        const contextAnalysis = analyzePromptForReferences(prompt, cacheState.changelog);
        const contextSection = buildContextSection(cacheState.changelog, contextAnalysis);
        
        // Contract Map intelligence (if available)
        const contractMapSection = buildContractMapContext(contractMap);
        
        const contextInstruction = cacheId 
            ? "You have the FULL CONTRACT loaded in your context. Use this deep knowledge to understand parties, defined terms, liability caps, cross-references, and document structure."
            : "Working in direct mode without cached context. Analyze based on the snapshot provided.";

        // ENHANCEMENT 1C: Self-check instruction for short documents
        const isShortDocument = snapshot.totalParagraphs < 20;
        const selfCheckInstruction = isShortDocument 
            ? "\n\n=== SELF-CHECK (Required for short documents) ===\nBefore finalizing your response, verify:\n1. Each action in the actions array directly maps to something in your change_plan\n2. No actions are included that weren't in your plan\n3. Your changes don't touch clauses that should remain unchanged\n4. Defined terms are used consistently"
            : "";

        // ENHANCEMENT 3: Complex transformation mode with full document and terminology
        let complexTransformationSection = "";
        let fullDocumentSection = "";
        
        if (isComplexTransformation && fullDocumentText) {
            
            fullDocumentSection = `
    === FULL DOCUMENT TEXT ===
    The complete document is provided below for context. Use this to ensure consistent terminology across ALL modifications.
    
    ${fullDocumentText}
    
    === END FULL DOCUMENT ===`;

            complexTransformationSection = `
    === COMPLEX TRANSFORMATION MODE ===
    This is a complex transformation (like "make mutual", "flip parties", "convert to bilateral").
    
    CRITICAL: Before listing actions, you MUST:
    
    1. DECIDE ON TERMINOLOGY and output it in a "terminology" field:
    {
        "terminology": {
            "transformation_type": "mutual_nda" | "party_swap" | "other",
            "notes": "Describe your approach (e.g., 'Converting one-way NDA to mutual. Both parties can be Disclosing Party or Receiving Party.')",
            "find_replace": [
                { "find": "Recipient", "replace": "Receiving Party", "context": "role-based term for party receiving info" },
                { "find": "Discloser", "replace": "Disclosing Party", "context": "role-based term for party sharing info" }
            ],
            "party_names": {
                "party_a": "Original company name that was Discloser",
                "party_b": "Original company name that was Recipient"
            }
        }
    }
    
    2. Make each MODIFY instruction EXPLICIT and SELF-CONTAINED:
       - DON'T say: "make this mutual" or "apply same changes"
       - DO say: "Replace 'Recipient' with 'Receiving Party'. Replace 'Discloser' with 'Disclosing Party'. Add 'Either party may be the Disclosing Party or Receiving Party under this Agreement.'"
       - Each instruction should work correctly INDEPENDENTLY, without needing to see other modifications
    
    3. Include COMPLETE find/replace instructions in EACH action's instruction field
       Example instruction: "Convert to mutual. In this paragraph: (1) Replace 'the Recipient' with 'the Receiving Party', (2) Replace 'the Discloser' with 'the Disclosing Party', (3) Change 'shall not disclose' to 'each Receiving Party shall not disclose'. Keep all other content unchanged."`;
        }

        // ENHANCEMENT 1A: Structured reasoning output format
        // Build delta updates section (if any changes since cache)
        const deltaSection = deltaText 
            ? `\n    === DELTA UPDATES (LIVE TRUTH) ===
    The cached document is the BASELINE. These are changes made since caching:
    ${deltaText}
    NOTE: If the cache conflicts with these deltas, the DELTA wins - it is the current state.`
            : "";
        
        // Build neighborhood section for insertion context
        const neighborhoodSection = neighborhoodText
            ? `\n    === INSERTION CONTEXT ===
    When generating INSERT content, consider the surrounding text:
    ${neighborhoodText}
    CRITICAL: Match the tone and style. Do NOT repeat content already present above.`
            : "";

        const systemInstruction = `SYSTEM: You are Vibe Legal, an intelligent legal document analyzer.

    === YOUR KNOWLEDGE ===
    ${contextInstruction}
    ${contractMapSection}

    === SESSION CONTEXT ===
    ${contextSection}
    ${fullDocumentSection}
    ${complexTransformationSection}
    ${deltaSection}
    ${neighborhoodSection}

    === STRUCTURED REASONING PROCESS ===
    
    Before generating actions, you MUST think through these steps in the "reasoning" field:

    1. TASK UNDERSTANDING: What exactly is being asked? What is explicitly OUT OF SCOPE and must NOT be changed?
    
    2. DOCUMENT ANALYSIS: What defined terms exist that relate to this task? Where are ALL relevant clauses?
    
    3. CHANGE PLAN: Create a numbered list of specific changes needed (and ONLY those changes)
    
    4. VERIFICATION: Confirm each action in the actions array maps to something in the change_plan

    === DOCUMENT ANALYSIS PROCESS ===

    STEP 1: IDENTIFY THE "MAIN CLAUSE" PATTERN
    Look at the SNAPSHOT paragraphs. Find patterns like "1. Term", "2. Payment", etc.
    Analyze:
    - Which styleId/token is used for these numbered clauses?
    - Are they Bold (fmt.bold = true)? All Caps (fmt.allCaps = true)?
    - Is the numbering manual (e.g. "1.", "2.") or from a Word list (list.isListItem = true)?

    STEP 2: IDENTIFY THE DOCUMENT STRUCTURE
    - "Block" style: Heading on its own paragraph, body on the next
    - "Inline" style: Heading and body combined with bold title

    STEP 3: GENERATE YOUR RESPONSE
    Apply the EXACT same style tokens and formatting to new content.

    === CURRENT DOCUMENT STRUCTURE ===
    ⚠️ CRITICAL: The FULL contract document is in your cached context (all clauses, all annexes).
    The "PARAGRAPH ID REFERENCE" below is TRUNCATED (first 40 + last 10 paragraphs only).
    
    DO NOT say "clause X doesn't exist" based on the truncated reference!
    ALWAYS use your CACHED CONTEXT to find clauses and content.
    The cached document contains the COMPLETE contract with ALL clauses.

    ${deltaText ? `=== SESSION CHANGES (Delta Log) ===
    The following changes have been made since the cache was created.
    Use this to understand the CURRENT state of the document:
    ${deltaText}
    ` : ""}
    
    STYLE MENU (available styles with tokens):
    ${styleMenu}

    PARAGRAPH ID REFERENCE (for location_id only - use cache for content):
    ${snapshotJSON}

    TOTAL PARAGRAPHS: ${snapshot.totalParagraphs}
    LAST PARAGRAPH ID: ${snapshot.lastParagraphId}

    === OUTPUT FORMAT (JSON ONLY) ===
    Return ONLY valid JSON. No markdown. No code blocks (no ${backtick}${backtick}${backtick}).

    {
        "intent": "INSERT" | "MODIFY" | "HYBRID" | "ANSWER",
        "terminology": {
            "transformation_type": "mutual_nda | party_swap | other (ONLY for complex transformations)",
            "notes": "Describe the transformation approach",
            "find_replace": [{ "find": "old term", "replace": "new term" }]
        },
        "reasoning": {
            "task_understanding": "What exactly is being asked? What is OUT OF SCOPE?",
            "document_analysis": "What defined terms exist? Where are ALL relevant clauses?",
            "change_plan": ["1. First change...", "2. Second change..."],
            "verification": "Confirm: action 1 maps to change_plan item X, etc."
        },
        "analysis": {
            "clauseStyle": { "token": "S1", "styleId": "Normal", "isBold": true, "isAllCaps": false },
            "bodyStyle": { "token": "S1", "styleId": "Normal" },
            "structure": "inline" | "block",
            "lastClauseNumber": 5
        },
        "answer": "Optional explanation of what you're doing and why",
        "operations": [
            {
                "type": "AMEND",
                "scope": "NODE" | "TREE",
                "target_id": 37,
                "target": { "number": "17", "title": "General Coverage" },
                "paragraph_operations": [
                    { "id": "P101", "action": "KEEP" },
                    { "id": "P102", "action": "AMEND", "new_text": "Modified paragraph text..." },
                    { "id": "P103", "action": "DELETE", "reason": "Merged into P102" },
                    { "id": "P104", "action": "INSERT_AFTER", "new_text": "New paragraph to add after this one" }
                ]
            },
            {
                "type": "AMEND_SIMPLE",
                "scope": "NODE",
                "target_id": 42,
                "target": { "number": "17.1", "title": "Specific Sub-clause" },
                "amended_text": "For SINGLE-PARAGRAPH edits only: the new text"
            },
            {
                "type": "INSERT",
                "target": { "after": "17.2", "title": "After Liability Limits" },
                "content": "17.3 Cyber Liability. The Supplier shall maintain..."
            },
            {
                "type": "INSERT_BLOCK",
                "insert_after": 26,
                "paragraphs": [
                    { "content": "18. Jurisdiction", "clone_from": 25, "list_level": 0 },
                    { "content": "The parties irrevocably agree...", "clone_from": 26, "list_level": 1 }
                ]
            },
            {
                "type": "DELETE",
                "target": { "number": "17.4", "title": "Outdated Provision" },
                "reason": "This provision is superseded by the new cyber liability clause"
            }
        ]
    }

    === RULES ===

    RULE 0: SEMANTIC INTENT DETECTION (CRITICAL - MUST FOLLOW)
    
    ⚠️ MANDATORY: These verbs REQUIRE operations[] array, NOT just an answer:
    - SIMPLIFY, SHORTEN, CLARIFY → AMEND operation
    - ADD, INSERT, INCLUDE → INSERT operation
    - DELETE, REMOVE, DROP → DELETE operation
    - BEEF UP, STRENGTHEN, ENHANCE, EXPAND → AMEND + optional INSERT
    - CHANGE, MODIFY, UPDATE, REWRITE → AMEND operation
    
    RULE 0B: SEMANTIC SCOPING (NODE vs TREE)
    
    For AMEND/AMEND_SIMPLE operations, you MUST determine the SCOPE:
    
    scope: "NODE" - Use when user targets a SPECIFIC provision:
    - "Amend clause 10.1" → NODE (only 10.1, not 10.2)
    - "Change the payment terms in 5.2" → NODE
    - "Shorten 8.3.1" → NODE
    - User references a SUB-CLAUSE number (has dots like X.Y)
    
    scope: "TREE" - Use when user wants to rewrite an ENTIRE section:
    - "Simplify Clause 10" → TREE (may affect 10, 10.1, 10.2 etc.)
    - "Rewrite the Confidentiality section" → TREE
    - "Make the termination provisions clearer" → TREE
    - User references a MAIN CLAUSE number (no dots like X)
    
    DEFAULT: If uncertain, use "NODE" (safer - prevents collateral damage).
    
    RULE 0C: ID-FIRST TARGETING (CRITICAL - Eliminates Header Trap)
    
    The document text is prefixed with paragraph IDs: [P1], [P2], etc.
    When you target a clause, LOOK UP the exact ID in the text provided.
    
    ⚠️ ALWAYS return target_id with the paragraph number:
    - User says "Amend 10.1" → Find "[P37] 10.1 Law..." in text → Return target_id: 37
    - User says "Amend Governing Law" → Find "[P37] 10.1 Law..." → Return target_id: 37
    
    WHY: target_id bypasses complex resolution logic. Zero ambiguity.
    
    Example:
    If document shows: [P36] 10. GOVERNING LAW\n[P37] 10.1 Law: This Agreement...
    And user asks to "amend 10.1":
    - target_id: 37 (NOT 36 which is the header!)
    - target: { "number": "10.1", "title": "Law" }
    
    RULE 0D: GROUPED INSERT (Multi-Paragraph Clauses)
    
    When inserting a NEW CLAUSE with header + body, use INSERT_BLOCK (not multiple INSERT):
    
    {
        "type": "INSERT_BLOCK",
        "insert_after": 26,           // Paragraph ID to insert AFTER
        "paragraphs": [
            { "content": "Jurisdiction", "clone_from": 25, "list_level": 0 },
            { "content": "The parties agree...", "clone_from": 26, "list_level": 1 }
        ]
    }
    
    clone_from = Paragraph ID with SIMILAR STYLE to copy formatting from:
    - For numbered headings: clone_from = nearest clause heading (e.g., P25 "7. Governing Law")
    - For body text: clone_from = nearest body paragraph (e.g., P26)
    - For sub-clauses (10.1): clone_from = nearest sub-clause heading
    
    list_level: (ABSOLUTE LEVELING - Word Auto-Numbers)
    - 0 = Main Clause (Word generates: 6., 7.)
    - 1 = Sub-clause (Word generates: 6.1, 6.2)
    - 2 = Sub-sub-clause (Word generates: 6.1.1, 6.1.2)
    - null = Plain text (no numbering)
    
    ⚠️ NEVER include clause numbers in content. Word generates them automatically.
    ✅ CORRECT: { "content": "GOVERNING LAW", "list_level": 0 }
    ❌ WRONG: { "content": "6. GOVERNING LAW", "list_level": 0 }
    
    Example: To add clause 6 with sub-clauses 6.1 and 6.2:
    { "content": "GOVERNING LAW", "clone_from": 23, "list_level": 0 }
    { "content": "Applicable Law", "clone_from": 24, "list_level": 1 }
    { "content": "Jurisdiction", "clone_from": 24, "list_level": 1 }
    
    This ensures the new clause MATCHES the document's existing formatting.
    
    ⚠️ PARAGRAPH-MAPPED AMEND (CRITICAL for multi-paragraph sections):
    When you receive a SECTION CONTEXT with paragraph IDs like:
    [P1595] 64. REMOTE WORKING [HEADING]
    [P1596] The Supplier must ensure... [BODY]
    [P1597] 64.1.1 unless in writing... [SUB-1]
    
    You MUST return paragraph_operations array with action for EACH paragraph:
    - KEEP: Paragraph unchanged (no redline)
    - AMEND: Provide new_text (character-level diff applied)
    - DELETE: Paragraph will be struck through
    - INSERT_AFTER: Add new paragraph after this one (provide new_text)
    
    EXAMPLE - "Simplify clause 64" with section context:
    ✅ CORRECT:
    {
        "type": "AMEND",
        "target": { "number": "64" },
        "paragraph_operations": [
            { "id": "P1595", "action": "KEEP" },
            { "id": "P1596", "action": "AMEND", "new_text": "Simplified intro text..." },
            { "id": "P1597", "action": "DELETE", "reason": "Redundant" },
            { "id": "P1598", "action": "AMEND", "new_text": "Simplified sub-clause..." }
        ]
    }
    ❌ WRONG: Return "amended_text" blob for multi-paragraph sections
    
    ⚠️ SINGLE-PARAGRAPH EXCEPTION:
    For simple single-paragraph edits, you MAY use AMEND_SIMPLE with amended_text.
    
    If user references a clause/paragraph number, SEARCH THE ENTIRE CACHED DOCUMENT including Annexes.
    The Annexes continue numbering beyond clause 36.
    
    OPERATIONS GUIDE:
    - AMEND: Multi-paragraph. Return paragraph_operations array with action for each [P#] ID
    - AMEND_SIMPLE: Single-paragraph only. Include amended_text
    - INSERT: Add new content. Include target.after (section to insert after) and content
    - DELETE: Remove content. Include target and reason
    
    You may return MULTIPLE operations for a single request.
    
    ⚠️ NEVER return just an "answer" for modification verbs. ALWAYS return operations[].

    RULE 0E: SMART DELETE (Numbering Preservation in Contracts)
    
    When a user asks to "delete", "remove", or "take out" a clause:
    
    1. ANALYZE THE CONTEXT:
       - Is the target a NUMBERED clause (e.g., "5.2", "Article III", "[P45] 8. Warranties")?
       - Is the target part of an auto-numbered list (list.isListItem = true)?
       - Would deletion disrupt cross-references or clause numbering?
    
    2. CHOOSE THE APPROPRIATE ACTION:
    
       SOFT DELETE (use AMEND with "[Reserved]"):
       → When deleting a NUMBERED clause in a numbered sequence
       → Preserves numbering so "Clause 6" doesn't become "Clause 5"
       → Standard legal practice for contract amendments
       
       Example - "Delete clause 5":
       {
           "type": "AMEND_SIMPLE",
           "target_id": 45,
           "target": { "number": "5", "title": "Warranties" },
           "amended_text": "[Reserved]"
       }
       
       HARD DELETE (use DELETE):
       → For non-numbered paragraphs (definitions, recitals, plain text)
       → When user explicitly says "remove completely", "delete and renumber", or "remove without reservation"
       → For content that doesn't affect document numbering
       
       Example - "Remove the first recital paragraph":
       {
           "type": "DELETE",
           "target_id": 3,
           "target": { "title": "Recital paragraph" },
           "reason": "Non-numbered content, safe to remove"
       }
    
    3. DEFAULT BEHAVIOR:
       - For NUMBERED clauses: Default to SOFT DELETE (AMEND with "[Reserved]")
       - For non-numbered content: Use HARD DELETE
       - If uncertain: Prefer SOFT DELETE (safer for contracts)


    RULE 1: STYLE MATCHING
    - Use the EXACT token from your analysis for clause titles and body text
    - If structure is "inline", combine title and body in ONE block with **bold** title
    - If structure is "block", use separate blocks for title and body

    RULE 2: INLINE FORMATTING
    - Use **text** for bold, *text* for italic
    - The engine converts these to proper OXML runs

    RULE 3: LOCATION SEMANTICS
    - location_id means "insert AFTER this paragraph ID"
    - To insert BEFORE paragraph 25, use location_id: 24
    - STANDARD CONTRACT ORDER: Definitions, Operative terms, Boilerplate, Governing Law, Signatures
    - BOILERPLATE (No Waiver, Severability, etc.) goes BEFORE Governing Law

    RULE 4: NUMBERING
    - Continue from the last clause number, match the format (1. vs 1) vs (1))

    RULE 5: INDEPENDENCE
    - Unless the user explicitly references previous work, treat this as a fresh request
    - Do not carry over specific values ($, dates, names) from previous changes to new clauses

    RULE 6: HIERARCHICAL CLAUSE REFERENCES
    When user says "add clause 3.4" or "insert section 2.3":
    - The clauseRef field in the snapshot shows detected clause numbers (e.g., "3", "3.1", "3.2")
    - Find the paragraph where clauseRef matches the last sibling (e.g., for "3.4", find "3.3")
    - Set location_id to that paragraph's ID
    - If inserting a sub-clause like "3.4", the list.level should match its siblings
    
    RULE 7: AUTOMATIC LIST NUMBERING
    When inserting into an auto-numbered list (where list.isListItem is true and list.listString exists):
    - Do NOT include the clause number in your content
    - Word automatically generates the next number in sequence
    - CORRECT: "**Dishonesty.** Either Party may terminate..."
    - WRONG: "**11.4.1.6 Dishonesty.** Either Party may terminate..."
    
    The snapshot's list.listString shows the auto-generated number (e.g., "11.4.1.5").
    If listString is present, omit the number from your INSERT content.
    For manual numbering (no listString), include the number in your content.
    
    Example: "Add clause 11.4.1.6 about termination for dishonesty"
    1. Find paragraph with clauseRef/listString: "11.4.1.5"
    2. Use that paragraph's id as location_id
    3. Content: "**Dishonesty.** Either Party may terminate this Agreement immediately..."
    
    RULE 8: AI-FIRST NAVIGATION (REQUIRED FOR INSERT AND MODIFY)
    For every INSERT or MODIFY action, you MUST include a "navigation" object:
    {
        "target_number": "17",           // Section NUMBER (preferred, e.g., "17" or "17.1")
        "target_title": "Insurance",     // Section TITLE (fallback if number unclear)
        "position": "end"                // For INSERT: "end" (append) or "start" (prepend)
                                         // For MODIFY: "section" (entire section) or "body" (exclude heading)
    }
    
    FOR INSERT: The system inserts AFTER the last paragraph of the target section.
    FOR MODIFY: The system identifies the RANGE of paragraphs in that section and applies redlines.
    
    SECTION-LEVEL MODIFICATIONS:
    When user asks to "change", "simplify", "update", or "amend" an existing clause:
    - Set intent to "MODIFY" (NOT "INSERT")
    - Include navigation pointing to the EXISTING section
    - The instruction field should describe HOW to change the text
    
    Example: "Make the IP clause simpler"
    → intent: "MODIFY"
    → navigation: { target_number: "12", target_title: "Intellectual Property" }
    → instruction: "Simplify the language. Use shorter sentences. Remove redundant phrases."
    
    - Prioritize section NUMBER if the contract has clear numbering
    - Always include BOTH target_number and target_title for robustness
    
    RULE 9: SUPER FOCUS MODE (Router-First Amendment Drafting)
    When user asks to modify specific clauses or sections:
    - Use "modification_plan" array for targeted modifications
    - YOU must draft the amended text directly (you have the document cache)
    
    Each modification_plan entry MUST include:
    - target_anchor: { number, title } - identifies the section
    - instruction: What the user asked to change
    - original_text: The EXACT current text of the section (copy from cached document)
    - amended_text: Your FULL rewritten version with changes applied
    
    CRITICAL RULES FOR amended_text:
    1. Preserve ALL structural elements (headers, subclause markers)
    2. Keep the same clause numbering format
    3. Only change what the user asked to change
    4. Do NOT delete critical structural phrases
    5. The amended_text replaces the ENTIRE original_text
    
    Example: "Simplify the backup clause"
    → modification_plan: [{
        target_anchor: { number: "17", title: "Backup and Recovery" },
        instruction: "Simplify the language",
        original_text: "The Supplier must ensure that the Supplier System: backs up and allows...",
        amended_text: "The Supplier must ensure that the Supplier System: creates backups and enables..."
    }]
    ${selfCheckInstruction}

    === CURRENT REQUEST ===
    ${prompt}`;

        const requestBody: any = {
            contents: [{ parts: [{ text: systemInstruction }] }],
            generationConfig: { responseMimeType: "application/json" }
        };
        
        // DIAGNOSTIC: Log cache usage
        log(" ROUTER DIAGNOSTIC: cacheId = " + (cacheId ? cacheId.substring(0, 50) + "..." : "NULL (CACHE NOT USED!)"));
        
        if (cacheId) {
            requestBody.cachedContent = cacheId;
            log(" ROUTER DIAGNOSTIC: Cache attached to request");
        } else {
            logWarn(" ROUTER DIAGNOSTIC: NO CACHE - AI will not see full document!");
        }

        const response = await fetch(url, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(requestBody)
        });

        const data = await response.json();
        const text = data.candidates?.[0]?.content?.parts?.[0]?.text?.trim() || "{}";


        let result = tryParseJSON(text);

        if (!result) {
            logWarn(" Router failed to parse JSON.");
            result = {
                intent: "ANSWER",
                answer: "I understood your request but had trouble processing the response. Please try again."
            };
        }

        if (result.reasoning) {
        }
        if (result.analysis) {
        }

        return result;
    }

    // Robust JSON Parser (The "JSON Shield")
    function tryParseJSON(str: string) {
        if (!str) return null;
        try {
            let cleanStr = str.replace(/```json\s*|\s*```/g, "").trim();
            return JSON.parse(cleanStr);
        } catch (e) {
            logWarn(" Direct JSON parse failed. Engaging Shield Protocols...", e);

            try {
                const firstOpen = str.indexOf('{');
                const lastClose = str.lastIndexOf('}');

                if (firstOpen !== -1 && lastClose !== -1 && lastClose > firstOpen) {
                    let candidate = str.substring(firstOpen, lastClose + 1);
                    candidate = candidate.replace(/([{,]\s*)([a-zA-Z0-9_]+?)\s*:/g, '$1"$2":');
                    candidate = candidate.replace(/,\s*}/g, '}').replace(/,\s*]/g, ']');
                    return JSON.parse(candidate);
                }
            } catch (e2) {
                console.error("[Vibe] JSON Shield failed.", e2);
            }
            return null;
        }
    }

    /**
     * ID ECHO PROTOCOL: Wrap paragraphs with ID tags for deterministic matching.
     * Input: Original paragraph texts with their IDs
     * Output: Tagged text like "<P38>Original text...</P38>\n<P39>More text...</P39>"
     */
    function wrapParagraphsWithIdTags(
        paragraphsWithIds: Array<{ id: number; text: string }>
    ): string {
        return paragraphsWithIds
            .filter(p => p.text.trim().length > 0)
            .map(p => `<P${p.id}>${p.text.trim()}</P${p.id}>`)
            .join('\n');
    }

    /**
     * ID ECHO PROTOCOL: Parse tagged output back to paragraph IDs and content.
     * Returns Map of id -> content for modified paragraphs.
     */
    function parseIdTaggedText(taggedText: string): Map<number, string> {
        const result = new Map<number, string>();
        const tagPattern = /<P(\d+)>([\s\S]*?)<\/P\1>/g;
        let match;
        while ((match = tagPattern.exec(taggedText)) !== null) {
            result.set(parseInt(match[1], 10), match[2].trim());
        }
        return result;
    }

    // ENHANCEMENT 1B: Structured Reasoning for Redline
    async function callGeminiRedline(
        apiKey: string, 
        model: string, 
        instruction: string, 
        originalText: string,
        cacheId: string | null,
        neighborhoodText: string = ""     // NEW: Surrounding context for style matching
    ): Promise<string> {
        const cleanModel = (model || "gemini-2.0-flash-exp").replace(/^models\//, "");
        const url = `https://generativelanguage.googleapis.com/v1beta/models/${cleanModel}:generateContent?key=${apiKey}`;

        const contextAnalysis = analyzePromptForReferences(instruction, cacheState.changelog);
        
        let contextNote = "";
        if (cacheId) {
            contextNote = "You have the full contract in context. Use this to ensure accurate cross-references (e.g., 'subject to Section 12' or 'as defined above').";
        }
        
        let referenceNote = "";
        if (contextAnalysis.includeHistory && contextAnalysis.relevantEntries.length > 0) {
            const lastChange = contextAnalysis.relevantEntries[0];
            referenceNote = "\nUser may be referencing recent change: " + lastChange.description;
        }
        
        // NEW: Neighborhood context for style matching
        const neighborhoodNote = neighborhoodText
            ? "\n\n=== SURROUNDING CONTEXT ===\n" + neighborhoodText +
              "\nMatch the tone and numbering style of surrounding text. Do NOT repeat content already present."
            : "";

        // ID ECHO PROTOCOL: Check if input contains ID tags
        const hasIdTags = /<P\d+>/.test(originalText);
        const idEchoInstructions = hasIdTags 
            ? "\n\n=== ID ECHO PROTOCOL ===\n" +
              "Input contains ID tags like <P38>text</P38>.\n" +
              "CRITICAL: You MUST preserve these tags in your output!\n" +
              "- To AMEND: Change text inside the tag: <P38>new text here</P38>\n" +
              "- To DELETE: Remove the tag and its content entirely (do not include it)\n" +
              "- To INSERT: Add new untagged text BETWEEN existing tags\n" +
              "The tags are essential for tracking changes. DO NOT invent new tags."
            : "";

        // ENHANCEMENT 1B: Updated redline prompt with structured thinking
        const systemInstruction = "SYSTEM: You are a strict legal editor.\n" +
            contextNote + "\n" +
            referenceNote +
            neighborhoodNote +
            idEchoInstructions + "\n\n" +
            "CRITICAL RULES:\n" +
            "1. Return ONLY the modified text content\n" +
            "2. Do NOT add numbering (1., 2., a., etc.) - Word handles this automatically\n" +
            "3. Do NOT add bullet points or list markers\n" +
            "4. Preserve the exact structure - if given one paragraph, return one paragraph\n" +
            "5. Make ONLY the requested change, nothing else\n" +
            (hasIdTags ? "6. PRESERVE ALL ID TAGS (<P#>) in your output\n" : "") + "\n" +
            "BEFORE MAKING CHANGES, THINK THROUGH:\n" +
            "1. What specific change is requested? (State in one sentence)\n" +
            "2. What should NOT be changed? (Be explicit)\n" +
            "3. Make ONLY the requested change, nothing else.\n\n" +
            "IMPORTANT: Apply ONLY what the instruction asks for. Do not carry over specific values from other clauses unless explicitly requested.\n\n" +
            "Return ONLY the modified legal text. No markdown. No quotes. No LaTeX. No explanations. No numbering. Preserve placeholders like [Name].\n\n" +
            "The output must contain ONLY the modified text, nothing else.";

        const fullPrompt = `ORIGINAL TEXT: "${originalText}"\n\nINSTRUCTION: ${instruction}`;

        const requestBody: any = {
            contents: [{ parts: [{ text: `${systemInstruction}\n\n${fullPrompt}` }] }]
        };
        
        if (cacheId) {
            requestBody.cachedContent = cacheId;
        }

        const response = await fetch(url, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            const errorMsg = errorData.error?.message || `HTTP ${response.status}`;
            console.error("[Vibe] Redline API Error:", response.status, errorMsg);
            console.error("[Vibe] Original text was:", originalText.substring(0, 100) + "...");
            throw new Error(`Redline Error: ${errorMsg}`);
        }
        const data = await response.json();
        return data.candidates?.[0]?.content?.parts?.[0]?.text?.trim() || originalText;
    }

    async function callGeminiQuestion(
        apiKey: string,
        model: string,
        question: string,
        currentDocumentText: string,
        changelog: ChangeEntry[],
        cacheId: string | null
    ): Promise<string> {
        const cleanModel = (model || "gemini-2.0-flash-exp").replace(/^models\//, "");
        const url = `https://generativelanguage.googleapis.com/v1beta/models/${cleanModel}:generateContent?key=${apiKey}`;
        
        const isShortDocument = currentDocumentText.length < CACHE_CONFIG.minCacheChars;
        
        let changeSection = "";
        if (changelog.length > 0) {
            const changes = changelog.map((c, i) => {
                const contentPreview = c.content 
                    ? "\nNew text: \"" + c.content.substring(0, 1000) + (c.content.length > 1000 ? "..." : "") + "\""
                    : "";
                return "[" + (i + 1) + "] " + c.type + ": " + c.description + contentPreview;
            }).join("\n\n");
            
            changeSection = "\n=== CHANGES MADE THIS SESSION ===\nThe following changes have been applied (shown as track changes in Word):\n\n" + changes + "\n\nIMPORTANT: These changes are now part of the document. Answer based on the CURRENT state.\n";
        }
        
        let systemPrompt: string;
        
        if (isShortDocument) {
            
            systemPrompt = "You are Vibe Legal, a legal document analyst.\n\n=== CURRENT DOCUMENT (FULL TEXT) ===\n" + currentDocumentText + "\n" + changeSection + "\n=== INSTRUCTIONS ===\nAnswer the user's question based on the document above.\nThis is the CURRENT state of the document with all changes applied.\nBe specific and reference actual clauses or language.\n\nUSER QUESTION: " + question;
        } else {
            
            const contextNote = cacheId
                ? "You have the full contract loaded in your context from when the session started."
                : "Note: Document context not cached. Working with changelog only.";
            
            const criticalInstruction = changelog.length > 0 
                ? "Changes have been made this session. Your cached knowledge may be OUTDATED for the modified sections.\nTrust the changelog above for any topics that were changed.\nFor example, if the changelog shows confidentiality was changed from one-way to mutual,\nthe document is NOW mutual - do not rely on your cached memory of it being one-way."
                : "No changes have been made this session. Your cached knowledge is current.";
            
            systemPrompt = "You are Vibe Legal, a legal document analyst.\n\n=== YOUR KNOWLEDGE ===\n" + contextNote + "\n" + changeSection + "\n=== CRITICAL INSTRUCTION ===\n" + criticalInstruction + "\n\nAnswer the user's question based on the CURRENT state of the document.\nBe specific and reference actual clauses or language.\n\nUSER QUESTION: " + question;
        }
        
        const requestBody: any = {
            contents: [{ parts: [{ text: systemPrompt }] }]
        };
        
        if (!isShortDocument && cacheId) {
            requestBody.cachedContent = cacheId;
        }
        
        const response = await fetch(url, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(requestBody)
        });
        
        if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(errorData.error?.message || "HTTP " + response.status);
        }
        
        const data = await response.json();
        return data.candidates?.[0]?.content?.parts?.[0]?.text?.trim() || "I couldn't analyze the document.";
    }

    // ==========================================
    // CLAUDE API CALLS (ENHANCEMENT 2C)
    // ==========================================

    async function callClaudeRouter(
        apiKey: string, 
        model: string, 
        prompt: string, 
        styleMenu: string, 
        snapshot: DocumentSnapshot,
        cacheId: string | null,  // Always null for Claude
        isComplexTransformation: boolean = false,
        fullDocumentText: string = "",
        contractMap: ContractMap | null = null
    ): Promise<any> {
        if (!apiKey) throw new Error("API Key missing.");

        const backtick = String.fromCharCode(96);
        const snapshotJSON = JSON.stringify(snapshot.paragraphs, null, 2);
        
        const contextAnalysis = analyzePromptForReferences(prompt, cacheState.changelog);
        const contextSection = buildContextSection(cacheState.changelog, contextAnalysis);
        
        // Contract Map intelligence (if available)
        const contractMapSection = buildContractMapContext(contractMap);

        const isShortDocument = snapshot.totalParagraphs < 20;
        const selfCheckInstruction = isShortDocument 
            ? "\n\n=== SELF-CHECK (Required for short documents) ===\nBefore finalizing your response, verify:\n1. Each action in the actions array directly maps to something in your change_plan\n2. No actions are included that weren't in your plan\n3. Your changes don't touch clauses that should remain unchanged\n4. Defined terms are used consistently"
            : "";

        // ENHANCEMENT 3: Complex transformation mode with full document and terminology
        let complexTransformationSection = "";
        let fullDocumentSection = "";
        
        if (isComplexTransformation && fullDocumentText) {
            
            fullDocumentSection = `
    === FULL DOCUMENT TEXT ===
    ${fullDocumentText}
    === END FULL DOCUMENT ===`;

            complexTransformationSection = `
    === COMPLEX TRANSFORMATION MODE ===
    This is a complex transformation. Before listing actions:
    1. Output a "terminology" field with find/replace mappings
    2. Make each MODIFY instruction EXPLICIT and SELF-CONTAINED
    3. Don't say "make mutual" - say exactly what to find and replace in each paragraph`;
        }

        const systemInstruction = `You are Vibe Legal, an intelligent legal document analyzer.
    ${contractMapSection}

    === SESSION CONTEXT ===
    ${contextSection}
    ${fullDocumentSection}
    ${complexTransformationSection}

    === STRUCTURED REASONING PROCESS ===

    Before generating actions, you MUST think through these steps in the "reasoning" field:

    1. TASK UNDERSTANDING: What exactly is being asked? What is explicitly OUT OF SCOPE and must NOT be changed?

    2. DOCUMENT ANALYSIS: What defined terms exist that relate to this task? Where are ALL relevant clauses?

    3. CHANGE PLAN: Create a numbered list of specific changes needed (and ONLY those changes)

    4. VERIFICATION: Confirm each action in the actions array maps to something in the change_plan

    === DOCUMENT ANALYSIS PROCESS ===

    STEP 1: IDENTIFY THE "MAIN CLAUSE" PATTERN
    Look at the SNAPSHOT paragraphs. Find patterns like "1. Term", "2. Payment", etc.

    STEP 2: IDENTIFY THE DOCUMENT STRUCTURE
    - "Block" style: Heading on its own paragraph, body on the next
    - "Inline" style: Heading and body combined with bold title

    STEP 3: GENERATE YOUR RESPONSE
    Apply the EXACT same style tokens and formatting to new content.

    === CURRENT DOCUMENT STRUCTURE ===

    STYLE MENU (available styles with tokens):
    ${styleMenu}

    DOCUMENT SNAPSHOT (first 40 + last 10 paragraphs):
    ${snapshotJSON}

    TOTAL PARAGRAPHS: ${snapshot.totalParagraphs}
    LAST PARAGRAPH ID: ${snapshot.lastParagraphId}

    === OUTPUT FORMAT ===
    Respond with valid JSON only. No markdown code blocks.

    {
    "intent": "INSERT" | "MODIFY" | "HYBRID" | "ANSWER",
    "reasoning": {
        "task_understanding": "What exactly is being asked? What is OUT OF SCOPE?",
        "document_analysis": "What defined terms exist? Where are ALL relevant clauses?",
        "change_plan": ["1. First change...", "2. Second change..."],
        "verification": "Confirm: action 1 maps to change_plan item X, etc."
    },
    "analysis": {
        "clauseStyle": { "token": "S1", "styleId": "Normal", "isBold": true, "isAllCaps": false },
        "bodyStyle": { "token": "S1", "styleId": "Normal" },
        "structure": "inline" | "block",
        "lastClauseNumber": 5
    },
    "answer": "Optional explanation",
    "actions": [
        {
            "type": "INSERT",
            "location_id": <number>,
            "description": "Human-readable description",
            "blocks": [{ "styleId": "<token>", "content": "**6. New Clause Title.** Body text here..." }]
        },
        {
            "type": "MODIFY",
            "target_id": <number>,
            "description": "Human-readable description",
            "instruction": "What to change"
        }
    ]
    }

    === RULES ===

    RULE 0: ACTION VS ANSWER (CRITICAL)
    When the user asks to CHANGE, ADD, MODIFY, UPDATE, or REMOVE something:
    - You MUST output actions in the "actions" array
    - Do NOT just describe what you would do in the "answer" field  
    - Generate actual MODIFY or INSERT actions
    
    If uncertain whether it's an action or question, DEFAULT TO GENERATING ACTIONS.

    RULE 1: Use the EXACT token from your analysis for clause titles and body text
    RULE 2: Use **text** for bold, *text* for italic
    RULE 3: location_id means "insert AFTER this paragraph ID"
    RULE 4: Continue from the last clause number, match the format
    RULE 5: Unless the user explicitly references previous work, treat this as a fresh request
    RULE 6: HIERARCHICAL CLAUSE REFERENCES - When user says "add clause 3.4":
        - Find clauseRef/listString: "3.3" in snapshot, use that paragraph's ID as location_id
    RULE 7: AUTOMATIC LIST NUMBERING
        - If list.listString exists, DON'T include the number in content (Word auto-generates)
        - CORRECT: "**Title.** Content..."
        - WRONG: "**11.4.1.6 Title.** Content..."
    ${selfCheckInstruction}

    === CURRENT REQUEST ===
    ${prompt}`;

        const response = await fetch("https://api.anthropic.com/v1/messages", {
            method: "POST",
            headers: {
                "x-api-key": apiKey,
                "anthropic-version": "2023-06-01",
                "anthropic-dangerous-direct-browser-access": "true",
                "content-type": "application/json"
            },
            body: JSON.stringify({
                model: model || "claude-sonnet-4-20250514",
                max_tokens: 8192,
                messages: [{ role: "user", content: systemInstruction }]
            })
        });

        if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(errorData.error?.message || `HTTP ${response.status}`);
        }

        const data = await response.json();
        const text = data.content?.[0]?.text?.trim() || "{}";


        let result = tryParseJSON(text);

        if (!result) {
            logWarn(" Claude Router failed to parse JSON.");
            result = {
                intent: "ANSWER",
                answer: "I understood your request but had trouble processing the response. Please try again."
            };
        }

        if (result.reasoning) {
        }

        return result;
    }

    async function callClaudeRedline(
        apiKey: string, 
        model: string, 
        instruction: string, 
        originalText: string,
        cacheId: string | null  // Always null for Claude
    ): Promise<string> {
        const contextAnalysis = analyzePromptForReferences(instruction, cacheState.changelog);
        
        let referenceNote = "";
        if (contextAnalysis.includeHistory && contextAnalysis.relevantEntries.length > 0) {
            const lastChange = contextAnalysis.relevantEntries[0];
            referenceNote = "\nUser may be referencing recent change: " + lastChange.description;
        }

        const systemInstruction = `You are a strict legal editor.
    ${referenceNote}

    BEFORE MAKING CHANGES, THINK THROUGH:
    1. What specific change is requested? (State in one sentence)
    2. What should NOT be changed? (Be explicit)
    3. Make ONLY the requested change, nothing else.

    IMPORTANT: Apply ONLY what the instruction asks for. Do not carry over specific values from other clauses unless explicitly requested.

    Return ONLY the modified legal text. No markdown. No quotes. No LaTeX. No explanations. Preserve placeholders like [Name].

    The output must contain ONLY the modified text, nothing else.

    ORIGINAL TEXT: "${originalText}"

    INSTRUCTION: ${instruction}`;

        const response = await fetch("https://api.anthropic.com/v1/messages", {
            method: "POST",
            headers: {
                "x-api-key": apiKey,
                "anthropic-version": "2023-06-01",
                "anthropic-dangerous-direct-browser-access": "true",
                "content-type": "application/json"
            },
            body: JSON.stringify({
                model: model || "claude-sonnet-4-20250514",
                max_tokens: 4096,
                messages: [{ role: "user", content: systemInstruction }]
            })
        });

        if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            const errorMsg = errorData.error?.message || `HTTP ${response.status}`;
            console.error("[Vibe] Claude Redline API Error:", response.status, errorMsg);
            throw new Error(`Redline Error: ${errorMsg}`);
        }
        
        const data = await response.json();
        return data.content?.[0]?.text?.trim() || originalText;
    }

    async function callClaudeQuestion(
        apiKey: string,
        model: string,
        question: string,
        currentDocumentText: string,
        changelog: ChangeEntry[],
        cacheId: string | null  // Always null for Claude
    ): Promise<string> {
        const isShortDocument = currentDocumentText.length < CACHE_CONFIG.minCacheChars;
        
        let changeSection = "";
        if (changelog.length > 0) {
            const changes = changelog.map((c, i) => {
                const contentPreview = c.content 
                    ? "\nNew text: \"" + c.content.substring(0, 1000) + (c.content.length > 1000 ? "..." : "") + "\""
                    : "";
                return "[" + (i + 1) + "] " + c.type + ": " + c.description + contentPreview;
            }).join("\n\n");
            
            changeSection = "\n=== CHANGES MADE THIS SESSION ===\n" + changes + "\n\nIMPORTANT: These changes are now part of the document. Answer based on the CURRENT state.\n";
        }
        
        let systemPrompt: string;
        
        if (isShortDocument) {
            systemPrompt = "You are Vibe Legal, a legal document analyst.\n\n=== CURRENT DOCUMENT (FULL TEXT) ===\n" + currentDocumentText + "\n" + changeSection + "\n=== INSTRUCTIONS ===\nAnswer the user's question based on the document above.\nBe specific and reference actual clauses or language.\n\nUSER QUESTION: " + question;
        } else {
            // For long documents without cache, send a truncated version
            const truncatedDoc = currentDocumentText.substring(0, 50000) + (currentDocumentText.length > 50000 ? "\n...[document truncated]..." : "");
            systemPrompt = "You are Vibe Legal, a legal document analyst.\n\n=== DOCUMENT EXCERPT ===\n" + truncatedDoc + "\n" + changeSection + "\n=== INSTRUCTIONS ===\nAnswer the user's question based on the document.\nBe specific and reference actual clauses or language.\n\nUSER QUESTION: " + question;
        }
        
        const response = await fetch("https://api.anthropic.com/v1/messages", {
            method: "POST",
            headers: {
                "x-api-key": apiKey,
                "anthropic-version": "2023-06-01",
                "anthropic-dangerous-direct-browser-access": "true",
                "content-type": "application/json"
            },
            body: JSON.stringify({
                model: model || "claude-sonnet-4-20250514",
                max_tokens: 4096,
                messages: [{ role: "user", content: systemPrompt }]
            })
        });
        
        if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(errorData.error?.message || "HTTP " + response.status);
        }
        
        const data = await response.json();
        return data.content?.[0]?.text?.trim() || "I couldn't analyze the document.";
    }

    // ==========================================
    // UNIFIED API DISPATCHER (ENHANCEMENT 2D)
    // ==========================================

    async function callRouter(
        prompt: string, 
        styleMenu: string, 
        snapshot: DocumentSnapshot,
        cacheId: string | null,
        isComplexTransformation: boolean = false,
        fullDocumentText: string = "",
        deltaText: string = "",           // NEW: Delta updates since cache
        neighborhoodText: string = ""     // NEW: Insertion context
    ): Promise<any> {
        const apiKey = getCurrentApiKey();
        const model = getCurrentModel();
        
        if (providerConfig.provider === "claude") {
            return callClaudeRouter(apiKey, model, prompt, styleMenu, snapshot, null, isComplexTransformation, fullDocumentText);
        } else {
            return callGeminiRouter(apiKey, model, prompt, styleMenu, snapshot, cacheId, isComplexTransformation, fullDocumentText, null, deltaText, neighborhoodText);
        }
    }

    async function callRedline(
        instruction: string, 
        originalText: string,
        cacheId: string | null,
        neighborhoodText: string = ""     // NEW: Context for style matching
    ): Promise<string> {
        const apiKey = getCurrentApiKey();
        const model = getCurrentModel();
        
        if (providerConfig.provider === "claude") {
            return callClaudeRedline(apiKey, model, instruction, originalText, null);
        } else {
            return callGeminiRedline(apiKey, model, instruction, originalText, cacheId, neighborhoodText);
        }
    }

    async function callQuestion(
        question: string,
        currentDocumentText: string,
        changelog: ChangeEntry[],
        cacheId: string | null
    ): Promise<string> {
        const apiKey = getCurrentApiKey();
        const model = getCurrentModel();
        
        if (providerConfig.provider === "claude") {
            return callClaudeQuestion(apiKey, model, question, currentDocumentText, changelog, null);
        } else {
            return callGeminiQuestion(apiKey, model, question, currentDocumentText, changelog, cacheId);
        }
    }

    // ==========================================
    // V8.0 COMPILER PATTERN (Tag-Based Abstraction)
    // ==========================================

    interface StyleToken {
        token: string;
        styleId: string;
        styleName: string;
    }

    async function generateStyleMenuAndCache(context: Word.RequestContext, paragraphs: Word.ParagraphCollection): Promise<{ styleCache: Map<string, StyleToken>, menu: string }> {

        paragraphs.load("text, style, styleId");
        await context.sync();

        for (let i = 0; i < Math.min(5, paragraphs.items.length); i++) {
            const p = paragraphs.items[i];
        }

        const styleCache = new Map<string, StyleToken>();
        const menuLines = [];
        const seenStyles = new Map<string, { styleName: string, index: number }>();

        for (let i = 0; i < paragraphs.items.length; i++) {
            const p = paragraphs.items[i];
            const styleName = p.style || "Normal";

            if (!seenStyles.has(styleName) && styleName) {
                seenStyles.set(styleName, { styleName, index: i });
            }
        }

        const standardStyles = [
            { id: "Normal", name: "Normal" },
            { id: "Heading 1", name: "Heading 1" },
            { id: "Heading 2", name: "Heading 2" },
            { id: "Heading 3", name: "Heading 3" }
        ];

        standardStyles.forEach(style => {
            if (!seenStyles.has(style.id)) {
                seenStyles.set(style.id, { styleName: style.name, index: -1 });
            }
        });

        const styleNames = Array.from(seenStyles.keys());
        let tokenCount = 1;

        for (const styleName of styleNames) {
            const info = seenStyles.get(styleName);
            const token = `S${tokenCount++}`;

            styleCache.set(token, {
                token,
                styleId: styleName,
                styleName: styleName
            });

            let category = "BODY";
            const sLower = styleName.toLowerCase();
            if (sLower.includes("heading") || sLower.includes("title")) category = "HEADING";
            else if (sLower.includes("list") || sLower.includes("number")) category = "LIST";

            let sample = "Standard Style";
            if (info.index >= 0) {
                const p = paragraphs.items[info.index];
                try { sample = (p.text || "").substring(0, 30).replace(/\n/g, " "); } catch (e) {}
            }

            const menuObj = { id: token, name: styleName, type: category, sample: sample };
            menuLines.push(JSON.stringify(menuObj));
        }

        return { styleCache, menu: menuLines.join("\n") };
    }

    interface TextSegment {
        text: string;
        bold: boolean;
        italic: boolean;
    }

    function parseMarkdownToSegments(content: string): TextSegment[] {
        const segments: TextSegment[] = [];
        const regex = /(\*\*(.+?)\*\*)|(\*([^*]+?)\*)|([^*]+)/g;
        let match;

        while ((match = regex.exec(content)) !== null) {
            if (match[2]) {
                segments.push({ text: match[2], bold: true, italic: false });
            } else if (match[4]) {
                segments.push({ text: match[4], bold: false, italic: true });
            } else if (match[5]) {
                segments.push({ text: match[5], bold: false, italic: false });
            }
        }

        return segments.length > 0 ? segments : [{ text: content, bold: false, italic: false }];
    }

    function createFormattedRuns(xmlDoc: Document, segments: TextSegment[], WORD_NS: string): Element[] {
        const runs: Element[] = [];

        for (const seg of segments) {
            if (!seg.text || seg.text.length === 0) continue;

            const run = xmlDoc.createElementNS(WORD_NS, "w:r");

            if (seg.bold || seg.italic) {
                const rPr = xmlDoc.createElementNS(WORD_NS, "w:rPr");
                if (seg.bold) {
                    const b = xmlDoc.createElementNS(WORD_NS, "w:b");
                    rPr.appendChild(b);
                }
                if (seg.italic) {
                    const i = xmlDoc.createElementNS(WORD_NS, "w:i");
                    rPr.appendChild(i);
                }
                run.appendChild(rPr);
            }

            const t = xmlDoc.createElementNS(WORD_NS, "w:t");
            t.setAttribute("xml:space", "preserve");
            t.textContent = seg.text;
            run.appendChild(t);

            runs.push(run);
        }

        return runs;
    }

    async function insertBlocks(
        context: Word.RequestContext, 
        blocks: any[], 
        styleCache: Map<string, StyleToken>, 
        insertLocation: Word.Paragraph, 
        analysis?: any,
        listInfo?: { numId: string; ilvl: string } | null
    ): Promise<number> {
        log("[insertBlocks] Starting with " + blocks.length + " blocks, listInfo:", listInfo);

        let lastInsert = insertLocation;
        let insertedCount = 0;

        const parser = new DOMParser();
        const serializer = new XMLSerializer();
        const WORD_NS = "http://schemas.openxmlformats.org/wordprocessingml/2006/main";

        context.trackedObjects.add(lastInsert);
        
        const insertLocationOxmlResult = insertLocation.getOoxml();
        await context.sync();
        
        let docRFonts: Node | null = null;
        let docSz: Node | null = null;
        let docSzCs: Node | null = null;
        
        try {
            const locationXml = parser.parseFromString(insertLocationOxmlResult.value, "text/xml");
            const locationRuns = locationXml.getElementsByTagNameNS(WORD_NS, "r");
            if (locationRuns.length > 0) {
                const firstRun = locationRuns[0] as Element;
                const rPr = firstRun.getElementsByTagNameNS(WORD_NS, "rPr")[0];
                if (rPr) {
                    docRFonts = rPr.getElementsByTagNameNS(WORD_NS, "rFonts")[0] || null;
                    docSz = rPr.getElementsByTagNameNS(WORD_NS, "sz")[0] || null;
                    docSzCs = rPr.getElementsByTagNameNS(WORD_NS, "szCs")[0] || null;
                    if (docRFonts) {
                    }
                }
            }
        } catch (e) {
            logWarn(" Could not extract font from insertion location:", e);
        }

        const insertedParagraphs: Word.Paragraph[] = [];
        const blockMetadata: { styleToken: string, content: string, originalContent: string }[] = [];

        for (const block of blocks) {
            const styleToken = block.styleId;
            const content = block.content;

            if (!content) continue;

            const tokenData = styleCache.get(styleToken);
            const targetStyleName = tokenData ? tokenData.styleName : "Normal";
            const cleanContent = stripMarkdownFormatting(content);

            const newP = lastInsert.insertParagraph(cleanContent, "After");
            newP.style = targetStyleName;

            context.trackedObjects.add(newP);
            insertedParagraphs.push(newP);
            blockMetadata.push({ styleToken, content: cleanContent, originalContent: content });

            lastInsert = newP;
            insertedCount++;
        }

        await context.sync();

        const oxmlResults: OfficeExtension.ClientResult<string>[] = [];
        for (const p of insertedParagraphs) {
            oxmlResults.push(p.getOoxml());
        }

        await context.sync();

        for (let i = 0; i < insertedParagraphs.length; i++) {
            const p = insertedParagraphs[i];
            const originalOxml = oxmlResults[i].value;
            const meta = blockMetadata[i];

            try {
                const insId = Math.floor(Math.random() * 10000000).toString();
                const date = new Date().toISOString();

                const xmlDoc = parser.parseFromString(originalOxml, "text/xml");
                const pNode = xmlDoc.getElementsByTagNameNS(WORD_NS, "p")[0] || xmlDoc.getElementsByTagName("w:p")[0];

                if (pNode) {
                    let pPr = pNode.getElementsByTagNameNS(WORD_NS, "pPr")[0] || pNode.getElementsByTagName("w:pPr")[0];

                    if (!pPr && meta.styleToken) {
                        const tokenData = styleCache.get(meta.styleToken);
                        if (tokenData && tokenData.styleId !== "Normal") {
                            pPr = xmlDoc.createElementNS(WORD_NS, "w:pPr");
                            const pStyle = xmlDoc.createElementNS(WORD_NS, "w:pStyle");
                            pStyle.setAttribute("w:val", tokenData.styleId);
                            pPr.appendChild(pStyle);

                            if (pNode.firstChild) {
                                pNode.insertBefore(pPr, pNode.firstChild);
                            } else {
                                pNode.appendChild(pPr);
                            }
                        }
                    }

                    if (pPr) {
                        const pPr_rPr = pPr.getElementsByTagNameNS(WORD_NS, "rPr")[0] || pPr.getElementsByTagName("w:rPr")[0];
                        if (pPr_rPr) {
                            const rFonts = pPr_rPr.getElementsByTagNameNS(WORD_NS, "rFonts")[0] || pPr_rPr.getElementsByTagName("w:rFonts")[0];
                            if (rFonts) {
                                pPr_rPr.removeChild(rFonts);
                            }
                        }
                    }


                    const existingRuns = Array.from(pNode.childNodes).filter(n => 
                        n.localName === "r" || n.nodeName.endsWith(":r")
                    );
                    existingRuns.forEach(run => pNode.removeChild(run));

                    const segments = parseMarkdownToSegments(meta.originalContent);
                    const formattedRuns = createFormattedRuns(xmlDoc, segments, WORD_NS);

                    if (docRFonts || docSz) {
                        formattedRuns.forEach(run => {
                            let rPr = run.getElementsByTagNameNS(WORD_NS, "rPr")[0] as Element;
                            if (!rPr) {
                                rPr = xmlDoc.createElementNS(WORD_NS, "w:rPr");
                                run.insertBefore(rPr, run.firstChild);
                            }
                            if (docRFonts && !rPr.getElementsByTagNameNS(WORD_NS, "rFonts")[0]) {
                                rPr.insertBefore(docRFonts.cloneNode(true), rPr.firstChild);
                            }
                            if (docSz && !rPr.getElementsByTagNameNS(WORD_NS, "sz")[0]) {
                                rPr.appendChild(docSz.cloneNode(true));
                            }
                            if (docSzCs && !rPr.getElementsByTagNameNS(WORD_NS, "szCs")[0]) {
                                rPr.appendChild(docSzCs.cloneNode(true));
                            }
                        });
                    }

                    const isFirstBlock = (i === 0);
                    const shouldForceBold = isFirstBlock && analysis?.clauseStyle?.isBold && !meta.originalContent.includes('**');

                    if (shouldForceBold) {
                        formattedRuns.forEach(run => {
                            let rPr = run.getElementsByTagNameNS(WORD_NS, "rPr")[0] as Element;
                            if (!rPr) {
                                rPr = xmlDoc.createElementNS(WORD_NS, "w:rPr");
                                run.insertBefore(rPr, run.firstChild);
                            }
                            if (!rPr.getElementsByTagNameNS(WORD_NS, "b")[0]) {
                                const b = xmlDoc.createElementNS(WORD_NS, "w:b");
                                rPr.appendChild(b);
                            }
                        });
                    }

                    const insNode = xmlDoc.createElementNS(WORD_NS, "w:ins");
                    insNode.setAttribute("w:id", insId);
                    insNode.setAttribute("w:author", getTrackChangeAuthor());
                    insNode.setAttribute("w:date", date);

                    formattedRuns.forEach(run => insNode.appendChild(run));
                    pNode.appendChild(insNode);

                }

                const body = xmlDoc.getElementsByTagNameNS(WORD_NS, "body")[0] || xmlDoc.getElementsByTagName("w:body")[0];
                if (body) {
                    const sectPr = body.getElementsByTagNameNS(WORD_NS, "sectPr")[0] || body.getElementsByTagName("w:sectPr")[0];
                    if (sectPr) body.removeChild(sectPr);
                }

                let finalOxml = serializer.serializeToString(xmlDoc);
                
                // NEW: Inject numPr if inserting into a numbered list
                if (listInfo) {
                    finalOxml = injectNumPrIntoOxml(finalOxml, listInfo.numId, listInfo.ilvl);
                }
                
                p.insertOoxml(finalOxml, "Replace");

            } catch (e) {
                console.error(`[Vibe] Redline Error for ${meta.styleToken}:`, e);
            }
        }

        await context.sync();

        for (const p of insertedParagraphs) {
            context.trackedObjects.remove(p);
        }
        context.trackedObjects.remove(insertLocation);

        await context.sync();
        
        log("[insertBlocks] Completed: " + insertedCount + " paragraphs inserted");
        return insertedCount;
    }

    // ==========================================
    // UI COMPONENTS (React)
    // ==========================================

    const fontStack = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif';

    const Header = ({ onSettingsClick, onRefreshContext, onHelpClick, cacheStatus, focusedSelection, processingStage, provider, currentModel }) => {
        const [refreshHover, setRefreshHover] = React.useState(false);
        const [settingsHover, setSettingsHover] = React.useState(false);
        const [helpHover, setHelpHover] = React.useState(false);

        return React.createElement("div", { 
            style: { 
                display: "flex",
                flexDirection: "column",
                position: "sticky",
                top: 0,
                zIndex: 10
            } 
        },
            // Main header
            React.createElement("div", { 
                style: { 
                    background: "rgba(255,255,255,0.8)",
                    backdropFilter: "blur(24px)",
                    borderBottom: "1px solid rgba(228,228,231,0.6)",
                    padding: "16px 20px",
                    boxShadow: "0 1px 3px rgba(0,0,0,0.05)"
                } 
            },
                // Top row: Title + Actions
                React.createElement("div", { 
                    style: { 
                        display: "flex", 
                        justifyContent: "space-between", 
                        alignItems: "center",
                        marginBottom: "12px"
                    } 
                },
                    // Title only (no icon - Point 1)
                    React.createElement("h1", { 
                        style: { 
                            margin: 0, 
                            fontSize: "18px", 
                            fontWeight: "700",
                            color: "#18181b",
                            letterSpacing: "-0.025em"
                        } 
                    }, "Vibe Legal"),
                    // Action buttons
                    React.createElement("div", { style: { display: "flex", gap: "8px" } },
                        // Refresh button
                        React.createElement("button", { 
                            onClick: onRefreshContext,
                            onMouseOver: () => setRefreshHover(true),
                            onMouseOut: () => setRefreshHover(false),
                            style: { 
                                padding: "10px",
                                background: refreshHover ? "#f4f4f5" : "transparent",
                                border: "none",
                                borderRadius: "12px",
                                cursor: "pointer",
                                transition: "all 0.3s",
                                transform: refreshHover ? "scale(1.1)" : "scale(1)"
                            },
                            title: "Refresh Context"
                        }, React.createElement("span", { 
                            style: { 
                                display: "inline-block",
                                fontSize: "16px",
                                color: "#27272a",
                                transition: "transform 0.5s",
                                transform: refreshHover ? "rotate(180deg)" : "rotate(0deg)"
                            } 
                        }, "↻")),
                        // Help button (Point 6)
                        React.createElement("button", { 
                            onClick: onHelpClick,
                            onMouseOver: () => setHelpHover(true),
                            onMouseOut: () => setHelpHover(false),
                            style: { 
                                padding: "10px",
                                background: helpHover ? "#f4f4f5" : "transparent",
                                border: "none",
                                borderRadius: "12px",
                                cursor: "pointer",
                                transition: "all 0.3s",
                                transform: helpHover ? "scale(1.1)" : "scale(1)"
                            },
                            title: "Help & Guide"
                        }, React.createElement("span", { 
                            style: { 
                                fontSize: "16px",
                                color: "#27272a",
                                fontWeight: "600"
                            } 
                        }, "?")),
                        // Settings button (Point 2 - monochrome)
                        React.createElement("button", { 
                            onClick: onSettingsClick,
                            onMouseOver: () => setSettingsHover(true),
                            onMouseOut: () => setSettingsHover(false),
                            style: { 
                                padding: "10px",
                                background: settingsHover ? "#f4f4f5" : "transparent",
                                border: "none",
                                borderRadius: "12px",
                                cursor: "pointer",
                                transition: "all 0.3s",
                                transform: settingsHover ? "scale(1.1)" : "scale(1)"
                            },
                            title: "Settings"
                        }, React.createElement("span", { 
                            style: { 
                                display: "inline-block",
                                fontSize: "16px",
                                color: "#27272a",
                                transition: "transform 0.3s",
                                transform: settingsHover ? "rotate(90deg)" : "rotate(0deg)"
                            } 
                        }, "⚙"))
                    )
                ),
                // Status badges row
                React.createElement("div", { style: { display: "flex", gap: "10px" } },
                    // Model badge
                    React.createElement("span", { 
                        style: { 
                            display: "inline-flex",
                            alignItems: "center",
                            padding: "6px 12px",
                            fontSize: "11px",
                            fontWeight: "600",
                            background: "linear-gradient(to right, #fff, #fafafa)",
                            color: "#3f3f46",
                            border: "1px solid rgba(228,228,231,0.8)",
                            borderRadius: "9999px",
                            boxShadow: "0 1px 2px rgba(0,0,0,0.05)"
                        } 
                    }, currentModel || (provider === "claude" ? "Claude" : "Gemini 2.0 Flash")),
                    // Context status badge
                    cacheStatus === "loaded" && React.createElement("span", { 
                        style: { 
                            display: "inline-flex",
                            alignItems: "center",
                            padding: "6px 12px",
                            fontSize: "11px",
                            fontWeight: "600",
                            background: "linear-gradient(to right, #f5f5f5, #fafafa)",
                            color: "#3f3f46",
                            border: "1px solid rgba(212,212,216,0.8)",
                            borderRadius: "9999px",
                            boxShadow: "0 1px 2px rgba(0,0,0,0.05)"
                        } 
                    },
                        React.createElement("span", { 
                            style: { 
                                width: "6px",
                                height: "6px",
                                background: "#10b981",
                                borderRadius: "50%",
                                marginRight: "8px",
                                animation: "pulse-glow 2s ease-in-out infinite"
                            } 
                        }),
                        "Context Active"
                    )
                )
            ),
            
            // Focus indicator (when text selected)
            focusedSelection && React.createElement("div", { 
                style: { 
                    background: "linear-gradient(to right, #f4f4f5, #fafafa, #f4f4f5)",
                    borderBottom: "1px solid rgba(228,228,231,0.6)",
                    padding: "12px 20px",
                    animation: "slideDown 0.4s ease-out",
                    position: "relative",
                    overflow: "hidden"
                } 
            },
                // Shimmer effect overlay
                React.createElement("div", { 
                    style: { 
                        position: "absolute",
                        inset: 0,
                        background: "linear-gradient(to right, transparent, rgba(255,255,255,0.6), transparent)",
                        animation: "shimmer 3s ease-in-out infinite"
                    } 
                }),
                React.createElement("div", { style: { display: "flex", alignItems: "center", gap: "12px", position: "relative" } },
                    // Icon container
                    React.createElement("div", { 
                        style: { 
                            padding: "6px",
                            background: "rgba(255,255,255,0.9)",
                            borderRadius: "8px",
                            boxShadow: "0 1px 2px rgba(0,0,0,0.05)"
                        } 
                    }, React.createElement("span", { style: { fontSize: "14px" } }, "✨")),
                    // Text content
                    React.createElement("div", { style: { flex: 1 } },
                        React.createElement("p", { 
                            style: { 
                                fontSize: "11px", 
                                fontWeight: "600", 
                                color: "#52525b", 
                                textTransform: "uppercase", 
                                letterSpacing: "0.05em",
                                margin: "0 0 2px 0"
                            } 
                        }, "AI Focusing"),
                        React.createElement("p", { 
                            style: { 
                                fontSize: "12px", 
                                fontWeight: "500", 
                                color: "#27272a",
                                margin: 0,
                                overflow: "hidden",
                                textOverflow: "ellipsis",
                                whiteSpace: "nowrap"
                            } 
                        }, 
                            "Analyzing ",
                            React.createElement("strong", null, "'" + (focusedSelection.length > 30 ? focusedSelection.substring(0, 30) + "..." : focusedSelection) + "'")
                        )
                    )
                )
            ),
            
            // Processing stage indicator
            processingStage && React.createElement("div", { 
                style: { 
                    padding: "10px 20px", 
                    background: "#fff7ed", 
                    fontSize: "12px", 
                    color: "#c2410c", 
                    borderBottom: "1px solid #fed7aa" 
                } 
            }, processingStage)
        );
    };

    // ENHANCEMENT 2A: Settings with Provider Dropdown
    const Settings = ({ 
        provider, setProvider,
        geminiApiKey, setGeminiApiKey,
        claudeApiKey, setClaudeApiKey,
        geminiModel, setGeminiModel,
        claudeModel, setClaudeModel,
        authorMode, setAuthorMode, 
        customAuthor, setCustomAuthor, 
        detectedAuthor, onBack 
    }) => {
        const [status, setStatus] = React.useState("");
        const [models, setModels] = React.useState([]);

        const currentApiKey = provider === "gemini" ? geminiApiKey : claudeApiKey;
        const currentModel = provider === "gemini" ? geminiModel : claudeModel;

        React.useEffect(() => { 
            if (currentApiKey) handleSync(); 
        }, [provider]);

        const handleSync = async () => {
            setStatus("Loading...");
            try {
                let list;
                if (provider === "gemini") {
                    list = await fetchModelsFromGoogle(geminiApiKey);
                } else {
                    list = await fetchModelsFromAnthropic(claudeApiKey);
                }
                setModels(list);
                setStatus(list.length + " models found");
                
                const modelId = provider === "gemini" ? geminiModel : claudeModel;
                const currentExists = list.find((m) => {
                    const mName = m.name?.replace("models/", "") || m.name;
                    return mName === modelId;
                });
                if (!currentExists && list.length > 0) {
                    const newModel = list[0].name?.replace("models/", "") || list[0].name;
                    if (provider === "gemini") {
                        setGeminiModel(newModel);
                    } else {
                        setClaudeModel(newModel);
                    }
                }
            } catch (e) {
                setStatus("Error: Check Key");
                setModels([]);
            }
        };

        const handleProviderChange = (newProvider) => {
            setProvider(newProvider);
            setModels([]);
            setStatus("Click Refresh to load models");
        };

        const handleDone = () => {
            localStorage.setItem("vibe_provider", provider);
            localStorage.setItem("vibe_api_key_gemini", geminiApiKey);
            localStorage.setItem("vibe_api_key_claude", claudeApiKey);
            localStorage.setItem("vibe_model_gemini", geminiModel);
            localStorage.setItem("vibe_model_claude", claudeModel);
            localStorage.setItem("vibe_author_mode", authorMode);
            localStorage.setItem("vibe_custom_author", customAuthor);
            
            providerConfig.provider = provider;
            providerConfig.geminiApiKey = geminiApiKey;
            providerConfig.claudeApiKey = claudeApiKey;
            providerConfig.geminiModel = geminiModel;
            providerConfig.claudeModel = claudeModel;
            
            authorSettings.mode = authorMode;
            authorSettings.customName = customAuthor;
            onBack();
        };

        // Modern Styles
        const sectionLabelStyle = {
            fontSize: "11px",
            fontWeight: "500",
            color: "#475569",
            textTransform: "uppercase",
            letterSpacing: "0.05em",
            marginBottom: "8px"
        };
        
        const inputStyle = {
            width: "100%",
            padding: "10px 16px",
            fontSize: "13px",
            color: "#1e293b",
            background: "#ffffff",
            border: "1px solid #e4e4e7",
            borderRadius: "12px",
            outline: "none",
            boxShadow: "0 1px 2px rgba(0,0,0,0.05)",
            boxSizing: "border-box"
        };
        
        const selectStyle = {
            ...inputStyle,
            appearance: "none",
            cursor: "pointer"
        };
        
        const providerButtonStyle = (isActive) => ({
            flex: 1,
            padding: "10px 12px",
            fontSize: "12px",
            fontWeight: "500",
            border: "none",
            cursor: "pointer",
            transition: "all 0.2s",
            background: isActive ? "linear-gradient(to bottom right, #1e293b, #0f172a)" : "#ffffff",
            color: isActive ? "#ffffff" : "#3f3f46"
        });
        
        const cardStyle = {
            border: "1px solid #e4e4e7",
            borderRadius: "12px",
            padding: "16px",
            background: "#ffffff",
            boxShadow: "0 1px 2px rgba(0,0,0,0.05)"
        };

        return React.createElement("div", { 
            style: { 
                display: "flex", 
                flexDirection: "column", 
                height: "100%", 
                background: "linear-gradient(to bottom, #ffffff, #fafafa)" 
            } 
        },
            // Header
            React.createElement("div", { 
                style: { 
                    padding: "14px 16px", 
                    borderBottom: "1px solid #e4e4e7",
                    background: "rgba(255,255,255,0.95)",
                    backdropFilter: "blur(8px)",
                    display: "flex",
                    alignItems: "center",
                    gap: "12px"
                } 
            },
                React.createElement("button", { 
                    onClick: onBack,
                    style: { 
                        padding: "8px", 
                        background: "none", 
                        border: "none", 
                        cursor: "pointer",
                        borderRadius: "8px",
                        fontSize: "16px",
                        color: "#475569"
                    }
                }, "←"),
                React.createElement("h1", { 
                    style: { 
                        margin: 0, 
                        fontSize: "16px", 
                        fontWeight: "600", 
                        color: "#0f172a" 
                    } 
                }, "Configuration")
            ),
            
            // Scrollable content
            React.createElement("div", { 
                style: { 
                    flex: 1, 
                    overflowY: "auto", 
                    padding: "20px 16px" 
                } 
            },
                // Provider Display (Point 5 - Claude hidden from UI but code preserved)
                React.createElement("div", { style: { marginBottom: "24px" } },
                    React.createElement("label", { style: sectionLabelStyle }, "AI Provider"),
                    React.createElement("div", { 
                        style: { 
                            padding: "14px 16px",
                            fontSize: "13px",
                            fontWeight: "600",
                            background: "linear-gradient(to bottom right, #27272a, #171717, #000)",
                            color: "#fff",
                            borderRadius: "16px",
                            boxShadow: "0 4px 12px rgba(0,0,0,0.1)",
                            textAlign: "center"
                        } 
                    }, "Google Gemini")
                ),
                
                // API Key
                React.createElement("div", { style: { marginBottom: "24px" } },
                    React.createElement("label", { style: sectionLabelStyle }, "API Key"),
                    React.createElement("input", { 
                        type: "password",
                        value: currentApiKey,
                        onChange: (e) => provider === "gemini" ? setGeminiApiKey(e.target.value) : setClaudeApiKey(e.target.value),
                        placeholder: "Enter your API key",
                        style: inputStyle
                    })
                ),
                
                // Model Selector
                React.createElement("div", { style: { marginBottom: "24px" } },
                    React.createElement("label", { style: sectionLabelStyle }, "Model"),
                    React.createElement("div", { style: { display: "flex", gap: "8px" } },
                        React.createElement("select", { 
                            value: currentModel,
                            onChange: (e) => provider === "gemini" ? setGeminiModel(e.target.value) : setClaudeModel(e.target.value),
                            style: { ...selectStyle, flex: 1 }
                        },
                            models.length > 0
                                ? models.map((m) => React.createElement("option", { key: m.name, value: m.name.replace("models/", "") }, m.displayName || m.name))
                                : React.createElement("option", { value: currentModel }, currentModel || "Default")
                        ),
                        React.createElement("button", { 
                            onClick: handleSync,
                            style: { 
                                padding: "10px 14px", 
                                background: "#ffffff",
                                border: "1px solid #e4e4e7",
                                borderRadius: "12px",
                                cursor: "pointer",
                                boxShadow: "0 1px 2px rgba(0,0,0,0.05)",
                                fontSize: "14px"
                            }
                        }, "↻")
                    ),
                    React.createElement("p", { style: { fontSize: "10px", color: "#71717a", marginTop: "8px", margin: "8px 0 0 0" } }, status || "Click refresh to load models")
                ),
                
                // Track Changes Identity
                React.createElement("div", { style: { marginBottom: "24px" } },
                    React.createElement("label", { style: sectionLabelStyle }, "Track Changes Identity"),
                    React.createElement("select", { 
                        value: authorMode,
                        onChange: (e) => setAuthorMode(e.target.value),
                        style: selectStyle
                    },
                        React.createElement("option", { value: "auto" }, detectedAuthor ? "Use my name (" + detectedAuthor + ")" : "Auto-Detect"),
                        React.createElement("option", { value: "vibe" }, "Vibe AI"),
                        React.createElement("option", { value: "custom" }, "Custom Name")
                    ),
                    authorMode === "custom" && React.createElement("input", {
                        type: "text",
                        value: customAuthor,
                        onChange: (e) => setCustomAuthor(e.target.value),
                        placeholder: "Enter custom name",
                        style: { ...inputStyle, marginTop: "8px" }
                    })
                ),
                
                // Cache Management (Point 9)
                React.createElement("div", { style: { marginBottom: "24px" } },
                    React.createElement("label", { style: sectionLabelStyle }, "Context Cache Manager"),
                    React.createElement("div", { style: cardStyle },
                        // Note about when caching applies (Point 9)
                        React.createElement("div", { 
                            style: { 
                                background: "#fafafa",
                                borderRadius: "10px",
                                padding: "10px 12px",
                                marginBottom: "14px",
                                border: "1px solid #e4e4e7"
                            } 
                        },
                            React.createElement("p", { 
                                style: { 
                                    fontSize: "11px", 
                                    color: "#52525b", 
                                    margin: 0,
                                    lineHeight: "1.5"
                                } 
                            }, 
                                React.createElement("strong", { style: { color: "#27272a" } }, "Note: "),
                                "Context caching is used for documents longer than ~20 pages. Shorter documents are processed directly."
                            )
                        ),
                        React.createElement("div", { style: { display: "flex", gap: "8px", marginBottom: "12px" } },
                            React.createElement("button", { 
                                onClick: async () => {
                                    try {
                                        setStatus("Refreshing cache...");
                                        cacheState = { cacheId: null, createdAt: null, changelog: cacheState.changelog };
                                        contractMapState.totalParagraphCount = null;
                                        setStatus("Cache will refresh on next request");
                                        log(" Cache set to refresh");
                                    } catch (e) {
                                        setStatus("Error: " + e.message);
                                    }
                                },
                                style: { 
                                    flex: 1, 
                                    padding: "10px", 
                                    fontSize: "12px",
                                    fontWeight: "500",
                                    background: "linear-gradient(to bottom right, #1e293b, #0f172a)",
                                    color: "#ffffff",
                                    border: "none",
                                    borderRadius: "8px",
                                    cursor: "pointer",
                                    boxShadow: "0 1px 2px rgba(0,0,0,0.1)"
                                }
                            }, "Force Refresh"),
                            React.createElement("button", { 
                                onClick: async () => {
                                    try {
                                        setStatus("Clearing cache...");
                                        cacheState = { cacheId: null, createdAt: null, changelog: [] };
                                        contractMapState = { map: null, documentHash: null, totalParagraphCount: null };
                                        deltaManager.operations = [];
                                        setStatus("Cache cleared");
                                        log(" Cache cleared manually");
                                    } catch (e) {
                                        setStatus("Error: " + e.message);
                                    }
                                },
                                style: { 
                                    flex: 1, 
                                    padding: "10px", 
                                    fontSize: "12px",
                                    fontWeight: "500",
                                    background: "#ffffff",
                                    color: "#3f3f46",
                                    border: "1px solid #d4d4d8",
                                    borderRadius: "8px",
                                    cursor: "pointer",
                                    boxShadow: "0 1px 2px rgba(0,0,0,0.05)"
                                }
                            }, "Clear Cache")
                        ),
                        React.createElement("p", { style: { fontSize: "10px", color: "#71717a", margin: 0 } }, 
                            React.createElement("strong", { style: { color: "#27272a" } }, "Refresh"),
                            " updates knowledge. ",
                            React.createElement("strong", { style: { color: "#dc2626" } }, "Clear"),
                            " resets memory."
                        )
                    )
                )
            ),
            
            // Done Button (sticky footer)
            React.createElement("div", { 
                style: { 
                    padding: "16px", 
                    borderTop: "1px solid #e4e4e7" 
                } 
            },
                React.createElement("button", { 
                    onClick: handleDone,
                    style: { 
                        width: "100%",
                        padding: "14px",
                        fontSize: "13px",
                        fontWeight: "500",
                        background: "linear-gradient(to bottom right, #1e293b, #0f172a)",
                        color: "#ffffff",
                        border: "none",
                        borderRadius: "12px",
                        cursor: "pointer",
                        boxShadow: "0 4px 12px rgba(0,0,0,0.15)"
                    }
                }, "Done")
            )
        );
    };

    // ChatMessage component with hover effect
    const ChatMessage = ({ role, content }) => {
        const isUser = role === "user";
        const [isHovered, setIsHovered] = React.useState(false);
        
        const baseStyle = {
            maxWidth: "85%",
            padding: "12px 16px",
            fontSize: "13px",
            lineHeight: "1.6",
            borderRadius: "16px",
            transition: "all 0.3s",
            animation: "scaleIn 0.3s ease-out"
        };
        
        const userStyle = {
            ...baseStyle,
            marginLeft: "auto",
            background: "linear-gradient(to bottom right, #27272a, #171717, #000)",
            color: "#ffffff",
            boxShadow: isHovered 
                ? "0 20px 25px -5px rgba(113,113,122,0.3)" 
                : "0 10px 15px -3px rgba(113,113,122,0.2)",
            transform: isHovered ? "scale(1.02)" : "scale(1)"
        };
        
        const botStyle = {
            ...baseStyle,
            marginRight: "auto",
            background: "linear-gradient(to bottom right, #fff, #fff, #fafafa)",
            color: "#1e293b",
            border: "1px solid rgba(228,228,231,0.6)",
            boxShadow: isHovered 
                ? "0 10px 15px -3px rgba(0,0,0,0.1)" 
                : "0 4px 6px -1px rgba(0,0,0,0.05)",
            transform: isHovered ? "scale(1.01)" : "scale(1)"
        };

        return React.createElement("div", { 
            style: { alignSelf: isUser ? "flex-end" : "flex-start", maxWidth: "85%" },
            onMouseOver: () => setIsHovered(true),
            onMouseOut: () => setIsHovered(false)
        },
            React.createElement("div", { 
                style: isUser ? userStyle : botStyle,
                dangerouslySetInnerHTML: { __html: renderMarkdown(content) }
            })
        );
    };

    // Loading dots animation
    const LoadingDots = () => React.createElement("div", { 
        style: { display: "flex", alignItems: "center", gap: "6px", padding: "4px 0" } 
    },
        [0, 1, 2].map(i => React.createElement("div", { 
            key: i,
            style: { 
                width: "8px", 
                height: "8px", 
                background: "#71717a",
                borderRadius: "50%",
                animation: "bounce 1.4s ease-in-out " + (i * 0.2) + "s infinite",
                boxShadow: "0 1px 2px rgba(0,0,0,0.1)"
            } 
        }))
    );

    const Chat = ({ messages, isLoading }) => {
        const bottomRef = React.useRef(null);
        React.useEffect(() => { 
            bottomRef.current?.scrollIntoView({ behavior: "smooth" }); 
        }, [messages]);
        
        return React.createElement("div", { 
            style: { 
                flexGrow: 1, 
                overflowY: "auto", 
                padding: "24px 20px", 
                display: "flex", 
                flexDirection: "column", 
                gap: "16px",
                background: "linear-gradient(to bottom right, #fafafa, #fff, #f5f5f5)",
                position: "relative"
            } 
        },
            // Subtle radial background
            React.createElement("div", { 
                style: { 
                    position: "absolute",
                    inset: 0,
                    background: "radial-gradient(circle at 30% 20%, rgba(64,64,64,0.04), transparent 50%), radial-gradient(circle at 70% 80%, rgba(38,38,38,0.03), transparent 50%)",
                    pointerEvents: "none"
                } 
            }),
            messages.map((msg, i) => React.createElement(ChatMessage, { key: i, role: msg.role, content: msg.content })),
            isLoading && React.createElement("div", { 
                style: { 
                    maxWidth: "85%",
                    marginRight: "auto",
                    padding: "12px 16px",
                    background: "linear-gradient(to bottom right, #fff, #fff, #fafafa)",
                    border: "1px solid rgba(228,228,231,0.6)",
                    borderRadius: "16px",
                    boxShadow: "0 4px 6px -1px rgba(0,0,0,0.05)",
                    animation: "scaleIn 0.3s ease-out"
                } 
            }, React.createElement(LoadingDots)),
            React.createElement("div", { ref: bottomRef })
        );
    };

    const InputArea = ({ value, onChange, onSend, disabled, currentModel, provider }) => {
        const [isFocused, setIsFocused] = React.useState(false);
        const [buttonHover, setButtonHover] = React.useState(false);

        return React.createElement("div", { 
            style: { 
                padding: "20px",
                background: "linear-gradient(to top, #fff, #fff, transparent)",
                position: "relative"
            } 
        },
            // Input container
            React.createElement("div", { 
                style: { 
                    display: "flex",
                    alignItems: "center",
                    gap: "12px",
                    background: "#fff",
                    border: isFocused ? "2px solid rgba(161,161,170,0.6)" : "2px solid rgba(228,228,231,0.8)",
                    borderRadius: "16px",
                    padding: "14px 16px",
                    boxShadow: isFocused 
                        ? "0 20px 50px -12px rgba(0,0,0,0.18)" 
                        : "0 10px 40px -12px rgba(0,0,0,0.12)",
                    transition: "all 0.3s"
                } 
            },
                // Text input
                React.createElement("input", {
                    value: value,
                    onChange: (e) => onChange(e.target.value),
                    onKeyDown: (e) => { if (e.key === "Enter" && !disabled) onSend(); },
                    onFocus: () => setIsFocused(true),
                    onBlur: () => setIsFocused(false),
                    placeholder: "Ask about this document...",
                    disabled: disabled,
                    style: { 
                        flex: 1,
                        fontSize: "14px",
                        color: "#1e293b",
                        background: "transparent",
                        border: "none",
                        outline: "none"
                    }
                }),
                // Send button with SVG arrow (Point 3)
                React.createElement("button", {
                    onClick: onSend,
                    disabled: disabled,
                    onMouseOver: () => setButtonHover(true),
                    onMouseOut: () => setButtonHover(false),
                    style: { 
                        padding: "10px 12px",
                        background: disabled 
                            ? "#e4e4e7" 
                            : "linear-gradient(to bottom right, #27272a, #171717, #000)",
                        border: "none",
                        borderRadius: "12px",
                        cursor: disabled ? "default" : "pointer",
                        transition: "all 0.3s",
                        transform: buttonHover && !disabled ? "scale(1.1)" : "scale(1)",
                        boxShadow: disabled 
                            ? "none" 
                            : buttonHover 
                                ? "0 10px 20px -5px rgba(113,113,122,0.4)"
                                : "0 4px 12px rgba(113,113,122,0.3)",
                        display: "flex",
                        alignItems: "center",
                        justifyContent: "center"
                    }
                }, 
                    React.createElement("svg", {
                        width: "18",
                        height: "18",
                        viewBox: "0 0 24 24",
                        fill: "none",
                        stroke: "#ffffff",
                        strokeWidth: "2.5",
                        strokeLinecap: "round",
                        strokeLinejoin: "round"
                    },
                        React.createElement("line", { x1: "5", y1: "12", x2: "19", y2: "12" }),
                        React.createElement("polyline", { points: "12 5 19 12 12 19" })
                    )
                )
            ),
            // Legal disclaimer footer
            React.createElement("p", { 
                style: { 
                    fontSize: "10px", 
                    color: "#71717a", 
                    textAlign: "center", 
                    marginTop: "10px",
                    lineHeight: "1.4"
                } 
            }, "Not legal advice. AI can make mistakes. Please verify changes.")
        );
    };

    // ==========================================
    // HELP GUIDE MODAL (Point 6)
    // ==========================================

    const HelpGuide = ({ onClose }) => {
        const sectionTitleStyle = {
            fontSize: "13px", 
            fontWeight: "700", 
            color: "#18181b",
            marginBottom: "8px",
            letterSpacing: "-0.01em"
        };
        
        const sectionStyle = {
            marginBottom: "20px",
            paddingBottom: "20px",
            borderBottom: "1px solid #f4f4f5"
        };
        
        const lastSectionStyle = {
            marginBottom: "0"
        };

        return React.createElement("div", { 
            style: { 
                position: "fixed",
                inset: 0,
                background: "rgba(0,0,0,0.5)",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                zIndex: 100,
                animation: "fadeIn 0.2s ease-out"
            },
            onClick: onClose
        },
            React.createElement("div", { 
                style: { 
                    background: "#fff",
                    borderRadius: "20px",
                    padding: "24px",
                    maxWidth: "320px",
                    maxHeight: "80vh",
                    overflowY: "auto",
                    boxShadow: "0 25px 50px -12px rgba(0,0,0,0.25)",
                    animation: "scaleIn 0.3s ease-out"
                },
                onClick: (e) => e.stopPropagation()
            },
                // Header
                React.createElement("div", { 
                    style: { 
                        display: "flex", 
                        justifyContent: "space-between", 
                        alignItems: "center",
                        marginBottom: "24px",
                        paddingBottom: "16px",
                        borderBottom: "1px solid #e4e4e7"
                    } 
                },
                    React.createElement("h2", { 
                        style: { 
                            margin: 0, 
                            fontSize: "18px", 
                            fontWeight: "700",
                            color: "#18181b"
                        } 
                    }, "How to Use Vibe Legal"),
                    React.createElement("button", { 
                        onClick: onClose,
                        style: { 
                            background: "#f4f4f5",
                            border: "none",
                            fontSize: "14px",
                            cursor: "pointer",
                            color: "#71717a",
                            padding: "6px 10px",
                            borderRadius: "6px",
                            fontWeight: "500"
                        }
                    }, "Close")
                ),
                
                // Guide content
                React.createElement("div", { style: { fontSize: "13px", color: "#3f3f46", lineHeight: "1.6" } },
                    // Section 1: Basic Commands
                    React.createElement("div", { style: sectionStyle },
                        React.createElement("h3", { style: sectionTitleStyle }, "Basic Commands"),
                        React.createElement("ul", { style: { margin: 0, paddingLeft: "18px", color: "#52525b" } },
                            React.createElement("li", { style: { marginBottom: "6px" } }, "Ask to review or analyze specific clauses"),
                            React.createElement("li", { style: { marginBottom: "6px" } }, "Request changes: \"Make this more buyer-friendly\""),
                            React.createElement("li", { style: { marginBottom: "6px" } }, "Add new clauses: \"Add a governing law clause\""),
                            React.createElement("li", { style: { marginBottom: "0" } }, "Note: \"Delete this\" is not supported (use Word's native delete)")
                        )
                    ),
                    
                    // Section 2: Focus Mode
                    React.createElement("div", { style: sectionStyle },
                        React.createElement("h3", { style: sectionTitleStyle }, "Focus Mode"),
                        React.createElement("p", { style: { margin: 0, color: "#52525b" } }, 
                            "Select text in your document before asking a question. The AI will focus its analysis on your selection."
                        )
                    ),
                    
                    // Section 3: Track Changes
                    React.createElement("div", { style: sectionStyle },
                        React.createElement("h3", { style: sectionTitleStyle }, "Track Changes"),
                        React.createElement("p", { style: { margin: 0, color: "#52525b" } }, 
                            "All modifications appear as Track Changes in Word. Accept or reject changes as you would normally."
                        )
                    ),
                    
                    // Section 4: Refresh Context
                    React.createElement("div", { style: sectionStyle },
                        React.createElement("h3", { style: sectionTitleStyle }, "Refresh Context"),
                        React.createElement("p", { style: { margin: 0, color: "#52525b" } }, 
                            "Click the refresh button after making manual changes to update the AI's knowledge of your document."
                        )
                    ),
                    
                    // Section 5: Tips
                    React.createElement("div", { style: lastSectionStyle },
                        React.createElement("h3", { style: sectionTitleStyle }, "Tips"),
                        React.createElement("ul", { style: { margin: 0, paddingLeft: "18px", color: "#52525b" } },
                            React.createElement("li", { style: { marginBottom: "6px" } }, "Be specific: \"Change payment terms to Net 60\""),
                            React.createElement("li", { style: { marginBottom: "6px" } }, "Reference clauses: \"Amend Section 5.2\""),
                            React.createElement("li", { style: { marginBottom: "0" } }, "Batch requests work well for multiple changes")
                        )
                    )
                ),
                
                // Close button
                React.createElement("button", { 
                    onClick: onClose,
                    style: { 
                        width: "100%",
                        marginTop: "24px",
                        padding: "14px",
                        fontSize: "13px",
                        fontWeight: "600",
                        background: "linear-gradient(to bottom right, #27272a, #171717, #000)",
                        color: "#fff",
                        border: "none",
                        borderRadius: "12px",
                        cursor: "pointer"
                    }
                }, "Got it")
            )
        );
    };

    // ==========================================
    // MAIN APP (with Provider Support)
    // ==========================================

    const App = () => {
        const [view, setView] = React.useState("main");
        const [showHelp, setShowHelp] = React.useState(false);
        
        // ENHANCEMENT 2F: Provider-specific state
        const [provider, setProvider] = React.useState<AIProvider>("gemini");
        const [geminiApiKey, setGeminiApiKey] = React.useState("");
        const [claudeApiKey, setClaudeApiKey] = React.useState("");
        const [geminiModel, setGeminiModel] = React.useState("gemini-2.0-flash-exp");
        const [claudeModel, setClaudeModel] = React.useState("claude-sonnet-4-20250514");
        
        const [messages, setMessages] = React.useState([{ role: "bot", content: "**Vibe Legal** ready. Select text and give an instruction, or ask questions about your document." }]);
        const [inputValue, setInputValue] = React.useState("");
        const [isProcessing, setIsProcessing] = React.useState(false);
        const [cacheStatus, setCacheStatus] = React.useState<"loaded" | "loading" | "direct">("direct");
        
        const [processingStage, setProcessingStage] = React.useState<string>("");
        const [focusedSelection, setFocusedSelection] = React.useState<string>("");
        
        const [authorMode, setAuthorMode] = React.useState<AuthorMode>("auto");
        const [customAuthor, setCustomAuthor] = React.useState("");
        const [detectedAuthor, setDetectedAuthor] = React.useState<string | null>(null);

        // ENHANCEMENT 2F: Load provider-specific settings
        React.useEffect(() => {
            const p = localStorage.getItem("vibe_provider") as AIProvider;
            const gKey = localStorage.getItem("vibe_api_key_gemini");
            const cKey = localStorage.getItem("vibe_api_key_claude");
            const gModel = localStorage.getItem("vibe_model_gemini");
            const cModel = localStorage.getItem("vibe_model_claude");
            const am = localStorage.getItem("vibe_author_mode") as AuthorMode;
            const ca = localStorage.getItem("vibe_custom_author");
            
            // Backwards compatibility: check old key format
            const oldKey = localStorage.getItem("vibe_api_key");
            const oldModel = localStorage.getItem("vibe_model");
            
            if (p) setProvider(p);
            if (gKey) setGeminiApiKey(gKey);
            else if (oldKey) setGeminiApiKey(oldKey);
            if (cKey) setClaudeApiKey(cKey);
            if (gModel) setGeminiModel(gModel);
            else if (oldModel) setGeminiModel(oldModel);
            if (cModel) setClaudeModel(cModel);
            if (am) {
                setAuthorMode(am);
                authorSettings.mode = am;
            }
            if (ca) {
                setCustomAuthor(ca);
                authorSettings.customName = ca;
            }
            
            // Update global config
            providerConfig.provider = p || "gemini";
            providerConfig.geminiApiKey = gKey || oldKey || "";
            providerConfig.claudeApiKey = cKey || "";
            providerConfig.geminiModel = gModel || oldModel || "gemini-2.0-flash-exp";
            providerConfig.claudeModel = cModel || "claude-sonnet-4-20250514";
        }, []);

        React.useEffect(() => {
            const checkAuthor = setInterval(() => {
                if (authorSettings.detectedAuthor !== detectedAuthor) {
                    setDetectedAuthor(authorSettings.detectedAuthor);
                }
            }, 500);
            return () => clearInterval(checkAuthor);
        }, [detectedAuthor]);

        React.useEffect(() => {
            const interval = setInterval(() => {
                setCacheStatus(getCacheStatus());
            }, 1000);
            return () => clearInterval(interval);
        }, []);

        const handleRefreshContext = async () => {
            const apiKey = getCurrentApiKey();
            if (!apiKey) return;
            setIsProcessing(true);
            setMessages(p => [...p, { role: "bot", content: "Refreshing document context..." }]);
            
            try {
                await Word.run(async (context) => {
                    const body = context.document.body;
                    body.load("text");
                    await context.sync();
                    
                    const result = await refreshCache(apiKey, getCurrentModel(), body.text);
                    setCacheStatus(getCacheStatus());
                    
                    if (result.error) {
                        setMessages(p => [...p, { role: "bot", content: `Note: ${result.error}` }]);
                    } else if (result.success) {
                        setMessages(p => [...p, { role: "bot", content: "Context refreshed. AI now has updated knowledge of your document." }]);
                    } else {
                        setMessages(p => [...p, { role: "bot", content: "Cache refresh failed. Using Direct Mode." }]);
                    }
                });
            } catch (e) {
                setMessages(p => [...p, { role: "bot", content: "Refresh failed: " + (e as Error).message }]);
            } finally {
                setIsProcessing(false);
            }
        };

        // ENHANCEMENT 2D: Updated handleAction with provider routing
        const handleAction = async () => {
            const apiKey = getCurrentApiKey();
            if (!apiKey) return setView("settings");
            if (!inputValue.trim()) return;

            const currentInput = inputValue;
            setInputValue("");
            setMessages((p) => [...p, { role: "user", content: currentInput }]);
            setIsProcessing(true);
            setProcessingStage("Reading document...");

            try {
                await Word.run(async (context) => {
                    const trackedItems = [];

                    try {
                        if (!authorSettings.detectedAuthor) {
                            await detectDocumentAuthor(context);
                        }

                        const selection = context.document.getSelection();
                        selection.load("text");
                        await context.sync();
                        
                        const rawSelectedText = selection.text?.trim() || "";
                        const hasFocus = rawSelectedText.length > 0;
                        
                        // ==========================================
                        // NEW: Check for INSERT intent BEFORE focus mode
                        // ==========================================
                        const wantsInsert = isInsertIntent(currentInput);
                        const requestedClauseRef = extractClauseReferenceFromPrompt(currentInput);
                        
                        if (wantsInsert) {
                            log(" INSERT intent detected:", currentInput);
                            log(" Requested clause ref:", requestedClauseRef);
                            
                            // Don't use focus mode for inserts - fall through to full document mode
                            // Clear focused selection to ensure full document handling
                            setFocusedSelection("");
                            
                            // Continue to full document handling below (don't return)
                        } else if (hasFocus) {
                            // ==========================================
                            // EXISTING FOCUS MODE (for MODIFY/QUESTION only)
                            // ==========================================
                            
                            const { text: acceptedSelectionText, oxml: selectionOxml } = await getAcceptedSelectionText(context);
                            
                            setFocusedSelection(acceptedSelectionText.substring(0, 100));
                            
                            if (isQuestionIntent(currentInput)) {
                                setProcessingStage("Analyzing selection...");
                                
                                try {
                                    const answer = await callQuestion(
                                        currentInput + "\n\n[User is asking about this specific clause: \"" + acceptedSelectionText.substring(0, 2000) + "\"]",
                                        acceptedSelectionText,
                                        cacheState.changelog,
                                        null
                                    );
                                    setMessages(p => [...p, { role: "bot", content: answer }]);
                                } catch (e) {
                                    setMessages(p => [...p, { role: "bot", content: "Error: " + (e as Error).message }]);
                                }
                                
                                setProcessingStage("");
                                setFocusedSelection("");
                                return;
                            }
                            
                            // Loading dots are sufficient - no processing stage needed
                            
                            try {
                                const newText = await callRedline(
                                    currentInput,
                                    acceptedSelectionText,
                                    null
                                );
                                
                                if (newText !== acceptedSelectionText) {
                                    setProcessingStage("Applying changes...");
                                    
                                    const redlineResult = applyRedlineToOxml(selectionOxml, acceptedSelectionText, newText);
                                    
                                    if (redlineResult.hasChanges) {
                                        selection.insertOoxml(redlineResult.oxml, Word.InsertLocation.replace);
                                        await context.sync();
                                        
                                        logChange("MODIFY", "Selection: " + currentInput.substring(0, 100), newText);
                                        setMessages(p => [...p, { role: "bot", content: "Applied changes to selection." }]);
                                    } else {
                                        setMessages(p => [...p, { role: "bot", content: "No changes needed." }]);
                                    }
                                } else {
                                    setMessages(p => [...p, { role: "bot", content: "No changes suggested." }]);
                                }
                            } catch (e) {
                                console.error("[Vibe] Focus mode redline failed:", e);
                                setMessages(p => [...p, { role: "bot", content: "Error: " + (e as Error).message }]);
                            }
                            
                            setProcessingStage("");
                            setFocusedSelection("");
                            return;
                        }
                        
                        // ==========================================
                        // FULL DOCUMENT MODE (including INSERTS)
                        // ==========================================
                        setFocusedSelection("");

                        const body = context.document.body;
                        body.load("text");
                        const paragraphs = context.document.body.paragraphs;
                        paragraphs.load("text, style, styleId, isListItem");
                        await context.sync();

                        const fullDocumentText = body.text;

                        // ==========================================
                        // COMPLEX TRANSFORMATION DETECTION
                        // ==========================================
                        // Instead of full-document rewrite + diff (which corrupts output),
                        // we pass a flag to the router for terminology-aware routing
                        const isComplexTransform = isHolisticTransformation(currentInput);
                        if (isComplexTransform) {
                            // Silent - no verbose message needed
                        }

                        if (isQuestionIntent(currentInput)) {
                            setProcessingStage("Analyzing document...");
                            
                            // ENHANCEMENT 2E: Skip cache for Claude
                            let cacheId: string | null = null;
                            if (providerConfig.provider === "gemini" && fullDocumentText.length >= CACHE_CONFIG.minCacheChars) {
                                const cacheResult = await ensureCache(getCurrentApiKey(), getCurrentModel(), fullDocumentText);
                                cacheId = cacheResult.cacheId;
                                if (cacheResult.error) {
                                    logWarn(" Cache unavailable for question:", cacheResult.error);
                                }
                            }
                            
                            try {
                                const answer = await callQuestion(
                                    currentInput,
                                    fullDocumentText,
                                    cacheState.changelog,
                                    cacheId
                                );
                                setMessages(p => [...p, { role: "bot", content: answer }]);
                            } catch (e) {
                                console.error("[Vibe] Question handler failed:", e);
                                setMessages(p => [...p, { role: "bot", content: "Failed to analyze: " + (e as Error).message }]);
                            }
                            
                            return;
                        }

                        // ENHANCEMENT 2E: Skip cache refresh for Claude
                        if (providerConfig.provider === "gemini" && shouldRefreshCache()) {
                            const refreshResult = await refreshCache(getCurrentApiKey(), getCurrentModel(), fullDocumentText);
                            if (refreshResult.error) {
                                setMessages(p => [...p, { role: "bot", content: `Note: ${refreshResult.error}` }]);
                            }
                        }

                        // ENHANCEMENT 2E: Skip cache for Claude
                        let cacheId: string | null = null;
                        if (providerConfig.provider === "gemini") {
                            const cacheResult = await ensureCache(getCurrentApiKey(), getCurrentModel(), fullDocumentText);
                            cacheId = cacheResult.cacheId;
                            
                            if (cacheResult.error) {
                                setMessages(p => [...p, { role: "bot", content: `Note: ${cacheResult.error}` }]);
                            }
                        }

                        const mapLines = [];
                        const lookup = {};

                        for (let i = 0; i < paragraphs.items.length; i++) {
                            const p = paragraphs.items[i];
                            if (p.isListItem) {
                                p.listItem.load("level");
                            }
                        }
                        await context.sync();

                        for (let i = 0; i < paragraphs.items.length; i++) {
                            const p = paragraphs.items[i];
                            const id = i + 1;
                            lookup[id] = p;

                            context.trackedObjects.add(p);
                            trackedItems.push(p);

                            const text = p.text.substring(0, 150).replace(/\n/g, " ");

                            let meta = `{Style: ${p.styleId}}`;
                            if (p.isListItem) {
                                try {
                                    meta += ` {List: Lvl ${p.listItem.level}}`;
                                } catch (e) {
                                    meta += ` {List: true}`;
                                }
                            }

                            if (text.trim().length > 0) {
                                mapLines.push(`[${id}] ${meta} ${text}`);
                            }
                        }

                        await context.sync();

                        const documentMap = mapLines.join("\n");

                        const { styleCache, menu: styleMenu } = await generateStyleMenuAndCache(context, paragraphs);

                        const snapshot = await captureDocumentSnapshot(context, paragraphs, styleCache);

                        // ==========================================
                        // SMART INSERTION POINT DETECTION
                        // ==========================================
                        let insertionHint = "";
                        
                        if (wantsInsert) {
                            // STEP 1: Try explicit clause reference first
                            if (requestedClauseRef) {
                                setProcessingStage("Finding clause " + requestedClauseRef + "...");
                                
                                const insertPoint = await findInsertionPointForClause(context, paragraphs, requestedClauseRef);
                                
                                if (insertPoint) {
                                    insertionHint = "\n\nINSERTION LOCATION: Insert after paragraph " + insertPoint.paragraphId + 
                                        " (clause " + insertPoint.foundRef + ").";
                                    log(" Found insertion point by clause ref:", insertPoint.paragraphId);
                                    setMessages(p => [...p, { role: "bot", content: "Found insertion point after clause " + insertPoint.foundRef }]);
                                } else {
                                    log(" Could not find clause reference, trying topic detection");
                                }
                            }
                            
                            // STEP 2: Topic-based cascading search
                            if (!insertionHint) {
                                const topic = extractTopicFromPrompt(currentInput);
                                
                                if (topic) {
                                    setProcessingStage("Finding " + topic.topic + " section...");
                                    
                                    // Use cascading search with AI fallback
                                    const searchResult = await findClauseByTopicCascading(
                                        context, 
                                        paragraphs, 
                                        topic.topic,
                                        getCurrentApiKey(),  // Enable Level 3 AI fallback
                                        getCurrentModel()
                                    );
                                    
                                    if (searchResult) {
                                        insertionHint = "\n\nINSERTION LOCATION: User wants to add " + topic.topic + 
                                            " content. Found '" + searchResult.clauseTitle.substring(0, 50) + 
                                            "' (confidence: " + searchResult.confidence + "%, method: " + searchResult.method + 
                                            "). Insert at end of this section, after paragraph " + searchResult.paragraphId + ".";
                                        
                                        log(" Cascading search success: P" + searchResult.paragraphId + 
                                                    " via " + searchResult.method);
                                        
                                        setMessages(p => [...p, { 
                                            role: "bot", 
                                            content: "Found '" + searchResult.clauseTitle.substring(0, 40) + "' section."
                                        }]);
                                    } else {
                                        insertionHint = "\n\nINSERTION NOTE: User wants to add " + topic.topic + 
                                            " content but no existing clause was found after exhaustive search. " +
                                            "Choose an appropriate location based on standard contract structure.";
                                    }
                                } else {
                                    // STEP 3: No explicit ref and no topic detected
                                    log(" No clause ref or topic detected, AI will decide location");
                                    insertionHint = "\n\nINSERTION NOTE: No specific location indicated. Analyze the document structure and choose the most appropriate location.";
                                }
                            }
                        }
                        
                        // Enhance prompt with insertion hint
                        const enhancedPrompt = currentInput + insertionHint;

                        // Loading dots are sufficient - no processing stage needed
                        
                        // BRAIN WIRING: Generate delta and neighborhood context
                        const deltaText = deltaGetTextBlock();
                        
                        // Fetch neighborhood around target if we have one from cascading search
                        let neighborhoodText = "";
                        if (wantsInsert && snapshot) {
                            // Try to extract target ID from insertionHint
                            const targetMatch = insertionHint.match(/after paragraph (\d+)/);
                            if (targetMatch) {
                                const targetId = parseInt(targetMatch[1], 10);
                                const neighborhood = fetchNeighborhood(targetId, snapshot);
                                neighborhoodText = formatNeighborhoodForPrompt(neighborhood);
                                log(" Neighborhood context generated for P" + targetId);
                            }
                        }
                        
                        // ENHANCEMENT 2D + 3: Use unified router with delta and neighborhood context
                        const routerResponse = await callRouter(
                            enhancedPrompt, styleMenu, snapshot, cacheId,
                            isComplexTransform, fullDocumentText,
                            deltaText, neighborhoodText
                        );
                        
                        // Log terminology if present (for complex transformations)
                        if (routerResponse.terminology) {
                        }

                        if (routerResponse.answer) {
                            setMessages((p) => [...p, { role: "bot", content: routerResponse.answer }]);
                        }

                        // INTENT-FIRST ARCHITECTURE: Handle unified operations array
                        if (routerResponse.operations && routerResponse.operations.length > 0) {
                            log(" Operations: " + routerResponse.operations.length + " operations to process");
                            
                            // Ensure ContractMap is built
                            if (!contractMapState.map) {
                                log(" Building ContractMap for operations...");
                                // Removed verbose "Analyzing document structure..." message
                                await ensureContractMap(
                                    getCurrentApiKey(), getCurrentModel(),
                                    fullDocumentText, snapshot.paragraphs, provider
                                );
                            }
                            
                            // Sort operations: DELETE first (bottom-up), then AMEND (bottom-up), then INSERT
                            const deleteOps = routerResponse.operations.filter(op => op.type === "DELETE");
                            const amendOps = routerResponse.operations.filter(op => op.type === "AMEND" || op.type === "AMEND_SIMPLE");
                            const insertOps = routerResponse.operations.filter(op => op.type === "INSERT");
                            
                            // LIVE OFFSET FORMULA: Track ID shift as we process operations
                            // When we DELETE a paragraph, subsequent IDs shift up (-1)
                            // When we INSERT a paragraph, subsequent IDs shift down (+1)
                            let liveIdShift = 0;
                            
                            /**
                             * Calculate the live paragraph ID accounting for operations performed.
                             * @param originalId - The target_id from the Router (based on original document)
                             * @returns The adjusted ID in the current document state
                             */
                            const getLiveId = (originalId: number): number => {
                                return originalId + liveIdShift;
                            };
                            
                            // DIAGNOSTIC: Log operation breakdown
                            log(" Operation breakdown: " + deleteOps.length + " DELETE, " + amendOps.length + " AMEND, " + insertOps.length + " INSERT");
                            log(" Raw operations:", JSON.stringify(routerResponse.operations, null, 2).substring(0, 1500));
                            
                            // Process DELETEs first (in ascending order with ID shift tracking)
                            // Sort by target_id ascending for predictable shift tracking
                            const sortedDeleteOps = deleteOps.sort((a, b) => {
                                const aId = a.target_id || 0;
                                const bId = b.target_id || 0;
                                return aId - bId;
                            });
                            
                            // DELETE OPERATIONS TEMPORARILY DISABLED - needs debugging
                            // Keeping code for future implementation
                            if (sortedDeleteOps.length > 0) {
                                log(" DELETE operations skipped (feature disabled): " + sortedDeleteOps.length + " ops");
                            }
                            /* DELETE DISABLED - BEGIN
                            for (const op of sortedDeleteOps) {
                                try {
                                    const target = op.target;
                                    log(" DELETE target raw:", JSON.stringify(target));
                                    
                                    // Flexible property extraction - AI uses inconsistent names
                                    const targetNumber = target?.number || target?.target_number || target?.clause_number || target?.clauseNumber || target?.clauseRef || target?.section;
                                    const targetTitle = target?.title || target?.target_title || target?.clause_title || target?.clauseTitle || target?.name;
                                    
                                    let range: ParagraphRange | null = null;
                                    
                                    // ID-FIRST: Check for explicit target_id
                                    if (op.target_id && typeof op.target_id === "number" && op.target_id > 0) {
                                        const liveId = getLiveId(op.target_id);
                                        log(" DELETE ID-First: target_id=" + op.target_id + " → liveId=" + liveId);
                                        
                                        if (liveId > 0 && liveId <= paragraphs.items.length) {
                                            range = { startId: liveId, endId: liveId, clauseNumber: targetNumber, clauseTitle: targetTitle };
                                        }
                                    } else {
                                        // Fallback to semantic resolution
                                        const anchor = { target_number: targetNumber, target_title: targetTitle };
                                        range = resolveAnchorToRange(anchor, contractMapState.map, paragraphs);
                                    }
                                    
                                    if (range) {
                                        log(" DELETE: " + (target?.title || targetNumber) + " (P" + range.startId + "-P" + range.endId + ")");
                                        
                                        const startPara = lookup[range.startId];
                                        const endPara = lookup[range.endId];
                                        if (startPara && endPara) {
                                            const sectionRange = startPara.getRange("Start").expandTo(endPara.getRange("End"));
                                            sectionRange.delete();
                                            await context.sync();
                                            logChange("DELETE", "Deleted: " + (target?.title || targetNumber));
                                            
                                            // LIVE OFFSET FORMULA: Decrement shift (deleted paragraphs shift subsequent IDs up)
                                            const deletedCount = range.endId - range.startId + 1;
                                            liveIdShift -= deletedCount;
                                            log(" DELETE complete: liveIdShift now " + liveIdShift + " (deleted " + deletedCount + " paragraphs)");
                                        } else {
                                            console.error("[Vibe] DELETE: Paragraph lookup failed for range", range);
                                        }
                                    } else {
                                        // FALLBACK: Try text-based search if semantic resolution fails
                                        log(" DELETE: Range resolution failed, trying text-based fallback");
                                        
                                        // Search paragraphs for matching text
                                        let foundIdx = -1;
                                        const searchTerms = [targetTitle, targetNumber].filter(Boolean).map(t => t?.toLowerCase());
                                        
                                        for (let i = 0; i < paragraphs.items.length && foundIdx === -1; i++) {
                                            const pText = paragraphs.items[i].text?.toLowerCase() || "";
                                            for (const term of searchTerms) {
                                                if (term && pText.includes(term)) {
                                                    foundIdx = i;
                                                    break;
                                                }
                                            }
                                        }
                                        
                                        if (foundIdx >= 0) {
                                            const liveId = foundIdx + 1;
                                            log(" DELETE fallback: Found via text search at P" + liveId);
                                            const targetPara = paragraphs.items[foundIdx];
                                            targetPara.delete();
                                            await context.sync();
                                            logChange("DELETE", "Deleted (fallback): " + (targetTitle || targetNumber));
                                            liveIdShift -= 1;
                                        } else {
                                            console.error("[Vibe] DELETE: Could not locate target:", { targetNumber, targetTitle });
                                        }
                                    }
                                } catch (e) {
                                    console.error("[Vibe] DELETE error:", e);
                                    setMessages((p) => [...p, { role: "bot", content: "Delete failed: " + e.message }]);
                                }
                            }
                            DELETE DISABLED - END */
                            
                            // Process AMENDs (sorted by target_id ascending)
                            const sortedAmendOps = amendOps.sort((a, b) => {
                                const aId = a.target_id || 0;
                                const bId = b.target_id || 0;
                                return aId - bId;
                            });
                            
                            for (const op of sortedAmendOps) {
                                try {
                                    const target = op.target;
                                    log(" AMEND target raw:", JSON.stringify(target));
                                    
                                    // Flexible property extraction - AI uses inconsistent names
                                    const targetNumber = target?.number || target?.target_number || target?.clause_number || target?.clauseNumber || target?.clauseRef || target?.section;
                                    const targetTitle = target?.title || target?.target_title || target?.clause_title || target?.clauseTitle || target?.name;
                                    
                                    const anchor = { target_number: targetNumber, target_title: targetTitle };
                                    log(" Extracted anchor:", JSON.stringify(anchor));
                                    
                                    // Extract scope from operation (default to NODE for safety)
                                    const opScope: "NODE" | "TREE" = op.scope === "TREE" ? "TREE" : "NODE";
                                    log(" AMEND scope:", opScope);
                                    
                                    // ID-FIRST ARCHITECTURE: Check for explicit target_id (bypass resolver)
                                    let range: ParagraphRange | null = null;
                                    
                                    if (op.target_id && typeof op.target_id === "number" && op.target_id > 0) {
                                        // LIVE OFFSET FORMULA: Apply shift to get current live ID
                                        const liveId = getLiveId(op.target_id);
                                        log(" AMEND ID-First: target_id=" + op.target_id + " → liveId=" + liveId + " (shift=" + liveIdShift + ")");
                                        
                                        // Validate ID is within bounds
                                        if (liveId > 0 && liveId <= paragraphs.items.length) {
                                            range = {
                                                startId: liveId,
                                                endId: liveId, // Start with single paragraph
                                                clauseNumber: targetNumber,
                                                clauseTitle: targetTitle
                                            };
                                            // For TREE scope, expand to include children
                                            if (opScope === "TREE") {
                                                range.endId = liveId + 5; // TREE gets small range
                                            }
                                        } else {
                                            logWarn(" ID-First: liveId=" + liveId + " out of bounds (paragraphs=" + paragraphs.items.length + ")");
                                        }
                                    } else {
                                        // Fallback: Use semantic resolution
                                        log(" Fallback: No target_id, using resolveAnchorToRange");
                                        range = resolveAnchorToRange(anchor, contractMapState.map, paragraphs, opScope);
                                    }
                                    
                                    if (!range) {
                                        logWarn(" Could not resolve range for AMEND:", anchor);
                                        continue;
                                    }
                                    
                                    // PARAGRAPH-MAPPED MODE: Check for paragraph_operations array
                                    if (op.paragraph_operations && Array.isArray(op.paragraph_operations) && op.paragraph_operations.length > 0) {
                                        log(" AMEND (paragraph-mapped): " + target?.title + " with " + op.paragraph_operations.length + " operations");
                                        // Removed verbose "Amending..." in-progress message
                                        
                                        // Build section context for logging (debugging)
                                        const sectionContext = buildSectionContextWithIds(range, paragraphs);
                                        log(" Section context:\n" + sectionContext.substring(0, 1000) + "...");
                                        
                                        // Process paragraph operations
                                        const changeCount = await processParaOperations(op.paragraph_operations, lookup, context);
                                        
                                        if (changeCount > 0) {
                                            logChange("AMEND", "Amended: " + (target?.title || target?.number) + " (" + changeCount + " changes)");
                                        }
                                        // Silenced per-operation message - single summary at end
                                    }
                                    // SIMPLE MODE: Fall back to amended_text for single-paragraph edits
                                    else if (op.amended_text) {
                                        log(" AMEND (simple): " + target?.title + " (P" + range.startId + "-P" + range.endId + ")");
                                        // Removed verbose in-progress message
                                        
                                        const startPara = lookup[range.startId];
                                        const endPara = lookup[range.endId];
                                        if (startPara && endPara) {
                                            const sectionRange = startPara.getRange("Start").expandTo(endPara.getRange("End"));
                                            sectionRange.load("text");
                                            const rangeOxml = sectionRange.getOoxml();
                                            await context.sync();
                                            
                                            const redlineResult = applyRedlineToOxml(rangeOxml.value, sectionRange.text, op.amended_text);
                                            
                                            // DIAGNOSTIC: Log original vs amended text
                                            log(" AMEND DIAGNOSTIC - Original text (" + sectionRange.text.length + " chars):");
                                            log(sectionRange.text.substring(0, 500) + (sectionRange.text.length > 500 ? "..." : ""));
                                            log(" AMEND DIAGNOSTIC - Amended text (" + op.amended_text.length + " chars):");
                                            log(op.amended_text.substring(0, 500) + (op.amended_text.length > 500 ? "..." : ""));
                                            log(" AMEND DIAGNOSTIC - hasChanges:", redlineResult.hasChanges);
                                            if (redlineResult.hasChanges) {
                                                sectionRange.insertOoxml(redlineResult.oxml, Word.InsertLocation.replace);
                                                await context.sync();
                                                
                                                // AUTO-SCROLL: Show the amended section
                                                await scrollToRange(sectionRange, context);
                                                await scrollDelay(150);
                                                
                                                logChange("AMEND", "Amended: " + (target?.title || target?.number));
                                                deltaRecordModify(range.startId, sectionRange.text, op.amended_text);
                                            }
                                            // Silenced per-operation message - single summary at end
                                        }
                                    } else {
                                        logWarn(" AMEND missing both paragraph_operations and amended_text:", op);
                                    }
                                } catch (e) {
                                    console.error("[Vibe] AMEND error:", e);
                                    setMessages((p) => [...p, { role: "bot", content: "⚠️ Amend failed: " + e.message }]);
                                }
                            }
                            
                            // Process INSERTs
                            for (const op of insertOps) {
                                try {
                                    const target = op.target;
                                    const navigation = op.navigation;
                                    
                                    // ID-FIRST: Use location_id directly if available
                                    let resolvedId: number | null = null;
                                    
                                    if (op.location_id && typeof op.location_id === "number" && op.location_id > 0) {
                                        // Apply live offset for coordinate tracking
                                        resolvedId = getLiveId(op.location_id);
                                        log(" INSERT ID-First: location_id=" + op.location_id + " → liveId=" + resolvedId);
                                    } else if (navigation?.target_number) {
                                        // Fallback: Use navigation.target_number (e.g., "7")
                                        const anchor = { 
                                            target_number: String(navigation.target_number), 
                                            target_title: navigation.target_title 
                                        };
                                        resolvedId = resolveAnchorToLiveID(anchor, contractMapState.map, paragraphs);
                                        log(" INSERT Fallback: navigation resolved to P" + resolvedId);
                                    } else {
                                        // Last resort: Use target.after (may be text)
                                        const anchor = { target_number: target?.after, target_title: target?.title };
                                        resolvedId = resolveAnchorToLiveID(anchor, contractMapState.map, paragraphs);
                                    }
                                    
                                    if (resolvedId && op.content) {
                                        log(" INSERT: After P" + resolvedId);
                                        // Removed verbose "Inserting new content..." message
                                        
                                        const refP = lookup[resolvedId];
                                        if (refP) {
                                            // SMART STYLING: Multi-signal header detection
                                            const content = op.content || "";
                                            const analysis = routerResponse.analysis;
                                            let blockStyleId = "T_Normal";
                                            
                                            if (analysis) {
                                                const isShort = content.length < 80;
                                                const hasNumber = /^\d+\.?\s/.test(content);
                                                const isAllCaps = content === content.toUpperCase() && /[A-Z]/.test(content);
                                                const hasBoldMarkers = /^\*\*[^*]+\*\*$/.test(content.trim());
                                                const isSingleWord = content.trim().split(/\s+/).length <= 3;
                                                const matchesFmt = op.fmt?.bold === true;
                                                
                                                const isHeader = isShort && (hasNumber || isAllCaps || hasBoldMarkers || matchesFmt || isSingleWord);
                                                
                                                if (isHeader && analysis.clauseStyle?.token) {
                                                    blockStyleId = analysis.clauseStyle.token;
                                                    const reason = hasNumber ? "numbered" : isAllCaps ? "allcaps" : hasBoldMarkers ? "bold" : matchesFmt ? "fmt" : "short";
                                                    log(" Smart Style: HEADER (" + reason + ") → " + blockStyleId);
                                                } else if (analysis.bodyStyle?.token) {
                                                    blockStyleId = analysis.bodyStyle.token;
                                                    log(" Smart Style: BODY → " + blockStyleId);
                                                }
                                            } else {
                                                blockStyleId = op.styleId || "T_Normal";
                                            }
                                            
                                            const addedCount = await insertBlocks(
                                                context,
                                                [{ content: op.content, styleId: blockStyleId }],
                                                styleCache,
                                                refP,
                                                routerResponse.analysis,
                                                null
                                            );
                                            await context.sync();
                                            
                                            // LIVE OFFSET FORMULA: Use actual count from insertBlocks
                                            liveIdShift += addedCount;
                                            log(" INSERT complete: added " + addedCount + ", liveIdShift now " + liveIdShift);
                                            
                                            logChange("INSERT", "Inserted after: " + (target?.title || target?.after));
                                            // Silenced per-operation message - single summary at end
                                        }
                                    }
                                } catch (e) {
                                    console.error("[Vibe] INSERT error:", e);
                                    setMessages((p) => [...p, { role: "bot", content: "⚠️ Insert failed: " + e.message }]);
                                }
                            }
                            
                            // Process INSERT_BLOCK (multi-paragraph grouped insert)
                            const insertBlockOps = routerResponse.operations.filter(op => op.type === "INSERT_BLOCK");
                            
                            for (const op of insertBlockOps) {
                                try {
                                    if (!op.insert_after || !op.paragraphs || !Array.isArray(op.paragraphs)) {
                                        logWarn(" INSERT_BLOCK: Missing insert_after or paragraphs");
                                        continue;
                                    }
                                    
                                    const insertAfterId = getLiveId(op.insert_after);
                                    log(" INSERT_BLOCK: Inserting " + op.paragraphs.length + " paragraphs after P" + insertAfterId);
                                    // Removed verbose in-progress message
                                    
                                    let lastInsertRef = lookup[insertAfterId];
                                    if (!lastInsertRef) {
                                        logWarn(" INSERT_BLOCK: Could not find paragraph P" + insertAfterId);
                                        continue;
                                    }
                                    
                                    let blocksAdded = 0;
                                    
                                    for (const para of op.paragraphs) {
                                        const cloneFromId = getLiveId(para.clone_from);
                                        const cloneSource = lookup[cloneFromId];
                                        
                                        if (!cloneSource) {
                                            logWarn(" INSERT_BLOCK: Could not find clone source P" + cloneFromId);
                                            // Fallback: insert plain text
                                            const newPara = lastInsertRef.insertParagraph(para.content || "", Word.InsertLocation.after);
                                            context.trackedObjects.add(newPara);
                                            await context.sync();
                                            lastInsertRef = newPara;
                                            blocksAdded++;
                                            continue;
                                        }
                                        
                                        // Get OXML from clone source
                                        const cloneOxmlResult = cloneSource.getOoxml();
                                        await context.sync();
                                        
                                        // ABSOLUTE LEVELING + STYLED HEADING SUPPORT
                                        let numPrInfo: { numId: string; ilvl: string } | null = null;
                                        let contentToInsert = para.content || "";
                                        
                                        // UNIFIED LIST INJECTION LOGIC:
                                        // 1. Extract numId from clone source (ignore ilvl - we use AI's list_level)
                                        // 2. Direct mapping: list_level 0→ilvl 0, 1→ilvl 1, 2→ilvl 2
                                        // 3. Strip numbers from ALL content (Word auto-generates)
                                        // 4. Inject numPr for ALL levels including 0
                                        
                                        let numPrInfo: { numId: string; ilvl: string } | null = null;
                                        
                                        if (typeof para.list_level === "number") {
                                            // Extract ONLY numId from clone source
                                            let extracted = extractNumPrFromOxml(cloneOxmlResult.value);
                                            
                                            // RESCUE: If clone source has no numId, search neighbors
                                            if (!extracted) {
                                                log(" Source P" + cloneFromId + " has no numId. Searching neighbors...");
                                                
                                                for (let d = 1; d <= 10 && !extracted; d++) {
                                                    const backId = cloneFromId - d;
                                                    const neighbor = lookup[backId];
                                                    if (neighbor) {
                                                        try {
                                                            neighbor.load("isListItem");
                                                            const nOxml = neighbor.getOoxml();
                                                            await context.sync();
                                                            if (neighbor.isListItem) {
                                                                extracted = extractNumPrFromOxml(nOxml.value);
                                                                if (extracted) {
                                                                    log(" Rescue: Found numId=" + extracted.numId + " from P" + backId);
                                                                }
                                                            }
                                                        } catch (e) { /* ignore */ }
                                                    }
                                                }
                                            }
                                            
                                            if (extracted) {
                                                // DIRECT MAPPING: AI's list_level = Word's ilvl
                                                log(" List Injection: numId=" + extracted.numId + ", ilvl=" + para.list_level);
                                                
                                                numPrInfo = {
                                                    numId: extracted.numId,
                                                    ilvl: String(para.list_level)  // Direct: 0→0, 1→1, 2→2
                                                };
                                                
                                                // Strip numbers from content (Word auto-generates for ALL levels)
                                                const originalContent = contentToInsert;
                                                contentToInsert = contentToInsert.replace(/^\d+(\.\d+)*\.?\s*/, "");
                                                if (originalContent !== contentToInsert) {
                                                    log(" Stripped number: \"" + originalContent.substring(0, 30) + "\" → \"" + contentToInsert.substring(0, 30) + "\"");
                                                }
                                            } else {
                                                // No numId found → document uses manual numbering
                                                // Keep AI's content including numbers
                                                log(" No list found. Manual numbering mode - preserving content.");
                                            }
                                        } else {
                                            log(" Plain Text Mode: list_level=" + para.list_level);
                                        }
                                        
                                        // Parse and replace text content in OXML
                                        const parser = new DOMParser();
                                        const serializer = new XMLSerializer();
                                        const WORD_NS = "http://schemas.openxmlformats.org/wordprocessingml/2006/main";
                                        
                                        const xmlDoc = parser.parseFromString(cloneOxmlResult.value, "application/xml");
                                        
                                        // Find all text nodes (w:t) and replace with new content
                                        const textNodes = xmlDoc.getElementsByTagNameNS(WORD_NS, "t");
                                        const allT = Array.from(xmlDoc.getElementsByTagName("w:t")).concat(Array.from(textNodes));
                                        
                                        // Clear existing text and put new content in first text node
                                        let firstTextNode = allT[0];
                                        for (const tNode of allT) {
                                            (tNode as Element).textContent = "";
                                        }
                                        if (firstTextNode) {
                                            (firstTextNode as Element).textContent = contentToInsert;
                                        }
                                        
                                        // Add track change wrapper
                                        const pNodes = xmlDoc.getElementsByTagNameNS(WORD_NS, "p");
                                        const pNode = Array.from(pNodes)[0] || Array.from(xmlDoc.getElementsByTagName("w:p"))[0];
                                        
                                        if (pNode) {
                                            // Wrap runs in w:ins
                                            const runs = Array.from(pNode.childNodes).filter(n => 
                                                n.localName === "r" || n.nodeName.endsWith(":r")
                                            );
                                            
                                            if (runs.length > 0) {
                                                const insNode = xmlDoc.createElementNS(WORD_NS, "w:ins");
                                                insNode.setAttribute("w:id", String(Date.now()));
                                                insNode.setAttribute("w:author", getTrackChangeAuthor());
                                                insNode.setAttribute("w:date", new Date().toISOString());
                                                
                                                runs.forEach(run => {
                                                    pNode.removeChild(run);
                                                    insNode.appendChild(run);
                                                });
                                                pNode.appendChild(insNode);
                                            }
                                        }
                                        
                                        // Remove sectPr if present
                                        const body = xmlDoc.getElementsByTagNameNS(WORD_NS, "body")[0] || xmlDoc.getElementsByTagName("w:body")[0];
                                        if (body) {
                                            const sectPr = body.getElementsByTagNameNS(WORD_NS, "sectPr")[0] || body.getElementsByTagName("w:sectPr")[0];
                                            if (sectPr) body.removeChild(sectPr);
                                        }
                                        
                                        let finalOxml = serializer.serializeToString(xmlDoc);
                                        
                                        // UNIFIED: Strip inherited numPr, then inject fresh for ALL list levels
                                        if (numPrInfo) {
                                            finalOxml = stripNumPrFromOxml(finalOxml);  // Always strip first
                                            finalOxml = injectNumPrIntoOxml(finalOxml, numPrInfo.numId, numPrInfo.ilvl);
                                            
                                            // DEBUG: Extract the <w:p> portion and log it
                                            const pMatch = finalOxml.match(/<w:body[\s\S]*?<w:p[\s\S]*?<\/w:p>/);
                                            log(" DEBUG - Paragraph XML:", pMatch ? pMatch[0].substring(0, 500) : "NOT FOUND");
                                        }
                                        
                                        // Insert new paragraph after last insert
                                        const newPara = lastInsertRef.insertParagraph("", Word.InsertLocation.after);
                                        context.trackedObjects.add(newPara);
                                        await context.sync();
                                        
                                        newPara.insertOoxml(finalOxml, Word.InsertLocation.replace);
                                        await context.sync();
                                        
                                        // WORD API APPROACH: Set list level after insertion
                                        if (typeof para.list_level === "number") {
                                            try {
                                                newPara.load("listItem");
                                                await context.sync();
                                                
                                                log(" Setting listItem.level to:", para.list_level);
                                                newPara.listItem.level = para.list_level;
                                                await context.sync();
                                            } catch (e) {
                                                log(" listItem.level failed (not a list item?):", e);
                                            }
                                        }
                                        
                                        lastInsertRef = newPara;
                                        blocksAdded++;
                                        
                                        // AUTO-SCROLL: Show each inserted paragraph
                                        const insertedRange = newPara.getRange();
                                        await scrollToRange(insertedRange, context);
                                        await scrollDelay(150);
                                        
                                        log(" INSERT_BLOCK: Added paragraph (clone_from P" + cloneFromId + ", type: " + para.type + ")");
                                    }
                                    
                                    // Update live offset
                                    liveIdShift += blocksAdded;
                                    log(" INSERT_BLOCK complete: added " + blocksAdded + " paragraphs, liveIdShift now " + liveIdShift);
                                    
                                    logChange("INSERT_BLOCK", "Inserted " + blocksAdded + " paragraphs");
                                    // Silenced per-operation message - single summary at end
                                    
                                } catch (e) {
                                    console.error("[Vibe] INSERT_BLOCK error:", e);
                                    setMessages((p) => [...p, { role: "bot", content: "⚠️ Insert block failed: " + e.message }]);
                                }
                            }

                            if (routerResponse.operations.length > 0) {
                                setMessages((p) => [...p, { role: "bot", content: "✓ " + routerResponse.operations.length + " change" + (routerResponse.operations.length === 1 ? "" : "s") + " applied" }]);
                                
                                // SIZE BIFURCATION: Different strategies based on document size
                                const docSize = paragraphs?.items?.length || 0;
                                
                                if (docSize < 500) {
                                    // SHORT/MEDIUM DOC (<500 paragraphs ≈ 15 pages):
                                    // Force ContractMap rebuild every turn (fast, guarantees accuracy)
                                    log(" Short doc mode: Invalidating ContractMap for rebuild (" + docSize + " paragraphs)");
                                    contractMapState = { map: null, documentHash: null, totalParagraphCount: null, isAnalyzing: false };
                                    deltaFlatten();  // Clear delta log since map will be fresh
                                } else {
                                    // LONG DOC (>=500 paragraphs):
                                    // Use cached map + delta tracking (rebuilding is expensive)
                                    if (deltaNeedsFlatten()) {
                                        // Delta log too large - force full rebuild
                                        log(" Long doc: Delta log exceeded threshold - scheduling full ContractMap rebuild");
                                        contractMapState = { map: null, documentHash: null, totalParagraphCount: null, isAnalyzing: false };
                                        deltaFlatten();
                                    } else {
                                        // Keep ContractMap, rely on delta shifts for ID resolution
                                        log(" Long doc: Delta tracking active (" + deltaManager.operations.length + " deltas, map preserved)");
                                    }
                                }
                            }
                        }
                        
                        // LEGACY: Support old actions array for backward compatibility
                        if (routerResponse.actions && routerResponse.actions.length > 0) {
                            const actions = routerResponse.actions;

                            const insertActions = actions.filter(a => a.type === "INSERT");
                            const modifyActions = actions.filter(a => a.type === "MODIFY");

                            if (insertActions.length > 0) {
                                // COMBINE all INSERT action blocks into a single insertion
                                const firstAction = insertActions[0];
                                
                                // AI-FIRST NAVIGATION: Resolve anchor to live paragraph ID
                                let resolvedLocId: number | null = null;
                                
                                // Step 1: Try AI's navigation anchor
                                if (firstAction.navigation) {
                                    resolvedLocId = resolveAnchorToLiveID(
                                        firstAction.navigation,
                                        contractMapState.map,
                                        paragraphs
                                    );
                                    if (resolvedLocId) {
                                        log(" AI-First: Resolved to P" + resolvedLocId);
                                    }
                                }
                                
                                // Step 2: Fallback to AI's location_id if anchor failed
                                if (!resolvedLocId && firstAction.location_id) {
                                    resolvedLocId = firstAction.location_id;
                                    log(" AI-First fallback: Using AI's location_id P" + resolvedLocId);
                                }
                                
                                // Step 3: Final fallback - cascading search if all else failed
                                if (!resolvedLocId && wantsInsert) {
                                    log(" AI navigation failed, falling back to cascading search");
                                    const targetMatch = insertionHint.match(/after paragraph (\d+)/);
                                    if (targetMatch) {
                                        resolvedLocId = parseInt(targetMatch[1], 10);
                                        log(" Cascading fallback: P" + resolvedLocId);
                                    }
                                }
                                
                                const locId = resolvedLocId || firstAction.location_id;
                                let refP = lookup[locId];

                                // Merge all blocks from all INSERT actions
                                const allBlocks: any[] = [];
                                for (const action of insertActions) {
                                    if (action.blocks && Array.isArray(action.blocks)) {
                                        allBlocks.push(...action.blocks);
                                    } else if (action.content) {
                                        // Plain text action, wrap as block
                                        allBlocks.push({ content: action.content, styleId: "T_Normal" });
                                    }
                                }
                                
                                log(" Combined " + insertActions.length + " INSERT actions into " + allBlocks.length + " blocks, target P" + locId);

                                if (refP) {
                                    try {
                                        // DEFENSIVE: Re-add to tracked objects to prevent "object is untracked" error
                                        try {
                                            context.trackedObjects.add(refP);
                                        } catch (trackErr) {
                                            // Already tracked, ignore
                                        }
                                        
                                        // Check if sibling is a list item and extract numPr
                                        let listInfo: { numId: string; ilvl: string } | null = null;
                                        
                                        refP.load("isListItem, style");
                                        const siblingOxmlResult = refP.getOoxml();
                                        await context.sync();
                                        
                                        if (refP.isListItem) {
                                            const extractedInfo = extractNumPrFromOxml(siblingOxmlResult.value);
                                            if (extractedInfo) {
                                                // SMART LIST LEVEL
                                                const siblingIlvl = parseInt(extractedInfo.ilvl, 10);
                                                const isHeading = siblingIlvl === 0 && 
                                                    (refP.style?.toLowerCase().includes("heading") || false);
                                                
                                                const smartIlvl = isHeading ? "1" : extractedInfo.ilvl;
                                                
                                                listInfo = { numId: extractedInfo.numId, ilvl: smartIlvl };
                                                
                                                log(" Smart list: sibling ilvl=" + extractedInfo.ilvl + 
                                                    ", isHeading=" + isHeading + ", using ilvl=" + smartIlvl);
                                            }
                                        }
                                        
                                        if (allBlocks.length > 0) {
                                            // Insert ALL combined blocks at once
                                            await insertBlocks(context, allBlocks, styleCache, refP, routerResponse.analysis, listInfo);
                                            
                                            const contentPreview = allBlocks.map(b => b.content).join(" ").substring(0, 200);
                                            const listNote = listInfo ? " (joined numbered list)" : "";
                                            logChange("INSERT", `Added ${allBlocks.length} block(s) after paragraph ${locId}${listNote}`, contentPreview);
                                            
                                            // Record in DeltaManager
                                            deltaRecordInsert(locId, contentPreview);
                                            
                                            // Mark map as stale
                                            contractMapState.totalParagraphCount = null;
                                            
                                            setMessages((p) => [...p, { role: "bot", content: `Inserted ${allBlocks.length} block(s)${listNote}.` }]);
                                        } else {
                                            logWarn(" No blocks found in any INSERT action.");
                                            setMessages((p) => [...p, { role: "bot", content: `No content to insert.` }]);
                                        }
                                    } catch (e) {
                                        logWarn(" Insertion failed.", e);
                                        setMessages((p) => [...p, { role: "bot", content: `Insertion failed: ${e.message}` }]);
                                    }
                                } else {
                                    setMessages((p) => [...p, { role: "bot", content: `Invalid location specified.` }]);
                                }
                            }

                            if (modifyActions.length > 0) {
                                // INTENT-BASED FORKING: Check if any MODIFY has navigation anchor
                                // If so, resolve the section range first
                                
                                for (const action of modifyActions) {
                                    // If action has navigation but no target_id, resolve the range
                                    if (action.navigation && !action.target_id) {
                                        const range = resolveAnchorToRange(
                                            action.navigation,
                                            contractMapState.map,
                                            paragraphs
                                        );
                                        
                                        if (range) {
                                            // Convert section-level MODIFY to paragraph-level
                                            // Skip heading if position is "body"
                                            const bodyStart = (action.navigation.position === "body" && range.headingId) 
                                                ? range.headingId + 1 
                                                : range.startId;
                                            
                                            log(" Section MODIFY: P" + bodyStart + " to P" + range.endId + 
                                                " (" + range.clauseTitle + ")");
                                            
                                            // Inject target_ids for each paragraph in range
                                            action._resolvedRange = range;
                                            action._rangeTargets = [];
                                            for (let pid = bodyStart; pid <= range.endId; pid++) {
                                                action._rangeTargets.push(pid);
                                            }
                                        }
                                    }
                                }
                                
                                // ENHANCEMENT 3: Process sequentially for complex transformations
                                const processingMode = isComplexTransform ? "sequentially" : "in parallel";
                                
                                const modifyTasks = [];
                                const holisticTasks = [];  // NEW: Holistic section tasks

                                for (const action of modifyActions) {
                                    // Handle section-level MODIFY (resolved from navigation)
                                    // 🔧 FIX: Use HOLISTIC processing instead of paragraph-by-paragraph
                                    if (action._resolvedRange) {
                                        const range = action._resolvedRange;
                                        
                                        // Calculate actual start (skip heading if body-only)
                                        const startId = (range.headingId && action.navigation?.position === "body") 
                                            ? range.headingId + 1 
                                            : range.startId;
                                        const endId = range.endId;
                                        
                                        log(" HOLISTIC: Section " + range.clauseNumber + " → P" + startId + " to P" + endId);
                                        
                                        // Add to holistic queue (NOT modifyTasks)
                                        holisticTasks.push({
                                            startId,
                                            endId,
                                            instruction: action.instruction || action.description,
                                            clauseNumber: range.clauseNumber,
                                            clauseTitle: range.clauseTitle
                                        });
                                    } else {
                                        // Handle single-paragraph MODIFY (original behavior)
                                        const targetId = action.target_id;
                                        const targetP = lookup[targetId];
                                        if (targetP) {
                                            targetP.load("text");
                                            const oxml = targetP.getOoxml();
                                            modifyTasks.push({ action, targetP, oxml });
                                        } else {
                                            setMessages((p) => [...p, { role: "bot", content: `Invalid Target ID: ${targetId}` }]);
                                        }
                                    }
                                }
                                
                                // ==========================================
                                // HOLISTIC PROCESSING (SECTION-LEVEL)
                                // ==========================================
                                for (const task of holisticTasks) {
                                    try {
                                        const startPara = lookup[task.startId];
                                        const endPara = lookup[task.endId];
                                        
                                        if (startPara && endPara) {
                                            // Removed verbose "Modifying..." message
                                            
                                            // Create a single range spanning the entire section
                                            const sectionRange = startPara.getRange("Start").expandTo(endPara.getRange("End"));
                                            sectionRange.load("text");
                                            const rangeOxml = sectionRange.getOoxml();
                                            await context.sync();
                                            
                                            log(" HOLISTIC: Fetched " + sectionRange.text.length + " chars for " + task.clauseTitle);
                                            
                                            // Call redliner with ENTIRE section text
                                            const redlined = await callRedline(
                                                task.instruction,
                                                sectionRange.text,
                                                cacheId,
                                                fullDocumentText
                                            );
                                            
                                            // Apply redlines to OXML
                                            const redlineResult = applyRedlineToOxml(rangeOxml.value, sectionRange.text, redlined);
                                            
                                            if (redlineResult.hasChanges) {
                                                sectionRange.insertOoxml(redlineResult.oxml, Word.InsertLocation.replace);
                                                await context.sync();
                                                
                                                // AUTO-SCROLL: Show the modified section
                                                await scrollToRange(sectionRange, context);
                                                
                                                logChange("MODIFY", "Modified: " + (task.clauseTitle || task.clauseNumber));
                                                deltaRecordModify(task.startId, sectionRange.text, redlined);
                                                setMessages((p) => [...p, { role: "bot", content: "✓ Modified: " + (task.clauseTitle || task.clauseNumber) }]);
                                            } else {
                                                // Silent - no need to report lack of changes per item
                                            }
                                        }
                                    } catch (e) {
                                        console.error("[Vibe] HOLISTIC error:", e);
                                        setMessages((p) => [...p, { role: "bot", content: "⚠️ Modification failed: " + e.message }]);
                                    }
                                }

                                if (modifyTasks.length > 0) {
                                    await context.sync();

                                    let results: any[] = [];
                                    
                                    if (isComplexTransform) {
                                        // SEQUENTIAL processing for complex transformations
                                        // This ensures each change is applied cleanly before the next
                                        
                                        // Build terminology context from router response
                                        let terminologyContext = "";
                                        if (routerResponse.terminology) {
                                            const t = routerResponse.terminology;
                                            terminologyContext = `TRANSFORMATION: ${t.notes || 'Complex transformation'}. `;
                                            if (t.find_replace && t.find_replace.length > 0) {
                                                terminologyContext += "REPLACEMENTS: " + t.find_replace.map(
                                                    (fr: any) => `"${fr.find}" -> "${fr.replace}"`
                                                ).join(", ");
                                            }
                                        }
                                        
                                        for (const task of modifyTasks) {
                                            try {
                                                // Enrich instruction with terminology context for complex transformations
                                                let enrichedInstruction = task.action.instruction;
                                                if (terminologyContext) {
                                                    enrichedInstruction = `${terminologyContext}\n\nINSTRUCTION: ${task.action.instruction}`;
                                                }
                                                
                                                const newText = await callRedline(
                                                    enrichedInstruction, task.targetP.text, cacheId
                                                );
                                                results.push({ ...task, newText, success: true });
                                                
                                                // Apply immediately for sequential processing
                                                const redlineResult = applyRedlineToOxml(task.oxml.value, task.targetP.text, newText);
                                                if (redlineResult.hasChanges) {
                                                    task.targetP.insertOoxml(redlineResult.oxml, Word.InsertLocation.replace);
                                                    await context.sync();
                                                    
                                                    // AUTO-SCROLL: Show the modified paragraph
                                                    const modifiedRange = task.targetP.getRange();
                                                    await scrollToRange(modifiedRange, context);
                                                    
                                                    logChange("MODIFY", `Modified paragraph ${task.action.target_id}: ${task.action.instruction.substring(0, 100)}`);
                                                    
                                                    // Record in DeltaManager for cross-provider state tracking
                                                    deltaRecordModify(task.action.target_id, task.targetP.text, newText);
                                                    
                                                    setMessages((p) => [...p, { role: "bot", content: `Modified: ${task.action.description || 'section'}` }]);
                                                }
                                            } catch (e) {
                                                console.error(`[Vibe] Redline failed for ${task.action.target_id}`, e);
                                                results.push({ ...task, error: e.message, success: false });
                                                setMessages((p) => [...p, { role: "bot", content: `Failed to modify: ${e.message}` }]);
                                            }
                                        }
                                        
                                    } else {
                                        // PARALLEL processing for standard modifications
                                        results = await Promise.all(modifyTasks.map(async (task) => {
                                            try {
                                                const newText = await callRedline(
                                                    task.action.instruction, task.targetP.text, cacheId
                                                );
                                                return { ...task, newText, success: true };
                                            } catch (e) {
                                                console.error(`[Vibe] Redline failed for ${task.action.target_id}`, e);
                                                return { ...task, error: e.message, success: false };
                                            }
                                        }));

                                        let changesApplied = 0;
                                        for (const res of results) {
                                            if (res.success) {
                                                const redlineResult = applyRedlineToOxml(res.oxml.value, res.targetP.text, res.newText);
                                                if (redlineResult.hasChanges) {
                                                    res.targetP.insertOoxml(redlineResult.oxml, Word.InsertLocation.replace);
                                                    await context.sync();
                                                    
                                                    // AUTO-SCROLL: Show the modified paragraph
                                                    const modifiedRange = res.targetP.getRange();
                                                    await scrollToRange(modifiedRange, context);
                                                    
                                                    setMessages((p) => [...p, { role: "bot", content: `Modified section.` }]);
                                                    changesApplied++;
                                                    
                                                    logChange("MODIFY", `Modified paragraph ${res.action.target_id}: ${res.action.instruction.substring(0, 100)}`);
                                                    // Record in DeltaManager for cross-provider state tracking
                                                    deltaRecordModify(res.action.target_id, res.targetP.text, res.newText);
                                                } else {
                                                    setMessages((p) => [...p, { role: "bot", content: `No changes needed.` }]);
                                                }
                                            } else {
                                                setMessages((p) => [...p, { role: "bot", content: `Failed to modify: ${res.error}` }]);
                                            }
                                        }

                                        if (changesApplied > 0) {
                                            await context.sync();
                                        }
                                    }
                                }
                            }
                        }
                        
                        // SUPER FOCUS MODE: Process modification_plan for multi-section edits
                        if (routerResponse.modification_plan && routerResponse.modification_plan.length > 0) {
                            const plan = routerResponse.modification_plan;
                            log(" Super Focus: " + plan.length + " targets identified");
                            
                            // CRITICAL: Ensure ContractMap is built for anchor resolution
                            if (!contractMapState.map) {
                                log(" Super Focus: Building ContractMap for anchor resolution...");
                                setMessages((p) => [...p, { role: "bot", content: "Analyzing document structure..." }]);
                                
                                // Convert snapshot paragraphs to format needed by ensureContractMap
                                const snapshotParagraphs: ParagraphSnapshot[] = snapshot.paragraphs;
                                
                                await ensureContractMap(
                                    getCurrentApiKey(),
                                    getCurrentModel(),
                                    fullDocumentText,
                                    snapshotParagraphs,
                                    provider
                                );
                                
                                if (contractMapState.map) {
                                    log(" Super Focus: ContractMap built with " + 
                                        (contractMapState.map.clauses?.length || 0) + " clauses");
                                }
                            }
                            
                            setMessages((p) => [...p, { 
                                role: "bot", 
                                content: "**Super Focus Mode:** Targeting " + plan.length + " sections for modification" 
                            }]);
                            
                            // Step 1: Resolve all anchors FIRST (before any modifications)
                            const resolvedTargets = [];
                            for (const target of plan) {
                                const anchor = {
                                    target_number: target.target_anchor?.number,
                                    target_title: target.target_anchor?.title
                                };
                                const range = resolveAnchorToRange(anchor, contractMapState.map, paragraphs);
                                if (range) {
                                    resolvedTargets.push({
                                        ...target,
                                        range,
                                        startId: range.startId,
                                        endId: range.endId
                                    });
                                }
                            }
                            
                            // Step 2: Sort by startId DESCENDING (bottom-up) to avoid ID drift
                            resolvedTargets.sort((a, b) => b.startId - a.startId);
                            log(" Super Focus: Processing " + resolvedTargets.length + " targets bottom-up");
                            
                            // Step 3: Process each target
                            for (const target of resolvedTargets) {
                                try {
                                    log(" Super Focus: Modifying " + 
                                        (target.target_anchor?.title || target.target_anchor?.number) + 
                                        " (P" + target.startId + "-P" + target.endId + ")");
                                    
                                    setMessages((p) => [...p, { 
                                        role: "bot", 
                                        content: "Modifying: " + (target.target_anchor?.title || "Section " + target.target_anchor?.number) + "..." 
                                    }]);
                                    
                                    // HOLISTIC RANGE PROCESSING: Treat section as single block
                                    const startPara = lookup[target.startId];
                                    const endPara = lookup[target.endId];
                                    
                                    if (startPara && endPara) {
                                        // Create range spanning entire section
                                        const sectionRange = startPara.getRange("Start").expandTo(endPara.getRange("End"));
                                        sectionRange.load("text");
                                        const rangeOxml = sectionRange.getOoxml();
                                        await context.sync();
                                        
                                        if (sectionRange.text && sectionRange.text.trim().length > 0) {
                                            // ROUTER-FIRST DRAFTING: Use amended_text from Router if available
                                            let newText: string;
                                            
                                            if (target.amended_text) {
                                                // Router already drafted the amendment (preferred path)
                                                log(" Router-First: Using pre-drafted amended_text (" + target.amended_text.length + " chars)");
                                                newText = target.amended_text;
                                            } else {
                                                // Fallback: Call Redliner (legacy path)
                                                log(" Fallback: Calling Redliner for section");
                                                const contextNote = "SECTION: " + (target.range?.clauseTitle || "Unknown") + 
                                                    "\nDOCUMENT TYPE: " + (contractMapState.map?.documentType || "Contract") +
                                                    "\nCONTEXT: This is one section of a larger document. Preserve consistency.";
                                                const enrichedInstruction = contextNote + "\n\nINSTRUCTION: " + target.instruction;
                                                newText = await callRedline(
                                                    enrichedInstruction, sectionRange.text, cacheId, neighborhoodText
                                                );
                                            }
                                            
                                            // Apply diff to entire range
                                            const redlineResult = applyRedlineToOxml(rangeOxml.value, sectionRange.text, newText);
                                            if (redlineResult.hasChanges) {
                                                sectionRange.insertOoxml(redlineResult.oxml, Word.InsertLocation.replace);
                                                await context.sync();
                                                
                                                logChange("MODIFY", "Super Focus: " + target.instruction.substring(0, 50));
                                                deltaRecordModify(target.startId, sectionRange.text, newText);
                                                
                                                log(" Holistic: Applied diff to section range");
                                            }
                                        }
                                    }
                                    
                                    setMessages((p) => [...p, { 
                                        role: "bot", 
                                        content: "✓ Completed: " + (target.target_anchor?.title || "Section " + target.target_anchor?.number) 
                                    }]);
                                    
                                } catch (e) {
                                    console.error("[Vibe] Super Focus error for target:", target, e);
                                    setMessages((p) => [...p, { 
                                        role: "bot", 
                                        content: "⚠️ Failed to modify: " + (target.target_anchor?.title || "section") + " - " + e.message 
                                    }]);
                                }
                            }
                            
                            setMessages((p) => [...p, { 
                                role: "bot", 
                                content: "**Super Focus Mode complete.** Modified " + resolvedTargets.length + " sections." 
                            }]);
                        }
                    } finally {
                        if (trackedItems && trackedItems.length > 0) {
                            trackedItems.forEach(p => context.trackedObjects.remove(p));
                            await context.sync();
                        }
                    }
                });
            } catch (e) {
                console.error(e);
                setMessages((p) => [...p, { role: "bot", content: "Error: " + e.message }]);
            } finally {
                setIsProcessing(false);
                setProcessingStage("");
                setFocusedSelection("");
            }
        };

        if (view === "settings") {
            return React.createElement(Settings, {
                provider,
                setProvider,
                geminiApiKey,
                setGeminiApiKey,
                claudeApiKey,
                setClaudeApiKey,
                geminiModel,
                setGeminiModel,
                claudeModel,
                setClaudeModel,
                authorMode,
                setAuthorMode,
                customAuthor,
                setCustomAuthor,
                detectedAuthor,
                onBack: () => setView("main")
            });
        }

        return React.createElement("div", { style: { display: "flex", flexDirection: "column", height: "100vh", background: "linear-gradient(to bottom right, #fafafa, #fff, #f5f5f5)" } },
            React.createElement(Header, { 
                onSettingsClick: () => setView("settings"), 
                onRefreshContext: handleRefreshContext,
                onHelpClick: () => setShowHelp(true),
                cacheStatus: cacheStatus, 
                focusedSelection: focusedSelection, 
                processingStage: processingStage,
                provider: provider,
                currentModel: provider === "gemini" ? geminiModel : claudeModel
            }),
            React.createElement(Chat, { messages: messages, isLoading: isProcessing }),
            React.createElement(InputArea, { 
                value: inputValue, 
                onChange: setInputValue, 
                onSend: handleAction, 
                disabled: isProcessing,
                currentModel: provider === "gemini" ? geminiModel : claudeModel,
                provider: provider
            }),
            // HelpGuide modal (Point 6)
            showHelp && React.createElement(HelpGuide, { onClose: () => setShowHelp(false) })
        );
    };

    function renderMarkdown(text: string): string {
        if (!text) return "";
        return text
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/\*\*(.*?)\*\*/g, "<strong>$1</strong>")
            .replace(/\*(.*?)\*/g, "<em>$1</em>")
            .replace(/\n/g, "<br>");
    }


    // HELPER FUNCTIONS
    // Namespace-compliant element creation for Track Changes
    function createTextRun(xmlDoc, text, rPr, isDeleted) {
        const r = xmlDoc.createElementNS(WORD_NS, "w:r");
        if (rPr) {
            const newRPr = rPr.cloneNode(true);
            r.appendChild(newRPr);
        }

        if (isDeleted) {
            const delText = xmlDoc.createElementNS(WORD_NS, "w:delText");
            delText.textContent = text;
            delText.setAttribute("xml:space", "preserve");
            r.appendChild(delText);
        } else {
            const t = xmlDoc.createElementNS(WORD_NS, "w:t");
            t.textContent = text;
            t.setAttribute("xml:space", "preserve");
            r.appendChild(t);
        }
        return r;
    }

    function createTrackChange(xmlDoc, type, run) {
        const wrapper = xmlDoc.createElementNS(WORD_NS, type === 'del' ? "w:del" : "w:ins");
        wrapper.setAttribute("w:id", Math.floor(Math.random() * 10000).toString());
        wrapper.setAttribute("w:author", getTrackChangeAuthor());
        wrapper.setAttribute("w:date", new Date().toISOString());
        wrapper.appendChild(run);
        return wrapper;
    }


    Office.onReady(() => ReactDOM.render(React.createElement(App), document.getElementById("root")));

template:
  content: |
    <div id="root"></div>
style:
  content: |
    body { 
        margin: 0; 
        padding: 0; 
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        -webkit-font-smoothing: antialiased;
    }
    @keyframes float {
        0%, 100% { transform: translateY(0); }
        50% { transform: translateY(-3px); }
    }
    @keyframes pulse-glow {
        0%, 100% { opacity: 1; box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.4); }
        50% { opacity: 0.8; box-shadow: 0 0 0 4px rgba(16, 185, 129, 0); }
    }
    @keyframes bounce {
        0%, 80%, 100% { transform: translateY(0); }
        40% { transform: translateY(-6px); }
    }
    @keyframes slideDown {
        from { opacity: 0; transform: translateY(-10px); }
        to { opacity: 1; transform: translateY(0); }
    }
    @keyframes scaleIn {
        from { opacity: 0; transform: scale(0.95); }
        to { opacity: 1; transform: scale(1); }
    }
    @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
    }
    @keyframes shimmer {
        0% { transform: translateX(-100%); }
        100% { transform: translateX(100%); }
    }
    @keyframes spin {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
    }
libraries: |
  https://appsforoffice.microsoft.com/lib/1/hosted/office.js
  https://unpkg.com/react@17/umd/react.development.js
  https://unpkg.com/react-dom@17/umd/react-dom.development.js
  https://cdnjs.cloudflare.com/ajax/libs/diff_match_patch/20121119/diff_match_patch.js
