name: Vibe Legal Alpha 0.1
description: AI-Powered Contract Redlining
host: WORD
api_set: {}
script:
  content: |
    /**
     * VIBE LEGAL - AI-Powered Contract Redlining Engine
     * 
     * MVP 1.1 Enhanced - Structured Reasoning + Claude (Anthropic) API Support
     * 
     * https://github.com/sarturko-maker/vibe-legal
     * GNU General Public License
     */

    declare var diff_match_patch: any;
    declare var React: any;
    declare var ReactDOM: any;

    // ==========================================
    // PROVIDER CONFIGURATION
    // ==========================================

    type AIProvider = "gemini" | "claude";

    interface ProviderConfig {
        provider: AIProvider;
        geminiApiKey: string;
        claudeApiKey: string;
        geminiModel: string;
        claudeModel: string;
    }

    let providerConfig: ProviderConfig = {
        provider: "gemini",
        geminiApiKey: "",
        claudeApiKey: "",
        geminiModel: "gemini-2.0-flash-exp",
        claudeModel: "claude-sonnet-4-20250514"
    };

    function getCurrentApiKey(): string {
        return providerConfig.provider === "gemini" 
            ? providerConfig.geminiApiKey 
            : providerConfig.claudeApiKey;
    }

    function getCurrentModel(): string {
        return providerConfig.provider === "gemini"
            ? providerConfig.geminiModel
            : providerConfig.claudeModel;
    }

    // ==========================================
    // TRACK CHANGES AUTHOR SYSTEM
    // ==========================================

    type AuthorMode = "auto" | "vibe" | "custom";

    interface AuthorSettings {
        mode: AuthorMode;
        customName: string;
        detectedAuthor: string | null;
    }

    let authorSettings: AuthorSettings = {
        mode: "auto",
        customName: "",
        detectedAuthor: null
    };

    function getTrackChangeAuthor(): string {
        switch (authorSettings.mode) {
            case "auto":
                return authorSettings.detectedAuthor || "Vibe AI";
            case "vibe":
                return "Vibe AI";
            case "custom":
                return authorSettings.customName.trim() || "Vibe AI";
            default:
                return "Vibe AI";
        }
    }

    async function detectDocumentAuthor(context: Word.RequestContext): Promise<string | null> {
        try {
            const properties = context.document.properties;
            properties.load("lastAuthor, author");
            await context.sync();
            
            const detected = properties.lastAuthor?.trim() || properties.author?.trim() || null;
            
            if (detected) {
                authorSettings.detectedAuthor = detected;
            }
            
            return detected;
        } catch (e) {
            console.warn("[Vibe] Could not read document author:", e);
            return null;
        }
    }

    // ==========================================
    // CONTEXT CACHING SYSTEM - Configuration
    // ==========================================

    const CACHE_CONFIG = {
        maxChangelogEntries: 10,
        maxChangelogChars: 5000,
        cacheTTL: 3600000,
        minCacheChars: 10000
    };

    interface ChangeEntry {
        type: "INSERT" | "MODIFY";
        description: string;
        content?: string;
        timestamp: Date;
    }

    interface CacheState {
        cacheId: string | null;
        createdAt: Date | null;
        changelog: ChangeEntry[];
    }

    let cacheState: CacheState = {
        cacheId: null,
        createdAt: null,
        changelog: []
    };

    function stripMarkdownFormatting(text: string): string {
        if (!text) return "";
        return text
            .replace(/\*\*(.+?)\*\*/g, "$1")
            .replace(/\*(.+?)\*/g, "$1")
            .replace(/__(.+?)__/g, "$1")
            .replace(/`(.+?)`/g, "$1")
            .replace(/^#+\s*/gm, "")
            .replace(/^[-*]\s+/gm, "")
            .replace(/\n\n+/g, "\n")
            .trim();
    }

    interface TextSpan {
        charStart: number;
        charEnd: number;
        textElement: Element;
        runElement: Element;
        paragraph: Element;
        container: Element;
        rPr: Element | null;
    }

    function applyRedlineToOxml(
        oxml: string,
        originalText: string,
        modifiedText: string
    ): { oxml: string; hasChanges: boolean } {
        const parser = new DOMParser();
        const serializer = new XMLSerializer();

        let xmlDoc;
        try {
            xmlDoc = parser.parseFromString(oxml, "text/xml");
        } catch (e) {
            console.error("[Engine] Failed to parse OXML:", e);
            return { oxml, hasChanges: false };
        }

        const cleanModifiedText = sanitizeAiResponse(modifiedText);

        if (cleanModifiedText.trim() === originalText.trim()) {
            return { oxml, hasChanges: false };
        }

        const tables = xmlDoc.getElementsByTagName("w:tbl");
        const hasTables = tables.length > 0;

        if (hasTables) {
            return applySurgicalMode(xmlDoc, originalText, cleanModifiedText, serializer);
        } else {
            return applyReconstructionMode(xmlDoc, originalText, cleanModifiedText, serializer);
        }
    }

    function applySurgicalMode(xmlDoc, originalText, modifiedText, serializer) {
        let fullText = "";
        const textSpans: TextSpan[] = [];

        const allParagraphs = Array.from(xmlDoc.getElementsByTagName("w:p"));

        allParagraphs.forEach((p: Element, pIndex) => {
            const container = p.parentNode as Element;

            Array.from(p.childNodes).forEach(child => {
                if (child.nodeName === "w:r") {
                    const r = child as Element;
                    const rPr = r.getElementsByTagName("w:rPr")[0] || null;
                    Array.from(r.childNodes).forEach(rc => {
                        if (rc.nodeName === "w:t") {
                            const t = rc as Element;
                            const text = t.textContent || "";
                            if (text.length > 0) {
                                textSpans.push({ charStart: fullText.length, charEnd: fullText.length + text.length, textElement: t, runElement: r, paragraph: p, container, rPr });
                                fullText += text;
                            }
                        }
                    });
                } else if (child.nodeName === "w:hyperlink") {
                    Array.from(child.childNodes).forEach(hc => {
                        if (hc.nodeName === "w:r") {
                            const r = hc as Element;
                            const rPr = r.getElementsByTagName("w:rPr")[0] || null;
                            Array.from(r.childNodes).forEach(rc => {
                                if (rc.nodeName === "w:t") {
                                    const t = rc as Element;
                                    const text = t.textContent || "";
                                    if (text.length > 0) {
                                        textSpans.push({ charStart: fullText.length, charEnd: fullText.length + text.length, textElement: t, runElement: r, paragraph: p, container, rPr });
                                        fullText += text;
                                    }
                                }
                            });
                        }
                    });
                }
            });
            if (pIndex < allParagraphs.length - 1) fullText += "\n";
        });

        const dmp = new diff_match_patch();
        const diffs = dmp.diff_main(fullText, modifiedText);
        dmp.diff_cleanupSemantic(diffs);

        let currentPos = 0;
        const processedSpans = new Set();

        for (const diff of diffs) {
            const [op, text] = diff;
            if (op === 0) {
                currentPos += text.length;
            } else if (op === -1) {
                processDelete(xmlDoc, textSpans, currentPos, currentPos + text.length, processedSpans);
                currentPos += text.length;
            } else if (op === 1) {
                const textWithoutNewlines = text.replace(/\n/g, ' ');
                if (textWithoutNewlines.trim().length > 0) {
                    processInsert(xmlDoc, textSpans, currentPos, textWithoutNewlines, processedSpans);
                }
            }
        }

        return { oxml: serializer.serializeToString(xmlDoc), hasChanges: true };
    }

    function processDelete(xmlDoc, textSpans, startPos, endPos, processedSpans) {
        const affectedSpans = textSpans.filter(s => s.charEnd > startPos && s.charStart < endPos);

        for (const span of affectedSpans) {
            if (processedSpans.has(span.textElement)) continue;

            const deleteStart = Math.max(0, startPos - span.charStart);
            const deleteEnd = Math.min(span.charEnd - span.charStart, endPos - span.charStart);

            const originalText = span.textElement.textContent || "";
            const beforeText = originalText.substring(0, deleteStart);
            const deletedText = originalText.substring(deleteStart, deleteEnd);
            const afterText = originalText.substring(deleteEnd);

            if (deletedText.length === 0) continue;

            const parent = span.runElement.parentNode;
            if (!parent) continue;

            if (beforeText.length === 0 && afterText.length === 0) {
                const delRun = createTextRun(xmlDoc, deletedText, span.rPr, true);
                const delWrapper = createTrackChange(xmlDoc, 'del', delRun);
                parent.insertBefore(delWrapper, span.runElement);
                parent.removeChild(span.runElement);
            } else {
                if (beforeText.length > 0) {
                    const beforeRun = createTextRun(xmlDoc, beforeText, span.rPr, false);
                    parent.insertBefore(beforeRun, span.runElement);
                }
                const delRun = createTextRun(xmlDoc, deletedText, span.rPr, true);
                const delWrapper = createTrackChange(xmlDoc, 'del', delRun);
                parent.insertBefore(delWrapper, span.runElement);
                if (afterText.length > 0) {
                    const afterRun = createTextRun(xmlDoc, afterText, span.rPr, false);
                    parent.insertBefore(afterRun, span.runElement);
                }
                parent.removeChild(span.runElement);
            }
            processedSpans.add(span.textElement);
        }
    }

    function processInsert(xmlDoc, textSpans, pos, text, processedSpans) {
        let targetSpan = textSpans.find(s => pos >= s.charStart && pos < s.charEnd);

        if (!targetSpan && pos > 0) {
            targetSpan = textSpans.find(s => pos === s.charEnd);
        }

        if (!targetSpan && pos > 0) {
            targetSpan = textSpans.find(s => s.charEnd <= pos);
            if (!targetSpan && textSpans.length > 0) {
                const before = textSpans.filter(s => s.charEnd <= pos);
                if (before.length > 0) {
                    targetSpan = before[before.length - 1];
                }
            }
        }

        if (!targetSpan && textSpans.length > 0) {
            targetSpan = textSpans[textSpans.length - 1];
        }

        if (targetSpan) {
            const rPr = targetSpan.rPr;
            const insRun = createTextRun(xmlDoc, text, rPr, false);
            const insWrapper = createTrackChange(xmlDoc, 'ins', insRun);
            const parent = targetSpan.runElement.parentNode;
            if (parent) parent.insertBefore(insWrapper, targetSpan.runElement.nextSibling);
        }
    }

    // RECONSTRUCTION MODE (Restored from Legacy Vibe 3.3 Stable)
    function applyReconstructionMode(xmlDoc, originalText, modifiedText, serializer) {
        const body = xmlDoc.getElementsByTagName("w:body")[0] || xmlDoc.documentElement;
        const paragraphs = Array.from(xmlDoc.getElementsByTagName("w:p"));

        if (paragraphs.length === 0) return { oxml: serializer.serializeToString(xmlDoc), hasChanges: false };

        let originalFullText = "";
        const propertyMap = [];
        const paragraphMap = [];
        const sentinelMap = [];
        const referenceMap = new Map();
        const tokenToCharMap = new Map();
        let nextCharCode = 0xe000;

        const uniqueContainers = new Set();
        const replacementContainers = new Map();

        paragraphs.forEach((p, pIndex) => {
            const pStart = originalFullText.length;
            const children = Array.from(p.childNodes);

            children.forEach((child) => {
                if (child.nodeName === "w:r") {
                    const r = child;
                    const rPr = r.getElementsByTagName("w:rPr")[0] || null;
                    const runChildren = Array.from(r.childNodes);

                    runChildren.forEach((rc) => {
                        if (rc.nodeName === "w:t") {
                            const textContent = rc.textContent || "";
                            if (textContent.length > 0) {
                                propertyMap.push({
                                    start: originalFullText.length,
                                    end: originalFullText.length + textContent.length,
                                    rPr: rPr,
                                });
                                originalFullText += textContent;
                            }
                        } else if (["w:drawing", "w:pict", "w:object", "w:fldChar", "w:instrText"].includes(rc.nodeName)) {
                            const rcElement = rc;
                            const txbxContent = rcElement.getElementsByTagName("w:txbxContent")[0];
                            const hasTextBox = rc.nodeName === "w:pict" && !!txbxContent;

                            if (hasTextBox) {
                                sentinelMap.push({
                                    start: originalFullText.length,
                                    node: rc,
                                    isTextBox: true,
                                    originalContainer: txbxContent,
                                });
                                originalFullText += "\uFFFC";
                                propertyMap.push({ start: originalFullText.length - 1, end: originalFullText.length, rPr: rPr });
                            } else {
                                sentinelMap.push({ start: originalFullText.length, node: rc });
                                originalFullText += "\uFFFC";
                                propertyMap.push({ start: originalFullText.length - 1, end: originalFullText.length, rPr: rPr });
                            }
                        } else if (rc.nodeName === "w:footnoteReference" || rc.nodeName === "w:endnoteReference") {
                            const ref = rc;
                            const id = ref.getAttribute("w:id");
                            if (id) {
                                const type = rc.nodeName === "w:footnoteReference" ? "FN" : "EN";
                                const tokenString = `{{__${type}_${id}__}}`;
                                const char = String.fromCharCode(nextCharCode++);
                                referenceMap.set(char, rc);
                                tokenToCharMap.set(tokenString, char);
                                originalFullText += char;
                                propertyMap.push({ start: originalFullText.length - 1, end: originalFullText.length, rPr: rPr });
                            }
                        }
                    });
                } else if (child.nodeName === "w:hyperlink") {
                    const h = child;
                    const hChildren = Array.from(h.childNodes);
                    hChildren.forEach((hc) => {
                        if (hc.nodeName === "w:r") {
                            const r = hc;
                            const rPr = r.getElementsByTagName("w:rPr")[0] || null;
                            const texts = Array.from(r.getElementsByTagName("w:t"));
                            texts.forEach((t) => {
                                const textContent = t.textContent || "";
                                if (textContent.length > 0) {
                                    propertyMap.push({
                                        start: originalFullText.length,
                                        end: originalFullText.length + textContent.length,
                                        rPr: rPr,
                                        wrapper: h,
                                    });
                                    originalFullText += textContent;
                                }
                            });
                        }
                    });
                } else if (["w:sdt", "w:oMath", "m:oMath", "w:bookmarkStart", "w:bookmarkEnd"].includes(child.nodeName)) {
                    sentinelMap.push({ start: originalFullText.length, node: child });
                    originalFullText += "\uFFFC";
                }
            });

            if (pIndex < paragraphs.length - 1) {
                originalFullText += "\n";
            }

            const pEnd = originalFullText.length;
            const pPr = p.getElementsByTagName("w:pPr")[0] || null;
            const container = p.parentNode;
            if (container) uniqueContainers.add(container);

            paragraphMap.push({
                start: pStart,
                end: pEnd,
                pPr: pPr,
                container: container || body,
            });
        });

        let processedModifiedText = modifiedText || "";

        tokenToCharMap.forEach((char, tokenString) => {
            const escapedToken = tokenString.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
            processedModifiedText = processedModifiedText.replace(new RegExp(escapedToken, "g"), char);
        });

        const dmp = new diff_match_patch();
        const diffs = dmp.diff_main(originalFullText, processedModifiedText);
        dmp.diff_cleanupSemantic(diffs);

        const containerFragments = new Map();
        uniqueContainers.forEach((c) => containerFragments.set(c, xmlDoc.createDocumentFragment()));
        if (!containerFragments.has(body)) containerFragments.set(body, xmlDoc.createDocumentFragment());

        const getParagraphInfo = (index) => {
            const match = paragraphMap.find((m) => index >= m.start && index < m.end);
            if (!match && paragraphMap.length > 0) {
                const last = paragraphMap[paragraphMap.length - 1];
                return { pPr: last.pPr, container: last.container };
            }
            return match ? { pPr: match.pPr, container: match.container } : { pPr: null, container: body };
        };

        const createNewParagraph = (pPr) => {
            const newP = xmlDoc.createElement("w:p");
            if (pPr) newP.appendChild(pPr.cloneNode(true));
            return newP;
        };

        let startInfo = getParagraphInfo(0);
        let currentParagraph = createNewParagraph(startInfo.pPr);
        let currentContainer = startInfo.container;
        let currentFragment = containerFragments.get(currentContainer);
        if (currentFragment) currentFragment.appendChild(currentParagraph);

        let currentOriginalIndex = 0;
        const usedReferenceTokens = new Set();

        const getRunProperties = (index) => {
            const match = propertyMap.find((m) => index >= m.start && index < m.end);
            return match ? { rPr: match.rPr, wrapper: match.wrapper } : { rPr: null };
        };

        const appendTextToCurrent = (text, type, rPr, wrapper, baseIndex) => {
            const parts = text.split(/([\n\uFFFC]|[\uE000-\uF8FF])/);
            let localOffset = 0;

            parts.forEach((part) => {
                if (part === "\n") {
                    if (type !== "delete") {
                        let pPr = null;
                        let targetContainer = currentContainer;

                        if (type === "equal") {
                            const lookupIndex = baseIndex + localOffset + 1;
                            const info = getParagraphInfo(lookupIndex);
                            pPr = info.pPr;
                            targetContainer = info.container;
                        } else {
                            const info = getParagraphInfo(baseIndex);
                            pPr = info.pPr;
                            targetContainer = info.container;
                        }

                        currentParagraph = createNewParagraph(pPr);
                        if (targetContainer !== currentContainer) {
                            currentContainer = targetContainer;
                            currentFragment = containerFragments.get(currentContainer);
                        }
                        if (currentFragment) currentFragment.appendChild(currentParagraph);
                    }
                    localOffset += 1;
                } else if (part === "\uFFFC") {
                    const sentinelIndex = baseIndex + localOffset;
                    const sentinel = sentinelMap.find((s) => s.start === sentinelIndex);

                    if (sentinel) {
                        const clone = sentinel.node.cloneNode(true);
                        if (sentinel.isTextBox && sentinel.originalContainer) {
                            const newContainer = clone.getElementsByTagName("w:txbxContent")[0];
                            if (newContainer) {
                                while (newContainer.firstChild) newContainer.removeChild(newContainer.firstChild);
                                replacementContainers.set(sentinel.originalContainer, newContainer);
                            }
                        }
                        if (sentinel.node.nodeName === "w:r" || sentinel.node.parentNode?.nodeName === "w:r") {
                            const run = xmlDoc.createElement("w:r");
                            if (rPr) run.appendChild(rPr.cloneNode(true));
                            run.appendChild(clone);
                            currentParagraph.appendChild(run);
                        } else {
                            currentParagraph.appendChild(clone);
                        }
                    }
                    localOffset += 1;
                } else if (referenceMap.has(part)) {
                    if (type !== "delete") {
                        const refNode = referenceMap.get(part);
                        if (refNode) {
                            const clone = refNode.cloneNode(true);
                            const run = xmlDoc.createElement("w:r");
                            if (rPr) run.appendChild(rPr.cloneNode(true));
                            run.appendChild(clone);
                            currentParagraph.appendChild(run);
                            let tokenString = "";
                            tokenToCharMap.forEach((c, t) => {
                                if (c === part) tokenString = t;
                            });
                            usedReferenceTokens.add(tokenString);
                        }
                    }
                    localOffset += part.length;
                } else if (part.length > 0) {
                    const run = xmlDoc.createElement("w:r");
                    if (rPr) run.appendChild(rPr.cloneNode(true));

                    let parent = currentParagraph;
                    if (wrapper) {
                        const wrapperClone = wrapper.cloneNode(false);
                        parent = wrapperClone;
                        currentParagraph.appendChild(wrapperClone);
                    }

                    const t = type === "delete" ? xmlDoc.createElement("w:delText") : xmlDoc.createElement("w:t");
                    t.setAttribute("xml:space", "preserve");
                    t.textContent = part;

                    run.appendChild(t);

                    if (type === "delete") {
                        const del = xmlDoc.createElement("w:del");
                        del.setAttribute("w:id", Math.floor(Math.random() * 10000).toString());
                        del.setAttribute("w:author", getTrackChangeAuthor());
                        del.setAttribute("w:date", new Date().toISOString());
                        del.appendChild(run);
                        parent.appendChild(del);
                    } else if (type === "insert") {
                        const ins = xmlDoc.createElement("w:ins");
                        ins.setAttribute("w:id", Math.floor(Math.random() * 10000).toString());
                        ins.setAttribute("w:author", getTrackChangeAuthor());
                        ins.setAttribute("w:date", new Date().toISOString());
                        ins.appendChild(run);
                        parent.appendChild(ins);
                    } else {
                        parent.appendChild(run);
                    }
                    localOffset += part.length;
                }
            });
        };

        for (const diff of diffs) {
            const [op, text] = diff;
            if (op === 0) {
                let offset = 0;
                while (offset < text.length) {
                    const props = getRunProperties(currentOriginalIndex + offset);
                    const currentPropRange = propertyMap.find(
                        (m) => currentOriginalIndex + offset >= m.start && currentOriginalIndex + offset < m.end,
                    );
                    let length = currentPropRange
                        ? Math.min(currentPropRange.end - (currentOriginalIndex + offset), text.length - offset)
                        : 1;
                    const chunk = text.substring(offset, offset + length);
                    appendTextToCurrent(chunk, "equal", props.rPr || null, props.wrapper, currentOriginalIndex + offset);
                    offset += length;
                }
                currentOriginalIndex += text.length;
            } else if (op === 1) {
                const isStartOfParagraph = paragraphMap.some((p) => p.start === currentOriginalIndex);
                const props =
                    currentOriginalIndex > 0 && !isStartOfParagraph
                        ? getRunProperties(currentOriginalIndex - 1)
                        : getRunProperties(currentOriginalIndex);
                appendTextToCurrent(text, "insert", props.rPr || null, props.wrapper, currentOriginalIndex);
            } else if (op === -1) {
                let offset = 0;
                while (offset < text.length) {
                    const props = getRunProperties(currentOriginalIndex + offset);
                    const currentPropRange = propertyMap.find(
                        (m) => currentOriginalIndex + offset >= m.start && currentOriginalIndex + offset < m.end,
                    );
                    let length = currentPropRange
                        ? Math.min(currentPropRange.end - (currentOriginalIndex + offset), text.length - offset)
                        : 1;
                    const chunk = text.substring(offset, offset + length);
                    appendTextToCurrent(chunk, "delete", props.rPr || null, props.wrapper, currentOriginalIndex + offset);
                    offset += length;
                }
                currentOriginalIndex += text.length;
            }
        }

        paragraphs.forEach((p) => {
            if (p.parentNode) p.parentNode.removeChild(p);
        });

        containerFragments.forEach((fragment, container) => {
            const replacement = replacementContainers.get(container);
            const target = replacement || container;
            target.appendChild(fragment);
        });

        return { oxml: serializer.serializeToString(xmlDoc), hasChanges: true };
    }

    function sanitizeAiResponse(text) {
        let cleaned = text;
        cleaned = cleaned.replace(/^(Here is the redline:|Here is the text:|Sure, I can help:|Here's the updated text:)\s*/i, "");
        cleaned = cleaned.replace(/\$\\text\{/g, "").replace(/\}\$/g, "");
        cleaned = cleaned.replace(/\$([^0-9\n]+?)\$/g, "$1");
        return cleaned;
    }

    // ==========================================
    // SELECTION TRACK CHANGES HANDLER
    // ==========================================

    async function getAcceptedSelectionText(context: Word.RequestContext): Promise<{ text: string; oxml: string }> {
        const selection = context.document.getSelection();
        const oxmlResult = selection.getOoxml();
        await context.sync();
        
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(oxmlResult.value, "text/xml");
        
        const deletions = xmlDoc.getElementsByTagName("w:del");
        while (deletions.length > 0) {
            deletions[0].parentNode?.removeChild(deletions[0]);
        }
        
        const delTexts = xmlDoc.getElementsByTagName("w:delText");
        while (delTexts.length > 0) {
            delTexts[0].parentNode?.removeChild(delTexts[0]);
        }
        
        const insertions = xmlDoc.getElementsByTagName("w:ins");
        while (insertions.length > 0) {
            const ins = insertions[0];
            const parent = ins.parentNode;
            while (ins.firstChild) {
                parent?.insertBefore(ins.firstChild, ins);
            }
            parent?.removeChild(ins);
        }
        
        const paragraphs = xmlDoc.getElementsByTagName("w:p");
        let acceptedText = "";
        
        for (let p = 0; p < paragraphs.length; p++) {
            const textElements = paragraphs[p].getElementsByTagName("w:t");
            let paragraphText = "";
            for (let t = 0; t < textElements.length; t++) {
                paragraphText += textElements[t].textContent || "";
            }
            if (paragraphText.length > 0) {
                acceptedText += paragraphText + "\n";
            }
        }
        
        return {
            text: acceptedText.trim(),
            oxml: oxmlResult.value
        };
    }

    // ==========================================
    // CONTEXT CACHING SYSTEM - Functions
    // ==========================================

    async function createGeminiCache(apiKey: string, model: string, fullDocumentText: string): Promise<string> {
        const cleanModel = (model || "gemini-2.0-flash-exp").replace(/^models\//, "");
        
        const url = `https://generativelanguage.googleapis.com/v1beta/cachedContents?key=${apiKey}`;
        
        const response = await fetch(url, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                model: `models/${cleanModel}`,
                displayName: `vibe-legal-${Date.now()}`,
                contents: [{
                    parts: [{ text: fullDocumentText }],
                    role: "user"
                }],
                systemInstruction: {
                    parts: [{ 
                        text: "You are Vibe Legal, an AI legal contract analyst. The document above is a legal contract loaded for your reference. Understand this document deeply: Identify the parties and their roles. Note all defined terms and their meanings. Understand liability caps, indemnities, and risk allocation. Recognize the document structure and clause organization. Note governing law and dispute resolution provisions. You will receive instructions with a CURRENT STRUCTURE MAP showing paragraph IDs. Always use those IDs for any location references - they reflect the live document state."
                    }]
                },
                ttl: `${CACHE_CONFIG.cacheTTL / 1000}s`
            })
        });
        
        if (!response.ok) {
            const error = await response.json();
            const errorMsg = error.error?.message || "Failed to create cache";
            console.error("[Vibe] Cache creation failed:", response.status, errorMsg);
            const lowerMsg = errorMsg.toLowerCase();
            if ((lowerMsg.includes("model") && lowerMsg.includes("not support")) ||
                lowerMsg.includes("does not support caching") ||
                lowerMsg.includes("cachedcontent is not supported")) {
                throw new Error("ModelDoesNotSupportCaching");
            }
            throw new Error(errorMsg);
        }
        
        const data = await response.json();
        return data.name;
    }

    async function deleteGeminiCache(apiKey: string, cacheId: string): Promise<void> {
        if (!cacheId) return;
        
        try {
            const url = `https://generativelanguage.googleapis.com/v1beta/${cacheId}?key=${apiKey}`;
            await fetch(url, { method: "DELETE" });
        } catch (e) {
            console.warn("[Vibe] Failed to delete cache:", e);
        }
    }

    function isCacheExpired(): boolean {
        if (!cacheState.createdAt) return true;
        return Date.now() - cacheState.createdAt.getTime() > CACHE_CONFIG.cacheTTL;
    }

    async function ensureCache(apiKey: string, model: string, fullDocumentText: string): Promise<{ cacheId: string | null; error?: string }> {
        // Claude doesn't support caching - always return null
        if (providerConfig.provider === "claude") {
            return { cacheId: null };
        }
        
        if (cacheState.cacheId && !isCacheExpired()) {
            return { cacheId: cacheState.cacheId };
        }
        
        if (fullDocumentText.length < CACHE_CONFIG.minCacheChars) {
            cacheState = { cacheId: null, createdAt: null, changelog: [] };
            return { cacheId: null };
        }
        
        try {
            const cacheId = await createGeminiCache(apiKey, model, fullDocumentText);
            cacheState = {
                cacheId,
                createdAt: new Date(),
                changelog: []
            };
            return { cacheId };
        } catch (e) {
            const errorMsg = (e as Error).message;
            
            if (errorMsg === "ModelDoesNotSupportCaching") {
                console.warn("[Vibe] Model does not support caching, using direct mode");
                cacheState = { cacheId: null, createdAt: null, changelog: [] };
                return { cacheId: null, error: "This model doesn't support caching. Using Direct Mode." };
            }
            
            if (errorMsg.toLowerCase().includes("too small")) {
                console.warn("[Vibe] Document too small for caching, using direct mode");
                cacheState = { cacheId: null, createdAt: null, changelog: [] };
                return { cacheId: null };
            }
            
            console.warn("[Vibe] Context caching unavailable:", errorMsg);
            cacheState = { cacheId: null, createdAt: null, changelog: [] };
            return { cacheId: null, error: `Cache failed: ${errorMsg}. Using Direct Mode.` };
        }
    }

    function logChange(type: "INSERT" | "MODIFY", description: string, content?: string): void {
        const entry: ChangeEntry = {
            type,
            description,
            content: content ? content.substring(0, 2000) : undefined,
            timestamp: new Date()
        };
        
        cacheState.changelog.push(entry);
    }

    function shouldRefreshCache(): boolean {
        if (cacheState.changelog.length >= CACHE_CONFIG.maxChangelogEntries) {
            return true;
        }
        
        const totalChars = cacheState.changelog.reduce(
            (sum, e) => sum + (e.content?.length || 0) + e.description.length, 
            0
        );
        
        return totalChars >= CACHE_CONFIG.maxChangelogChars;
    }

    async function refreshCache(apiKey: string, model: string, fullDocumentText: string): Promise<{ success: boolean; error?: string }> {
        // Claude doesn't support caching
        if (providerConfig.provider === "claude") {
            cacheState = { cacheId: null, createdAt: null, changelog: [] };
            return { success: true };
        }
        
        
        if (cacheState.cacheId) {
            await deleteGeminiCache(apiKey, cacheState.cacheId);
        }
        
        if (fullDocumentText.length < CACHE_CONFIG.minCacheChars) {
            cacheState = { cacheId: null, createdAt: null, changelog: [] };
            return { success: true };
        }
        
        try {
            const cacheId = await createGeminiCache(apiKey, model, fullDocumentText);
            cacheState = {
                cacheId,
                createdAt: new Date(),
                changelog: []
            };
            return { success: true };
        } catch (e) {
            const errorMsg = (e as Error).message;
            
            if (errorMsg === "ModelDoesNotSupportCaching") {
                console.warn("[Vibe] Model does not support caching");
                cacheState = { cacheId: null, createdAt: null, changelog: [] };
                return { success: false, error: "This model doesn't support caching. Using Direct Mode." };
            }
            
            if (errorMsg.toLowerCase().includes("too small")) {
                console.warn("[Vibe] Document too small for caching, using direct mode");
                cacheState = { cacheId: null, createdAt: null, changelog: [] };
                return { success: true };
            }
            
            console.warn("[Vibe] Cache refresh failed:", errorMsg);
            cacheState = { cacheId: null, createdAt: null, changelog: [] };
            return { success: false, error: `Cache failed: ${errorMsg}. Using Direct Mode.` };
        }
    }

    function buildChangelogSection(): string {
        if (cacheState.changelog.length === 0) {
            return "";
        }
        
        const entries = cacheState.changelog.map((c, i) => {
            const contentPreview = c.content ? ` Content: "${c.content.substring(0, 100)}..."` : "";
            return `[${i + 1}] ${c.type}: ${c.description}${contentPreview}`;
        }).join("\n");
        
        return "\nCHANGES SINCE CONTEXT WAS LOADED:\n" + entries + "\n\nIMPORTANT: The above changes are MORE RECENT than your cached knowledge. When these topics are relevant, trust this changelog over your cached memory.";
    }

    function getCacheStatus(): "loaded" | "loading" | "direct" {
        if (providerConfig.provider === "claude") return "direct";
        if (cacheState.cacheId && !isCacheExpired()) return "loaded";
        if (cacheState.cacheId === null && cacheState.createdAt === null) return "direct";
        return "loading";
    }

    // ==========================================
    // QUESTION DETECTION SYSTEM
    // ==========================================

    function isQuestionIntent(prompt: string): boolean {
        const p = prompt.trim();
        
        // FIRST: Check if it's clearly an ACTION request (takes priority over question patterns)
        // This prevents "Can you change..." from being classified as a question
        const actionPatterns = [
            // "Can you [action verb]..." patterns
            /^can you (change|modify|update|edit|fix|correct|amend|revise)/i,
            /^can you (add|insert|include|create|draft|write)/i,
            /^can you (delete|remove|strike|redline)/i,
            /^can you (make|convert|turn|transform)/i,
            /^can you (strengthen|weaken|soften|clarify)/i,
            
            // "Please [action]..." patterns
            /^(please\s+)?(change|modify|update|edit|fix|correct|amend|revise)\s/i,
            /^(please\s+)?(add|insert|include|create|draft|write)\s/i,
            /^(please\s+)?(delete|remove|strike)\s/i,
            /^(please\s+)?(make|convert|turn|transform)\s/i,
            
            // Direct action commands
            /^(change|modify|update|add|insert|delete|remove|make|set|put)\s/i,
            
            // Specific value changes (strong indicator of action)
            /\b(change|set|update|modify)\b.*\b(to|at)\s+(ny|new york|california|texas|delaware)/i,
            /\b(change|set|update|modify)\b.*\b(to|at)\s+\$[\d,]+/i,
            /\b(change|set|update|modify)\b.*\b(to|at)\s+\d+\s*(days?|years?|months?|weeks?)/i,
            
            // "Make this..." patterns (actions, not questions)
            /^make (this|it|the)/i,
        ];
        
        // If any action pattern matches, it's NOT a question
        if (actionPatterns.some(pattern => pattern.test(p))) {
            return false;
        }
        
        // THEN: Check question patterns (only if not an action)
        const questionPatterns = [
            // Interrogative words
            /^(what|who|where|when|why|how|which)\s/i,
            
            // Ends with question mark
            /\?$/,
            
            // Explanation requests
            /^(tell me|explain|describe|summarize|analyze|review|assess|evaluate|compare)/i,
            /^can you (explain|tell|describe|summarize|analyze|review|check|assess)/i,
            
            // "Is/Are/Does..." questions (but NOT "is this mutual" style requests)
            /^(is this|is it|are there|does this|does it)\s.*(balanced|fair|reasonable|risky|compliant|enforceable|valid)/i,
            
            // Assessment language
            /(balanced|fair|reasonable|standard|typical|unusual|risky|favorable|unfavorable)\?/i,
            /(compliant|enforceable|valid|binding)\?/i,
            
            // List/Find requests
            /^(find|show|list|identify|highlight|point out)\s.*(issues?|problems?|clauses?|terms?)/i,
            
            // "What are/is the..." patterns
            /(what are the|what is the|who is|who are)/i,
        ];
        
        return questionPatterns.some(pattern => pattern.test(p));
    }

    // ==========================================
    // HOLISTIC TRANSFORMATION DETECTION
    // ==========================================

    /**
     * Detects if a prompt requires holistic document transformation.
     * Holistic mode sends the entire document for rewriting to ensure
     * consistent terminology and coherent changes across all sections.
     */
    function isHolisticTransformation(prompt: string): boolean {
        const p = prompt.toLowerCase().trim();
        
        // Patterns that indicate holistic transformation needed
        const holisticPatterns = [
            // Mutual/reciprocal conversions
            /\b(make|convert|change|turn).*(mutual|reciprocal|two-way|bilateral)/i,
            /\b(mutual|reciprocal|two-way|bilateral)\b.*\b(nda|agreement|contract)\b/i,
            
            // Party/role transformations
            /\b(flip|swap|switch|reverse).*(parties|roles|sides)/i,
            /\b(change|convert).*(from|to).*(one-way|two-way)/i,
            /\b(disclos(er|ing)|recipient).*(to|into|become)/i,
            
            // Document type conversions
            /\b(convert|change|turn|transform).*(this|document|agreement).*(to|into|as)/i,
            /\b(restructure|rewrite|recast|remake)\b/i,
            
            // Fundamental nature changes
            /\b(make this|turn this into|convert this to)\s+\w+\s+(agreement|contract|nda)/i,
            /\b(change|modify)\s+the\s+(nature|type|structure)\b/i
        ];
        
        // Patterns that indicate surgical/targeted changes (NOT holistic)
        const surgicalPatterns = [
            /^(add|insert|include|create|draft)\s/i,
            /\b(clause|section|paragraph|provision)\s*(about|for|regarding)/i,
            /\b(liability|indemnity|cap|limit)\s*(to|at)\s*\$?\d/i,
            /^(delete|remove|strike)\s/i,
            /\b(section|paragraph|clause)\s*\d/i,
            /\b(change|modify|update)\s+(the|section|paragraph).*\s+(to|from)\s+\$/i
        ];
        
        const isHolistic = holisticPatterns.some(pattern => pattern.test(p));
        const isSurgical = surgicalPatterns.some(pattern => pattern.test(p));
        
        // Only use holistic mode if it matches holistic patterns and doesn't match surgical patterns
        const result = isHolistic && !isSurgical;
        
        if (result) {
        }
        
        return result;
    }

    // ==========================================
    // CONVERSATION CONTEXT SYSTEM
    // ==========================================

    interface ContextAnalysis {
        includeHistory: boolean;
        relevantEntries: ChangeEntry[];
        referenceType: "none" | "explicit" | "implicit";
    }

    function analyzePromptForReferences(prompt: string, changelog: ChangeEntry[]): ContextAnalysis {
        const explicitPatterns = [
            /same (thing|way|approach|treatment|wording|language)/i,
            /like (before|we did|the previous|earlier|last time)/i,
            /similar(ly)? to (what|how)/i,
            /do that (to|for|with)/i,
            /apply (that|this|the same) to/i,
            /repeat (that|this) for/i,
            /as we did (with|for|to)/i,
            /(also|too|as well)$/i
        ];
        
        const implicitPatterns = [
            /^(and|also|now)\s/i,
            /the other/i,
            /remaining/i,
            /rest of/i
        ];
        
        const hasExplicitReference = explicitPatterns.some(p => p.test(prompt));
        const hasImplicitReference = implicitPatterns.some(p => p.test(prompt));
        
        if (hasExplicitReference) {
            return {
                includeHistory: true,
                relevantEntries: changelog.slice(-3),
                referenceType: "explicit"
            };
        }
        
        if (hasImplicitReference && changelog.length > 0) {
            return {
                includeHistory: true,
                relevantEntries: changelog.slice(-1),
                referenceType: "implicit"
            };
        }
        
        return {
            includeHistory: false,
            relevantEntries: [],
            referenceType: "none"
        };
    }

    function buildContextSection(changelog: ChangeEntry[], analysis: ContextAnalysis): string {
        let completedSection = "";
        if (changelog.length > 0) {
            const completedList = changelog.map((c, i) => 
                `[${i + 1}] ${c.type}: ${c.description}`
            ).join("\n");
            
            completedSection = "COMPLETED CHANGES THIS SESSION:\n" + completedList + "\n";
        }
        
        let referenceSection = "";
        if (analysis.includeHistory && analysis.relevantEntries.length > 0) {
            if (analysis.referenceType === "explicit") {
                const details = analysis.relevantEntries.map(e => {
                    const contentPreview = e.content ? " Content: \"" + e.content.substring(0, 150) + "...\"" : "";
                    return "- " + e.type + " " + e.description + contentPreview;
                }).join("\n");
                
                referenceSection = "\nUSER IS REFERENCING PREVIOUS WORK. Relevant changes:\n" + details + "\n\nApply a similar approach to the current request.";
            } else {
                referenceSection = "\nPOSSIBLE REFERENCE to recent change: " + analysis.relevantEntries[0].description + "\nOnly apply if the user's request clearly relates to this.";
            }
        }
        
        const independenceNote = "\nIMPORTANT: Unless the user explicitly says \"same\", \"like before\", or similar:\n- Treat this request as INDEPENDENT\n- Do NOT apply previous $ amounts, caps, or specific wording to new clauses\n- Do NOT assume connections between different sections\n- The changelog shows what's DONE, not patterns to repeat";

        return completedSection + referenceSection + independenceNote;
    }

    // ==========================================
    // V10.0 DOCUMENT SNAPSHOT (AI-Driven Analysis)
    // ==========================================

    interface ParagraphSnapshot {
        id: number;
        text: string;
        styleId: string;
        token: string;
        fmt: {
            bold: boolean;
            allCaps: boolean;
            alignment: string;
        };
        list: {
            isListItem: boolean;
            level: number;
        };
    }

    interface DocumentSnapshot {
        paragraphs: ParagraphSnapshot[];
        totalParagraphs: number;
        lastParagraphId: number;
    }

    async function captureDocumentSnapshot(
        context: Word.RequestContext,
        paragraphs: Word.ParagraphCollection,
        styleCache: Map<string, StyleToken>
    ): Promise<DocumentSnapshot> {

        paragraphs.load("text, style, isListItem, alignment");
        await context.sync();

        for (let i = 0; i < paragraphs.items.length; i++) {
            const p = paragraphs.items[i];
            if (p.isListItem) {
                p.listItem.load("level");
            }
        }
        await context.sync();

        const totalParagraphs = paragraphs.items.length;
        const snapshotParagraphs: ParagraphSnapshot[] = [];

        const indicesToCapture = new Set<number>();

        for (let i = 0; i < Math.min(40, totalParagraphs); i++) {
            indicesToCapture.add(i);
        }

        for (let i = Math.max(0, totalParagraphs - 10); i < totalParagraphs; i++) {
            indicesToCapture.add(i);
        }

        const styleNameToToken = new Map<string, string>();
        styleCache.forEach((data, token) => {
            styleNameToToken.set(data.styleName, token);
        });

        for (const idx of Array.from(indicesToCapture).sort((a, b) => a - b)) {
            const p = paragraphs.items[idx];
            const text = (p.text || "").substring(0, 100).trim();
            const styleName = p.style || "Normal";
            const token = styleNameToToken.get(styleName) || "S1";

            const isAllCaps = text.length > 0 && text === text.toUpperCase() && /[A-Z]/.test(text);
            const hasBoldPattern = /^\*\*/.test(text) || /^\d+\.\s+[A-Z]/.test(text);

            let listLevel = 0;
            if (p.isListItem) {
                try {
                    listLevel = p.listItem.level || 0;
                } catch (e) {
                    listLevel = 0;
                }
            }

            snapshotParagraphs.push({
                id: idx + 1,
                text: text,
                styleId: styleName,
                token: token,
                fmt: {
                    bold: hasBoldPattern,
                    allCaps: isAllCaps,
                    alignment: p.alignment || "Left"
                },
                list: {
                    isListItem: p.isListItem || false,
                    level: listLevel
                }
            });
        }


        return {
            paragraphs: snapshotParagraphs,
            totalParagraphs: totalParagraphs,
            lastParagraphId: totalParagraphs
        };
    }

    // ==========================================
    // NETWORK LAYER - Model Fetching
    // ==========================================

    async function fetchModelsFromGoogle(apiKey: string): Promise<any[]> {
        const url = `https://generativelanguage.googleapis.com/v1beta/models?key=${apiKey}`;
        const response = await fetch(url);
        if (!response.ok) throw new Error("Failed to fetch models");
        const data = await response.json();
        
        const allModels = data.models || [];
        
        const textModels = allModels.filter((m: any) => 
            m.supportedGenerationMethods?.includes("generateContent")
        );
        
        const getVersion = (name: string): number => {
            const match = name.match(/gemini-(\d+\.?\d*)/i);
            return match ? parseFloat(match[1]) : 0;
        };
        
        const getTier = (name: string): number => {
            const lower = name.toLowerCase();
            if (lower.includes("pro")) return 3;
            if (lower.includes("flash")) return 2;
            return 1;
        };
        
        const getVariant = (name: string): number => {
            const lower = name.toLowerCase();
            if (lower.includes("latest")) return 4;
            if (lower.includes("002")) return 3;
            if (lower.includes("001")) return 2;
            if (lower.includes("exp")) return 1;
            return 0;
        };
        
        textModels.sort((a: any, b: any) => {
            const aName = a.name || "";
            const bName = b.name || "";
            
            const versionDiff = getVersion(bName) - getVersion(aName);
            if (versionDiff !== 0) return versionDiff;
            
            const tierDiff = getTier(bName) - getTier(aName);
            if (tierDiff !== 0) return tierDiff;
            
            return getVariant(bName) - getVariant(aName);
        });
        
        return textModels;
    }

    // ENHANCEMENT 2B: Claude Model Fetching
    async function fetchModelsFromAnthropic(apiKey: string): Promise<any[]> {
        const url = "https://api.anthropic.com/v1/models";
        const response = await fetch(url, {
            method: "GET",
            headers: {
                "x-api-key": apiKey,
                "anthropic-version": "2023-06-01",
                "anthropic-dangerous-direct-browser-access": "true"
            }
        });
        
        if (!response.ok) throw new Error("Failed to fetch Claude models");
        const data = await response.json();
        
        const models = data.data || [];
        
        // Sort by created_at descending (newest first)
        models.sort((a: any, b: any) => {
            const aDate = new Date(a.created_at || 0).getTime();
            const bDate = new Date(b.created_at || 0).getTime();
            return bDate - aDate;
        });
        
        // Transform to match Gemini format for UI compatibility
        return models.map((m: any) => ({
            name: m.id,
            displayName: m.display_name || m.id
        }));
    }

    // ==========================================
    // GEMINI API CALLS (with Structured Reasoning)
    // ==========================================

    // ENHANCEMENT 1A: Structured Reasoning for Router
    // ENHANCEMENT 3: Terminology-aware routing for complex transformations
    async function callGeminiRouter(
        apiKey: string, 
        model: string, 
        prompt: string, 
        styleMenu: string, 
        snapshot: DocumentSnapshot,
        cacheId: string | null,
        isComplexTransformation: boolean = false,
        fullDocumentText: string = ""
    ): Promise<any> {
        if (!apiKey) throw new Error("API Key missing.");
        const cleanModel = (model || "gemini-2.0-flash-exp").replace(/^models\//, "");
        const url = `https://generativelanguage.googleapis.com/v1beta/models/${cleanModel}:generateContent?key=${apiKey}`;

        const backtick = String.fromCharCode(96);
        const snapshotJSON = JSON.stringify(snapshot.paragraphs, null, 2);
        
        const contextAnalysis = analyzePromptForReferences(prompt, cacheState.changelog);
        const contextSection = buildContextSection(cacheState.changelog, contextAnalysis);
        
        const contextInstruction = cacheId 
            ? "You have the FULL CONTRACT loaded in your context. Use this deep knowledge to understand parties, defined terms, liability caps, cross-references, and document structure."
            : "Working in direct mode without cached context. Analyze based on the snapshot provided.";

        // ENHANCEMENT 1C: Self-check instruction for short documents
        const isShortDocument = snapshot.totalParagraphs < 20;
        const selfCheckInstruction = isShortDocument 
            ? "\n\n=== SELF-CHECK (Required for short documents) ===\nBefore finalizing your response, verify:\n1. Each action in the actions array directly maps to something in your change_plan\n2. No actions are included that weren't in your plan\n3. Your changes don't touch clauses that should remain unchanged\n4. Defined terms are used consistently"
            : "";

        // ENHANCEMENT 3: Complex transformation mode with full document and terminology
        let complexTransformationSection = "";
        let fullDocumentSection = "";
        
        if (isComplexTransformation && fullDocumentText) {
            
            fullDocumentSection = `
    === FULL DOCUMENT TEXT ===
    The complete document is provided below for context. Use this to ensure consistent terminology across ALL modifications.
    
    ${fullDocumentText}
    
    === END FULL DOCUMENT ===`;

            complexTransformationSection = `
    === COMPLEX TRANSFORMATION MODE ===
    This is a complex transformation (like "make mutual", "flip parties", "convert to bilateral").
    
    CRITICAL: Before listing actions, you MUST:
    
    1. DECIDE ON TERMINOLOGY and output it in a "terminology" field:
    {
        "terminology": {
            "transformation_type": "mutual_nda" | "party_swap" | "other",
            "notes": "Describe your approach (e.g., 'Converting one-way NDA to mutual. Both parties can be Disclosing Party or Receiving Party.')",
            "find_replace": [
                { "find": "Recipient", "replace": "Receiving Party", "context": "role-based term for party receiving info" },
                { "find": "Discloser", "replace": "Disclosing Party", "context": "role-based term for party sharing info" }
            ],
            "party_names": {
                "party_a": "Original company name that was Discloser",
                "party_b": "Original company name that was Recipient"
            }
        }
    }
    
    2. Make each MODIFY instruction EXPLICIT and SELF-CONTAINED:
       - DON'T say: "make this mutual" or "apply same changes"
       - DO say: "Replace 'Recipient' with 'Receiving Party'. Replace 'Discloser' with 'Disclosing Party'. Add 'Either party may be the Disclosing Party or Receiving Party under this Agreement.'"
       - Each instruction should work correctly INDEPENDENTLY, without needing to see other modifications
    
    3. Include COMPLETE find/replace instructions in EACH action's instruction field
       Example instruction: "Convert to mutual. In this paragraph: (1) Replace 'the Recipient' with 'the Receiving Party', (2) Replace 'the Discloser' with 'the Disclosing Party', (3) Change 'shall not disclose' to 'each Receiving Party shall not disclose'. Keep all other content unchanged."`;
        }

        // ENHANCEMENT 1A: Structured reasoning output format
        const systemInstruction = `SYSTEM: You are Vibe Legal, an intelligent legal document analyzer.

    === YOUR KNOWLEDGE ===
    ${contextInstruction}

    === SESSION CONTEXT ===
    ${contextSection}
    ${fullDocumentSection}
    ${complexTransformationSection}

    === STRUCTURED REASONING PROCESS ===
    
    Before generating actions, you MUST think through these steps in the "reasoning" field:

    1. TASK UNDERSTANDING: What exactly is being asked? What is explicitly OUT OF SCOPE and must NOT be changed?
    
    2. DOCUMENT ANALYSIS: What defined terms exist that relate to this task? Where are ALL relevant clauses?
    
    3. CHANGE PLAN: Create a numbered list of specific changes needed (and ONLY those changes)
    
    4. VERIFICATION: Confirm each action in the actions array maps to something in the change_plan

    === DOCUMENT ANALYSIS PROCESS ===

    STEP 1: IDENTIFY THE "MAIN CLAUSE" PATTERN
    Look at the SNAPSHOT paragraphs. Find patterns like "1. Term", "2. Payment", etc.
    Analyze:
    - Which styleId/token is used for these numbered clauses?
    - Are they Bold (fmt.bold = true)? All Caps (fmt.allCaps = true)?
    - Is the numbering manual (e.g. "1.", "2.") or from a Word list (list.isListItem = true)?

    STEP 2: IDENTIFY THE DOCUMENT STRUCTURE
    - "Block" style: Heading on its own paragraph, body on the next
    - "Inline" style: Heading and body combined with bold title

    STEP 3: GENERATE YOUR RESPONSE
    Apply the EXACT same style tokens and formatting to new content.

    === CURRENT DOCUMENT STRUCTURE ===
    Use these paragraph IDs for location_id. This is the LIVE state of the document.

    STYLE MENU (available styles with tokens):
    ${styleMenu}

    DOCUMENT SNAPSHOT (first 40 + last 10 paragraphs):
    ${snapshotJSON}

    TOTAL PARAGRAPHS: ${snapshot.totalParagraphs}
    LAST PARAGRAPH ID: ${snapshot.lastParagraphId}

    === OUTPUT FORMAT (JSON ONLY) ===
    Return ONLY valid JSON. No markdown. No code blocks (no ${backtick}${backtick}${backtick}).

    {
        "intent": "INSERT" | "MODIFY" | "HYBRID" | "ANSWER",
        "terminology": {
            "transformation_type": "mutual_nda | party_swap | other (ONLY for complex transformations)",
            "notes": "Describe the transformation approach",
            "find_replace": [{ "find": "old term", "replace": "new term" }]
        },
        "reasoning": {
            "task_understanding": "What exactly is being asked? What is OUT OF SCOPE?",
            "document_analysis": "What defined terms exist? Where are ALL relevant clauses?",
            "change_plan": ["1. First change...", "2. Second change..."],
            "verification": "Confirm: action 1 maps to change_plan item X, etc."
        },
        "analysis": {
            "clauseStyle": { "token": "S1", "styleId": "Normal", "isBold": true, "isAllCaps": false },
            "bodyStyle": { "token": "S1", "styleId": "Normal" },
            "structure": "inline" | "block",
            "lastClauseNumber": 5
        },
        "answer": "Optional explanation",
        "actions": [
            {
                "type": "INSERT",
                "location_id": <number>,
                "description": "Human-readable description of what is being inserted",
                "blocks": [{ "styleId": "<token>", "content": "**6. New Clause Title.** Body text here..." }]
            },
            {
                "type": "MODIFY",
                "target_id": <number>,
                "description": "Human-readable description of the change",
                "instruction": "What to change"
            }
        ]
    }

    === RULES ===

    RULE 0: ACTION VS ANSWER (CRITICAL)
    When the user asks to CHANGE, ADD, MODIFY, UPDATE, or REMOVE something:
    - You MUST output actions in the "actions" array
    - Do NOT just describe what you would do in the "answer" field
    - Do NOT output the change as text - generate actual MODIFY or INSERT actions
    
    Examples that REQUIRE actions (not just answers):
    - "Can you change this to NY?"  MODIFY action
    - "Change governing law to New York"  MODIFY action  
    - "Add a jurisdiction clause"  INSERT action
    - "Can you add arbitration?"  INSERT action
    - "Remove section 5"  MODIFY action with deletion
    
    Examples that are questions (answer only, no actions):
    - "What does this clause mean?"  Answer only
    - "Is this agreement balanced?"  Answer only
    - "Explain the confidentiality provisions"  Answer only
    
    If uncertain, DEFAULT TO GENERATING ACTIONS.

    RULE 1: STYLE MATCHING
    - Use the EXACT token from your analysis for clause titles and body text
    - If structure is "inline", combine title and body in ONE block with **bold** title
    - If structure is "block", use separate blocks for title and body

    RULE 2: INLINE FORMATTING
    - Use **text** for bold, *text* for italic
    - The engine converts these to proper OXML runs

    RULE 3: LOCATION SEMANTICS
    - location_id means "insert AFTER this paragraph ID"
    - To insert BEFORE paragraph 25, use location_id: 24
    - STANDARD CONTRACT ORDER: Definitions, Operative terms, Boilerplate, Governing Law, Signatures
    - BOILERPLATE (No Waiver, Severability, etc.) goes BEFORE Governing Law

    RULE 4: NUMBERING
    - Continue from the last clause number, match the format (1. vs 1) vs (1))

    RULE 5: INDEPENDENCE
    - Unless the user explicitly references previous work, treat this as a fresh request
    - Do not carry over specific values ($, dates, names) from previous changes to new clauses
    ${selfCheckInstruction}

    === CURRENT REQUEST ===
    ${prompt}`;

        const requestBody: any = {
            contents: [{ parts: [{ text: systemInstruction }] }],
            generationConfig: { responseMimeType: "application/json" }
        };
        
        if (cacheId) {
            requestBody.cachedContent = cacheId;
        }

        const response = await fetch(url, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(requestBody)
        });

        const data = await response.json();
        const text = data.candidates?.[0]?.content?.parts?.[0]?.text?.trim() || "{}";


        let result = tryParseJSON(text);

        if (!result) {
            console.warn("[Vibe] Router failed to parse JSON.");
            result = {
                intent: "ANSWER",
                answer: "I understood your request but had trouble processing the response. Please try again."
            };
        }

        if (result.reasoning) {
        }
        if (result.analysis) {
        }

        return result;
    }

    // Robust JSON Parser (The "JSON Shield")
    function tryParseJSON(str: string) {
        if (!str) return null;
        try {
            let cleanStr = str.replace(/```json\s*|\s*```/g, "").trim();
            return JSON.parse(cleanStr);
        } catch (e) {
            console.warn("[Vibe] Direct JSON parse failed. Engaging Shield Protocols...", e);

            try {
                const firstOpen = str.indexOf('{');
                const lastClose = str.lastIndexOf('}');

                if (firstOpen !== -1 && lastClose !== -1 && lastClose > firstOpen) {
                    let candidate = str.substring(firstOpen, lastClose + 1);
                    candidate = candidate.replace(/([{,]\s*)([a-zA-Z0-9_]+?)\s*:/g, '$1"$2":');
                    candidate = candidate.replace(/,\s*}/g, '}').replace(/,\s*]/g, ']');
                    return JSON.parse(candidate);
                }
            } catch (e2) {
                console.error("[Vibe] JSON Shield failed.", e2);
            }
            return null;
        }
    }

    // ENHANCEMENT 1B: Structured Reasoning for Redline
    async function callGeminiRedline(
        apiKey: string, 
        model: string, 
        instruction: string, 
        originalText: string,
        cacheId: string | null
    ): Promise<string> {
        const cleanModel = (model || "gemini-2.0-flash-exp").replace(/^models\//, "");
        const url = `https://generativelanguage.googleapis.com/v1beta/models/${cleanModel}:generateContent?key=${apiKey}`;

        const contextAnalysis = analyzePromptForReferences(instruction, cacheState.changelog);
        
        let contextNote = "";
        if (cacheId) {
            contextNote = "You have the full contract in context. Use this to ensure accurate cross-references (e.g., 'subject to Section 12' or 'as defined above').";
        }
        
        let referenceNote = "";
        if (contextAnalysis.includeHistory && contextAnalysis.relevantEntries.length > 0) {
            const lastChange = contextAnalysis.relevantEntries[0];
            referenceNote = "\nUser may be referencing recent change: " + lastChange.description;
        }

        // ENHANCEMENT 1B: Updated redline prompt with structured thinking
        const systemInstruction = `SYSTEM: You are a strict legal editor.
    ${contextNote}
    ${referenceNote}

    BEFORE MAKING CHANGES, THINK THROUGH:
    1. What specific change is requested? (State in one sentence)
    2. What should NOT be changed? (Be explicit)
    3. Make ONLY the requested change, nothing else.

    IMPORTANT: Apply ONLY what the instruction asks for. Do not carry over specific values from other clauses unless explicitly requested.

    Return ONLY the modified legal text. No markdown. No quotes. No LaTeX. No explanations. Preserve placeholders like [Name].
    
    The output must contain ONLY the modified text, nothing else.`;

        const fullPrompt = `ORIGINAL TEXT: "${originalText}"\n\nINSTRUCTION: ${instruction}`;

        const requestBody: any = {
            contents: [{ parts: [{ text: `${systemInstruction}\n\n${fullPrompt}` }] }]
        };
        
        if (cacheId) {
            requestBody.cachedContent = cacheId;
        }

        const response = await fetch(url, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            const errorMsg = errorData.error?.message || `HTTP ${response.status}`;
            console.error("[Vibe] Redline API Error:", response.status, errorMsg);
            console.error("[Vibe] Original text was:", originalText.substring(0, 100) + "...");
            throw new Error(`Redline Error: ${errorMsg}`);
        }
        const data = await response.json();
        return data.candidates?.[0]?.content?.parts?.[0]?.text?.trim() || originalText;
    }

    async function callGeminiQuestion(
        apiKey: string,
        model: string,
        question: string,
        currentDocumentText: string,
        changelog: ChangeEntry[],
        cacheId: string | null
    ): Promise<string> {
        const cleanModel = (model || "gemini-2.0-flash-exp").replace(/^models\//, "");
        const url = `https://generativelanguage.googleapis.com/v1beta/models/${cleanModel}:generateContent?key=${apiKey}`;
        
        const isShortDocument = currentDocumentText.length < CACHE_CONFIG.minCacheChars;
        
        let changeSection = "";
        if (changelog.length > 0) {
            const changes = changelog.map((c, i) => {
                const contentPreview = c.content 
                    ? "\nNew text: \"" + c.content.substring(0, 1000) + (c.content.length > 1000 ? "..." : "") + "\""
                    : "";
                return "[" + (i + 1) + "] " + c.type + ": " + c.description + contentPreview;
            }).join("\n\n");
            
            changeSection = "\n=== CHANGES MADE THIS SESSION ===\nThe following changes have been applied (shown as track changes in Word):\n\n" + changes + "\n\nIMPORTANT: These changes are now part of the document. Answer based on the CURRENT state.\n";
        }
        
        let systemPrompt: string;
        
        if (isShortDocument) {
            
            systemPrompt = "You are Vibe Legal, a legal document analyst.\n\n=== CURRENT DOCUMENT (FULL TEXT) ===\n" + currentDocumentText + "\n" + changeSection + "\n=== INSTRUCTIONS ===\nAnswer the user's question based on the document above.\nThis is the CURRENT state of the document with all changes applied.\nBe specific and reference actual clauses or language.\n\nUSER QUESTION: " + question;
        } else {
            
            const contextNote = cacheId
                ? "You have the full contract loaded in your context from when the session started."
                : "Note: Document context not cached. Working with changelog only.";
            
            const criticalInstruction = changelog.length > 0 
                ? "Changes have been made this session. Your cached knowledge may be OUTDATED for the modified sections.\nTrust the changelog above for any topics that were changed.\nFor example, if the changelog shows confidentiality was changed from one-way to mutual,\nthe document is NOW mutual - do not rely on your cached memory of it being one-way."
                : "No changes have been made this session. Your cached knowledge is current.";
            
            systemPrompt = "You are Vibe Legal, a legal document analyst.\n\n=== YOUR KNOWLEDGE ===\n" + contextNote + "\n" + changeSection + "\n=== CRITICAL INSTRUCTION ===\n" + criticalInstruction + "\n\nAnswer the user's question based on the CURRENT state of the document.\nBe specific and reference actual clauses or language.\n\nUSER QUESTION: " + question;
        }
        
        const requestBody: any = {
            contents: [{ parts: [{ text: systemPrompt }] }]
        };
        
        if (!isShortDocument && cacheId) {
            requestBody.cachedContent = cacheId;
        }
        
        const response = await fetch(url, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(requestBody)
        });
        
        if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(errorData.error?.message || "HTTP " + response.status);
        }
        
        const data = await response.json();
        return data.candidates?.[0]?.content?.parts?.[0]?.text?.trim() || "I couldn't analyze the document.";
    }

    // ==========================================
    // CLAUDE API CALLS (ENHANCEMENT 2C)
    // ==========================================

    async function callClaudeRouter(
        apiKey: string, 
        model: string, 
        prompt: string, 
        styleMenu: string, 
        snapshot: DocumentSnapshot,
        cacheId: string | null,  // Always null for Claude
        isComplexTransformation: boolean = false,
        fullDocumentText: string = ""
    ): Promise<any> {
        if (!apiKey) throw new Error("API Key missing.");

        const backtick = String.fromCharCode(96);
        const snapshotJSON = JSON.stringify(snapshot.paragraphs, null, 2);
        
        const contextAnalysis = analyzePromptForReferences(prompt, cacheState.changelog);
        const contextSection = buildContextSection(cacheState.changelog, contextAnalysis);

        const isShortDocument = snapshot.totalParagraphs < 20;
        const selfCheckInstruction = isShortDocument 
            ? "\n\n=== SELF-CHECK (Required for short documents) ===\nBefore finalizing your response, verify:\n1. Each action in the actions array directly maps to something in your change_plan\n2. No actions are included that weren't in your plan\n3. Your changes don't touch clauses that should remain unchanged\n4. Defined terms are used consistently"
            : "";

        // ENHANCEMENT 3: Complex transformation mode with full document and terminology
        let complexTransformationSection = "";
        let fullDocumentSection = "";
        
        if (isComplexTransformation && fullDocumentText) {
            
            fullDocumentSection = `
    === FULL DOCUMENT TEXT ===
    ${fullDocumentText}
    === END FULL DOCUMENT ===`;

            complexTransformationSection = `
    === COMPLEX TRANSFORMATION MODE ===
    This is a complex transformation. Before listing actions:
    1. Output a "terminology" field with find/replace mappings
    2. Make each MODIFY instruction EXPLICIT and SELF-CONTAINED
    3. Don't say "make mutual" - say exactly what to find and replace in each paragraph`;
        }

        const systemInstruction = `You are Vibe Legal, an intelligent legal document analyzer.

    === SESSION CONTEXT ===
    ${contextSection}
    ${fullDocumentSection}
    ${complexTransformationSection}

    === STRUCTURED REASONING PROCESS ===

    Before generating actions, you MUST think through these steps in the "reasoning" field:

    1. TASK UNDERSTANDING: What exactly is being asked? What is explicitly OUT OF SCOPE and must NOT be changed?

    2. DOCUMENT ANALYSIS: What defined terms exist that relate to this task? Where are ALL relevant clauses?

    3. CHANGE PLAN: Create a numbered list of specific changes needed (and ONLY those changes)

    4. VERIFICATION: Confirm each action in the actions array maps to something in the change_plan

    === DOCUMENT ANALYSIS PROCESS ===

    STEP 1: IDENTIFY THE "MAIN CLAUSE" PATTERN
    Look at the SNAPSHOT paragraphs. Find patterns like "1. Term", "2. Payment", etc.

    STEP 2: IDENTIFY THE DOCUMENT STRUCTURE
    - "Block" style: Heading on its own paragraph, body on the next
    - "Inline" style: Heading and body combined with bold title

    STEP 3: GENERATE YOUR RESPONSE
    Apply the EXACT same style tokens and formatting to new content.

    === CURRENT DOCUMENT STRUCTURE ===

    STYLE MENU (available styles with tokens):
    ${styleMenu}

    DOCUMENT SNAPSHOT (first 40 + last 10 paragraphs):
    ${snapshotJSON}

    TOTAL PARAGRAPHS: ${snapshot.totalParagraphs}
    LAST PARAGRAPH ID: ${snapshot.lastParagraphId}

    === OUTPUT FORMAT ===
    Respond with valid JSON only. No markdown code blocks.

    {
    "intent": "INSERT" | "MODIFY" | "HYBRID" | "ANSWER",
    "reasoning": {
        "task_understanding": "What exactly is being asked? What is OUT OF SCOPE?",
        "document_analysis": "What defined terms exist? Where are ALL relevant clauses?",
        "change_plan": ["1. First change...", "2. Second change..."],
        "verification": "Confirm: action 1 maps to change_plan item X, etc."
    },
    "analysis": {
        "clauseStyle": { "token": "S1", "styleId": "Normal", "isBold": true, "isAllCaps": false },
        "bodyStyle": { "token": "S1", "styleId": "Normal" },
        "structure": "inline" | "block",
        "lastClauseNumber": 5
    },
    "answer": "Optional explanation",
    "actions": [
        {
            "type": "INSERT",
            "location_id": <number>,
            "description": "Human-readable description",
            "blocks": [{ "styleId": "<token>", "content": "**6. New Clause Title.** Body text here..." }]
        },
        {
            "type": "MODIFY",
            "target_id": <number>,
            "description": "Human-readable description",
            "instruction": "What to change"
        }
    ]
    }

    === RULES ===

    RULE 0: ACTION VS ANSWER (CRITICAL)
    When the user asks to CHANGE, ADD, MODIFY, UPDATE, or REMOVE something:
    - You MUST output actions in the "actions" array
    - Do NOT just describe what you would do in the "answer" field  
    - Generate actual MODIFY or INSERT actions
    
    If uncertain whether it's an action or question, DEFAULT TO GENERATING ACTIONS.

    RULE 1: Use the EXACT token from your analysis for clause titles and body text
    RULE 2: Use **text** for bold, *text* for italic
    RULE 3: location_id means "insert AFTER this paragraph ID"
    RULE 4: Continue from the last clause number, match the format
    RULE 5: Unless the user explicitly references previous work, treat this as a fresh request
    ${selfCheckInstruction}

    === CURRENT REQUEST ===
    ${prompt}`;

        const response = await fetch("https://api.anthropic.com/v1/messages", {
            method: "POST",
            headers: {
                "x-api-key": apiKey,
                "anthropic-version": "2023-06-01",
                "anthropic-dangerous-direct-browser-access": "true",
                "content-type": "application/json"
            },
            body: JSON.stringify({
                model: model || "claude-sonnet-4-20250514",
                max_tokens: 8192,
                messages: [{ role: "user", content: systemInstruction }]
            })
        });

        if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(errorData.error?.message || `HTTP ${response.status}`);
        }

        const data = await response.json();
        const text = data.content?.[0]?.text?.trim() || "{}";


        let result = tryParseJSON(text);

        if (!result) {
            console.warn("[Vibe] Claude Router failed to parse JSON.");
            result = {
                intent: "ANSWER",
                answer: "I understood your request but had trouble processing the response. Please try again."
            };
        }

        if (result.reasoning) {
        }

        return result;
    }

    async function callClaudeRedline(
        apiKey: string, 
        model: string, 
        instruction: string, 
        originalText: string,
        cacheId: string | null  // Always null for Claude
    ): Promise<string> {
        const contextAnalysis = analyzePromptForReferences(instruction, cacheState.changelog);
        
        let referenceNote = "";
        if (contextAnalysis.includeHistory && contextAnalysis.relevantEntries.length > 0) {
            const lastChange = contextAnalysis.relevantEntries[0];
            referenceNote = "\nUser may be referencing recent change: " + lastChange.description;
        }

        const systemInstruction = `You are a strict legal editor.
    ${referenceNote}

    BEFORE MAKING CHANGES, THINK THROUGH:
    1. What specific change is requested? (State in one sentence)
    2. What should NOT be changed? (Be explicit)
    3. Make ONLY the requested change, nothing else.

    IMPORTANT: Apply ONLY what the instruction asks for. Do not carry over specific values from other clauses unless explicitly requested.

    Return ONLY the modified legal text. No markdown. No quotes. No LaTeX. No explanations. Preserve placeholders like [Name].

    The output must contain ONLY the modified text, nothing else.

    ORIGINAL TEXT: "${originalText}"

    INSTRUCTION: ${instruction}`;

        const response = await fetch("https://api.anthropic.com/v1/messages", {
            method: "POST",
            headers: {
                "x-api-key": apiKey,
                "anthropic-version": "2023-06-01",
                "anthropic-dangerous-direct-browser-access": "true",
                "content-type": "application/json"
            },
            body: JSON.stringify({
                model: model || "claude-sonnet-4-20250514",
                max_tokens: 4096,
                messages: [{ role: "user", content: systemInstruction }]
            })
        });

        if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            const errorMsg = errorData.error?.message || `HTTP ${response.status}`;
            console.error("[Vibe] Claude Redline API Error:", response.status, errorMsg);
            throw new Error(`Redline Error: ${errorMsg}`);
        }
        
        const data = await response.json();
        return data.content?.[0]?.text?.trim() || originalText;
    }

    async function callClaudeQuestion(
        apiKey: string,
        model: string,
        question: string,
        currentDocumentText: string,
        changelog: ChangeEntry[],
        cacheId: string | null  // Always null for Claude
    ): Promise<string> {
        const isShortDocument = currentDocumentText.length < CACHE_CONFIG.minCacheChars;
        
        let changeSection = "";
        if (changelog.length > 0) {
            const changes = changelog.map((c, i) => {
                const contentPreview = c.content 
                    ? "\nNew text: \"" + c.content.substring(0, 1000) + (c.content.length > 1000 ? "..." : "") + "\""
                    : "";
                return "[" + (i + 1) + "] " + c.type + ": " + c.description + contentPreview;
            }).join("\n\n");
            
            changeSection = "\n=== CHANGES MADE THIS SESSION ===\n" + changes + "\n\nIMPORTANT: These changes are now part of the document. Answer based on the CURRENT state.\n";
        }
        
        let systemPrompt: string;
        
        if (isShortDocument) {
            systemPrompt = "You are Vibe Legal, a legal document analyst.\n\n=== CURRENT DOCUMENT (FULL TEXT) ===\n" + currentDocumentText + "\n" + changeSection + "\n=== INSTRUCTIONS ===\nAnswer the user's question based on the document above.\nBe specific and reference actual clauses or language.\n\nUSER QUESTION: " + question;
        } else {
            // For long documents without cache, send a truncated version
            const truncatedDoc = currentDocumentText.substring(0, 50000) + (currentDocumentText.length > 50000 ? "\n...[document truncated]..." : "");
            systemPrompt = "You are Vibe Legal, a legal document analyst.\n\n=== DOCUMENT EXCERPT ===\n" + truncatedDoc + "\n" + changeSection + "\n=== INSTRUCTIONS ===\nAnswer the user's question based on the document.\nBe specific and reference actual clauses or language.\n\nUSER QUESTION: " + question;
        }
        
        const response = await fetch("https://api.anthropic.com/v1/messages", {
            method: "POST",
            headers: {
                "x-api-key": apiKey,
                "anthropic-version": "2023-06-01",
                "anthropic-dangerous-direct-browser-access": "true",
                "content-type": "application/json"
            },
            body: JSON.stringify({
                model: model || "claude-sonnet-4-20250514",
                max_tokens: 4096,
                messages: [{ role: "user", content: systemPrompt }]
            })
        });
        
        if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(errorData.error?.message || "HTTP " + response.status);
        }
        
        const data = await response.json();
        return data.content?.[0]?.text?.trim() || "I couldn't analyze the document.";
    }

    // ==========================================
    // UNIFIED API DISPATCHER (ENHANCEMENT 2D)
    // ==========================================

    async function callRouter(
        prompt: string, 
        styleMenu: string, 
        snapshot: DocumentSnapshot,
        cacheId: string | null,
        isComplexTransformation: boolean = false,
        fullDocumentText: string = ""
    ): Promise<any> {
        const apiKey = getCurrentApiKey();
        const model = getCurrentModel();
        
        if (providerConfig.provider === "claude") {
            return callClaudeRouter(apiKey, model, prompt, styleMenu, snapshot, null, isComplexTransformation, fullDocumentText);
        } else {
            return callGeminiRouter(apiKey, model, prompt, styleMenu, snapshot, cacheId, isComplexTransformation, fullDocumentText);
        }
    }

    async function callRedline(
        instruction: string, 
        originalText: string,
        cacheId: string | null
    ): Promise<string> {
        const apiKey = getCurrentApiKey();
        const model = getCurrentModel();
        
        if (providerConfig.provider === "claude") {
            return callClaudeRedline(apiKey, model, instruction, originalText, null);
        } else {
            return callGeminiRedline(apiKey, model, instruction, originalText, cacheId);
        }
    }

    async function callQuestion(
        question: string,
        currentDocumentText: string,
        changelog: ChangeEntry[],
        cacheId: string | null
    ): Promise<string> {
        const apiKey = getCurrentApiKey();
        const model = getCurrentModel();
        
        if (providerConfig.provider === "claude") {
            return callClaudeQuestion(apiKey, model, question, currentDocumentText, changelog, null);
        } else {
            return callGeminiQuestion(apiKey, model, question, currentDocumentText, changelog, cacheId);
        }
    }

    // ==========================================
    // V8.0 COMPILER PATTERN (Tag-Based Abstraction)
    // ==========================================

    interface StyleToken {
        token: string;
        styleId: string;
        styleName: string;
    }

    async function generateStyleMenuAndCache(context: Word.RequestContext, paragraphs: Word.ParagraphCollection): Promise<{ styleCache: Map<string, StyleToken>, menu: string }> {

        paragraphs.load("text, style, styleId");
        await context.sync();

        for (let i = 0; i < Math.min(5, paragraphs.items.length); i++) {
            const p = paragraphs.items[i];
        }

        const styleCache = new Map<string, StyleToken>();
        const menuLines = [];
        const seenStyles = new Map<string, { styleName: string, index: number }>();

        for (let i = 0; i < paragraphs.items.length; i++) {
            const p = paragraphs.items[i];
            const styleName = p.style || "Normal";

            if (!seenStyles.has(styleName) && styleName) {
                seenStyles.set(styleName, { styleName, index: i });
            }
        }

        const standardStyles = [
            { id: "Normal", name: "Normal" },
            { id: "Heading 1", name: "Heading 1" },
            { id: "Heading 2", name: "Heading 2" },
            { id: "Heading 3", name: "Heading 3" }
        ];

        standardStyles.forEach(style => {
            if (!seenStyles.has(style.id)) {
                seenStyles.set(style.id, { styleName: style.name, index: -1 });
            }
        });

        const styleNames = Array.from(seenStyles.keys());
        let tokenCount = 1;

        for (const styleName of styleNames) {
            const info = seenStyles.get(styleName);
            const token = `S${tokenCount++}`;

            styleCache.set(token, {
                token,
                styleId: styleName,
                styleName: styleName
            });

            let category = "BODY";
            const sLower = styleName.toLowerCase();
            if (sLower.includes("heading") || sLower.includes("title")) category = "HEADING";
            else if (sLower.includes("list") || sLower.includes("number")) category = "LIST";

            let sample = "Standard Style";
            if (info.index >= 0) {
                const p = paragraphs.items[info.index];
                try { sample = (p.text || "").substring(0, 30).replace(/\n/g, " "); } catch (e) {}
            }

            const menuObj = { id: token, name: styleName, type: category, sample: sample };
            menuLines.push(JSON.stringify(menuObj));
        }

        return { styleCache, menu: menuLines.join("\n") };
    }

    interface TextSegment {
        text: string;
        bold: boolean;
        italic: boolean;
    }

    function parseMarkdownToSegments(content: string): TextSegment[] {
        const segments: TextSegment[] = [];
        const regex = /(\*\*(.+?)\*\*)|(\*([^*]+?)\*)|([^*]+)/g;
        let match;

        while ((match = regex.exec(content)) !== null) {
            if (match[2]) {
                segments.push({ text: match[2], bold: true, italic: false });
            } else if (match[4]) {
                segments.push({ text: match[4], bold: false, italic: true });
            } else if (match[5]) {
                segments.push({ text: match[5], bold: false, italic: false });
            }
        }

        return segments.length > 0 ? segments : [{ text: content, bold: false, italic: false }];
    }

    function createFormattedRuns(xmlDoc: Document, segments: TextSegment[], WORD_NS: string): Element[] {
        const runs: Element[] = [];

        for (const seg of segments) {
            if (!seg.text || seg.text.length === 0) continue;

            const run = xmlDoc.createElementNS(WORD_NS, "w:r");

            if (seg.bold || seg.italic) {
                const rPr = xmlDoc.createElementNS(WORD_NS, "w:rPr");
                if (seg.bold) {
                    const b = xmlDoc.createElementNS(WORD_NS, "w:b");
                    rPr.appendChild(b);
                }
                if (seg.italic) {
                    const i = xmlDoc.createElementNS(WORD_NS, "w:i");
                    rPr.appendChild(i);
                }
                run.appendChild(rPr);
            }

            const t = xmlDoc.createElementNS(WORD_NS, "w:t");
            t.setAttribute("xml:space", "preserve");
            t.textContent = seg.text;
            run.appendChild(t);

            runs.push(run);
        }

        return runs;
    }

    async function insertBlocks(context: Word.RequestContext, blocks: any[], styleCache: Map<string, StyleToken>, insertLocation: Word.Paragraph, analysis?: any) {

        let lastInsert = insertLocation;
        let insertedCount = 0;

        const parser = new DOMParser();
        const serializer = new XMLSerializer();
        const WORD_NS = "http://schemas.openxmlformats.org/wordprocessingml/2006/main";

        context.trackedObjects.add(lastInsert);
        
        const insertLocationOxmlResult = insertLocation.getOoxml();
        await context.sync();
        
        let docRFonts: Node | null = null;
        let docSz: Node | null = null;
        let docSzCs: Node | null = null;
        
        try {
            const locationXml = parser.parseFromString(insertLocationOxmlResult.value, "text/xml");
            const locationRuns = locationXml.getElementsByTagNameNS(WORD_NS, "r");
            if (locationRuns.length > 0) {
                const firstRun = locationRuns[0] as Element;
                const rPr = firstRun.getElementsByTagNameNS(WORD_NS, "rPr")[0];
                if (rPr) {
                    docRFonts = rPr.getElementsByTagNameNS(WORD_NS, "rFonts")[0] || null;
                    docSz = rPr.getElementsByTagNameNS(WORD_NS, "sz")[0] || null;
                    docSzCs = rPr.getElementsByTagNameNS(WORD_NS, "szCs")[0] || null;
                    if (docRFonts) {
                    }
                }
            }
        } catch (e) {
            console.warn("[Vibe] Could not extract font from insertion location:", e);
        }

        const insertedParagraphs: Word.Paragraph[] = [];
        const blockMetadata: { styleToken: string, content: string, originalContent: string }[] = [];

        for (const block of blocks) {
            const styleToken = block.styleId;
            const content = block.content;

            if (!content) continue;

            const tokenData = styleCache.get(styleToken);
            const targetStyleName = tokenData ? tokenData.styleName : "Normal";
            const cleanContent = stripMarkdownFormatting(content);

            const newP = lastInsert.insertParagraph(cleanContent, "After");
            newP.style = targetStyleName;

            context.trackedObjects.add(newP);
            insertedParagraphs.push(newP);
            blockMetadata.push({ styleToken, content: cleanContent, originalContent: content });

            lastInsert = newP;
            insertedCount++;
        }

        await context.sync();

        const oxmlResults: OfficeExtension.ClientResult<string>[] = [];
        for (const p of insertedParagraphs) {
            oxmlResults.push(p.getOoxml());
        }

        await context.sync();

        for (let i = 0; i < insertedParagraphs.length; i++) {
            const p = insertedParagraphs[i];
            const originalOxml = oxmlResults[i].value;
            const meta = blockMetadata[i];

            try {
                const insId = Math.floor(Math.random() * 10000000).toString();
                const date = new Date().toISOString();

                const xmlDoc = parser.parseFromString(originalOxml, "text/xml");
                const pNode = xmlDoc.getElementsByTagNameNS(WORD_NS, "p")[0] || xmlDoc.getElementsByTagName("w:p")[0];

                if (pNode) {
                    let pPr = pNode.getElementsByTagNameNS(WORD_NS, "pPr")[0] || pNode.getElementsByTagName("w:pPr")[0];

                    if (!pPr && meta.styleToken) {
                        const tokenData = styleCache.get(meta.styleToken);
                        if (tokenData && tokenData.styleId !== "Normal") {
                            pPr = xmlDoc.createElementNS(WORD_NS, "w:pPr");
                            const pStyle = xmlDoc.createElementNS(WORD_NS, "w:pStyle");
                            pStyle.setAttribute("w:val", tokenData.styleId);
                            pPr.appendChild(pStyle);

                            if (pNode.firstChild) {
                                pNode.insertBefore(pPr, pNode.firstChild);
                            } else {
                                pNode.appendChild(pPr);
                            }
                        }
                    }

                    if (pPr) {
                        const pPr_rPr = pPr.getElementsByTagNameNS(WORD_NS, "rPr")[0] || pPr.getElementsByTagName("w:rPr")[0];
                        if (pPr_rPr) {
                            const rFonts = pPr_rPr.getElementsByTagNameNS(WORD_NS, "rFonts")[0] || pPr_rPr.getElementsByTagName("w:rFonts")[0];
                            if (rFonts) {
                                pPr_rPr.removeChild(rFonts);
                            }
                        }
                    }


                    const existingRuns = Array.from(pNode.childNodes).filter(n => 
                        n.localName === "r" || n.nodeName.endsWith(":r")
                    );
                    existingRuns.forEach(run => pNode.removeChild(run));

                    const segments = parseMarkdownToSegments(meta.originalContent);
                    const formattedRuns = createFormattedRuns(xmlDoc, segments, WORD_NS);

                    if (docRFonts || docSz) {
                        formattedRuns.forEach(run => {
                            let rPr = run.getElementsByTagNameNS(WORD_NS, "rPr")[0] as Element;
                            if (!rPr) {
                                rPr = xmlDoc.createElementNS(WORD_NS, "w:rPr");
                                run.insertBefore(rPr, run.firstChild);
                            }
                            if (docRFonts && !rPr.getElementsByTagNameNS(WORD_NS, "rFonts")[0]) {
                                rPr.insertBefore(docRFonts.cloneNode(true), rPr.firstChild);
                            }
                            if (docSz && !rPr.getElementsByTagNameNS(WORD_NS, "sz")[0]) {
                                rPr.appendChild(docSz.cloneNode(true));
                            }
                            if (docSzCs && !rPr.getElementsByTagNameNS(WORD_NS, "szCs")[0]) {
                                rPr.appendChild(docSzCs.cloneNode(true));
                            }
                        });
                    }

                    const isFirstBlock = (i === 0);
                    const shouldForceBold = isFirstBlock && analysis?.clauseStyle?.isBold && !meta.originalContent.includes('**');

                    if (shouldForceBold) {
                        formattedRuns.forEach(run => {
                            let rPr = run.getElementsByTagNameNS(WORD_NS, "rPr")[0] as Element;
                            if (!rPr) {
                                rPr = xmlDoc.createElementNS(WORD_NS, "w:rPr");
                                run.insertBefore(rPr, run.firstChild);
                            }
                            if (!rPr.getElementsByTagNameNS(WORD_NS, "b")[0]) {
                                const b = xmlDoc.createElementNS(WORD_NS, "w:b");
                                rPr.appendChild(b);
                            }
                        });
                    }

                    const insNode = xmlDoc.createElementNS(WORD_NS, "w:ins");
                    insNode.setAttribute("w:id", insId);
                    insNode.setAttribute("w:author", getTrackChangeAuthor());
                    insNode.setAttribute("w:date", date);

                    formattedRuns.forEach(run => insNode.appendChild(run));
                    pNode.appendChild(insNode);

                }

                const body = xmlDoc.getElementsByTagNameNS(WORD_NS, "body")[0] || xmlDoc.getElementsByTagName("w:body")[0];
                if (body) {
                    const sectPr = body.getElementsByTagNameNS(WORD_NS, "sectPr")[0] || body.getElementsByTagName("w:sectPr")[0];
                    if (sectPr) body.removeChild(sectPr);
                }

                const finalOxml = serializer.serializeToString(xmlDoc);
                p.insertOoxml(finalOxml, "Replace");

            } catch (e) {
                console.error(`[Vibe] Redline Error for ${meta.styleToken}:`, e);
            }
        }

        await context.sync();

        for (const p of insertedParagraphs) {
            context.trackedObjects.remove(p);
        }
        context.trackedObjects.remove(insertLocation);

        await context.sync();
    }

    // ==========================================
    // UI COMPONENTS (React)
    // ==========================================

    const fontStack = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif';

    const Header = ({ onSettingsClick, onRefreshContext, cacheStatus, focusedSelection, processingStage, provider }) =>
        React.createElement("div", { style: { borderBottom: "1px solid #e5e5e5", background: "#fff" } },
            React.createElement("div", { style: { padding: "14px 16px", display: "flex", justifyContent: "space-between", alignItems: "center" } },
                React.createElement("div", { style: { display: "flex", alignItems: "center", gap: "8px" } },
                    React.createElement("h2", { style: { margin: 0, fontSize: "14px", fontWeight: "600", color: "#111", fontFamily: fontStack } }, "Vibe Legal"),
                    React.createElement("span", { 
                        style: { fontSize: "11px", color: "#666", padding: "2px 6px", background: "#f0f0f0", borderRadius: "4px" },
                        title: provider === "claude" ? "Using Claude (no caching)" : cacheStatus === "loaded" ? "Full document context loaded" : cacheStatus === "loading" ? "Loading context..." : "Direct mode (no cache)"
                    }, provider === "claude" ? "Claude" : cacheStatus === "loaded" ? "Context" : "")
                ),
                React.createElement("div", { style: { display: "flex", gap: "8px" } },
                    React.createElement("button", { 
                        onClick: onRefreshContext, 
                        style: { background: "#eee", border: "none", cursor: "pointer", fontSize: "12px", padding: "4px 8px", borderRadius: "4px" },
                        title: "Refresh AI's knowledge of the document"
                    }, "Refresh"),
                    React.createElement("button", { onClick: onSettingsClick, style: { background: "none", border: "none", cursor: "pointer", fontSize: "12px", opacity: 0.7, padding: "4px" } }, "Settings")
                )
            ),
            focusedSelection && React.createElement("div", { 
                style: { 
                    padding: "8px 16px", 
                    background: "#e3f2fd", 
                    fontSize: "12px", 
                    color: "#1565c0",
                    display: "flex",
                    alignItems: "center",
                    gap: "6px",
                    borderTop: "1px solid #bbdefb"
                } 
            },
                React.createElement("strong", null, "Focus:"),
                React.createElement("span", { style: { fontStyle: "italic" } }, 
                    focusedSelection.length > 40 ? focusedSelection.substring(0, 40) + "..." : focusedSelection
                )
            ),
            processingStage && React.createElement("div", { 
                style: { 
                    padding: "8px 16px", 
                    background: "#fff3e0", 
                    fontSize: "12px", 
                    color: "#e65100",
                    borderTop: "1px solid #ffe0b2"
                } 
            }, processingStage)
        );

    // ENHANCEMENT 2A: Settings with Provider Dropdown
    const Settings = ({ 
        provider, setProvider,
        geminiApiKey, setGeminiApiKey,
        claudeApiKey, setClaudeApiKey,
        geminiModel, setGeminiModel,
        claudeModel, setClaudeModel,
        authorMode, setAuthorMode, 
        customAuthor, setCustomAuthor, 
        detectedAuthor, onBack 
    }) => {
        const [status, setStatus] = React.useState("");
        const [models, setModels] = React.useState([]);

        const currentApiKey = provider === "gemini" ? geminiApiKey : claudeApiKey;
        const currentModel = provider === "gemini" ? geminiModel : claudeModel;

        React.useEffect(() => { 
            if (currentApiKey) handleSync(); 
        }, [provider]);

        const handleSync = async () => {
            setStatus("Loading...");
            try {
                let list;
                if (provider === "gemini") {
                    list = await fetchModelsFromGoogle(geminiApiKey);
                } else {
                    list = await fetchModelsFromAnthropic(claudeApiKey);
                }
                setModels(list);
                setStatus(list.length + " models found");
                
                // Ensure current model exists in list
                const modelId = provider === "gemini" ? geminiModel : claudeModel;
                const currentExists = list.find((m) => {
                    const mName = m.name?.replace("models/", "") || m.name;
                    return mName === modelId;
                });
                if (!currentExists && list.length > 0) {
                    const newModel = list[0].name?.replace("models/", "") || list[0].name;
                    if (provider === "gemini") {
                        setGeminiModel(newModel);
                    } else {
                        setClaudeModel(newModel);
                    }
                }
            } catch (e) {
                setStatus("Error: Check Key");
                setModels([]);
            }
        };

        const handleProviderChange = (newProvider) => {
            setProvider(newProvider);
            setModels([]); // Clear models
            setStatus("Click Refresh to load models");
        };

        const handleDone = () => {
            // ENHANCEMENT 2F: Store provider-specific settings
            localStorage.setItem("vibe_provider", provider);
            localStorage.setItem("vibe_api_key_gemini", geminiApiKey);
            localStorage.setItem("vibe_api_key_claude", claudeApiKey);
            localStorage.setItem("vibe_model_gemini", geminiModel);
            localStorage.setItem("vibe_model_claude", claudeModel);
            localStorage.setItem("vibe_author_mode", authorMode);
            localStorage.setItem("vibe_custom_author", customAuthor);
            
            // Update global config
            providerConfig.provider = provider;
            providerConfig.geminiApiKey = geminiApiKey;
            providerConfig.claudeApiKey = claudeApiKey;
            providerConfig.geminiModel = geminiModel;
            providerConfig.claudeModel = claudeModel;
            
            authorSettings.mode = authorMode;
            authorSettings.customName = customAuthor;
            onBack();
        };

        return React.createElement("div", { style: { padding: "20px", background: "#f9f9f9", height: "100%", fontFamily: fontStack, fontSize: "13px" } },
            React.createElement("h3", { style: { marginTop: 0, fontSize: "14px", marginBottom: "20px" } }, "Settings"),
            
            // ENHANCEMENT 2A: Provider Dropdown
            React.createElement("div", { style: { marginBottom: "20px" } },
                React.createElement("label", { style: { display: "block", fontWeight: "600", marginBottom: "6px", color: "#444" } }, "Provider"),
                React.createElement("select", { 
                    value: provider, 
                    onChange: (e) => handleProviderChange(e.target.value), 
                    style: { width: "100%", padding: "10px", border: "1px solid #ddd", borderRadius: "6px", fontSize: "13px", background: "#fff" } 
                },
                    React.createElement("option", { value: "gemini" }, "Google Gemini"),
                    React.createElement("option", { value: "claude" }, "Anthropic Claude")
                ),
            ),
            
            React.createElement("div", { style: { marginBottom: "20px" } },
                React.createElement("label", { style: { display: "block", fontWeight: "600", marginBottom: "6px", color: "#444" } }, 
                    provider === "gemini" ? "Gemini API Key" : "Claude API Key"
                ),
                React.createElement("input", { 
                    type: "password", 
                    value: currentApiKey, 
                    onChange: (e) => provider === "gemini" ? setGeminiApiKey(e.target.value) : setClaudeApiKey(e.target.value), 
                    style: { width: "100%", padding: "10px", border: "1px solid #ddd", borderRadius: "6px", fontSize: "13px" }, 
                    placeholder: provider === "gemini" ? "Enter Gemini API Key" : "Enter Claude API Key"
                }),
            ),
            
            React.createElement("div", { style: { marginBottom: "20px" } },
                React.createElement("div", { style: { display: "flex", justifyContent: "space-between", marginBottom: "6px" } },
                    React.createElement("label", { style: { fontWeight: "600", color: "#444" } }, "Model"),
                    React.createElement("button", { onClick: handleSync, style: { fontSize: "11px", background: "none", border: "none", color: "#000", textDecoration: "underline", cursor: "pointer" } }, "Refresh"),
                ),
                React.createElement("select", { 
                    value: currentModel, 
                    onChange: (e) => provider === "gemini" ? setGeminiModel(e.target.value) : setClaudeModel(e.target.value), 
                    style: { width: "100%", padding: "10px", border: "1px solid #ddd", borderRadius: "6px", fontSize: "13px", background: "#fff" } 
                },
                    models.length > 0
                        ? models.map((m) => React.createElement("option", { key: m.name, value: m.name.replace("models/", "") }, m.displayName || m.name))
                        : React.createElement("option", { value: currentModel }, currentModel || "Default"),
                ),
                React.createElement("div", { style: { fontSize: "11px", color: "#666", marginTop: "6px" } }, status),
            ),
            
            React.createElement("div", { style: { marginBottom: "20px" } },
                React.createElement("label", { style: { display: "block", fontWeight: "600", marginBottom: "6px", color: "#444" } }, "Track Changes Attribution"),
                React.createElement("select", { 
                    value: authorMode, 
                    onChange: (e) => setAuthorMode(e.target.value), 
                    style: { width: "100%", padding: "10px", border: "1px solid #ddd", borderRadius: "6px", fontSize: "13px", background: "#fff", marginBottom: "8px" } 
                },
                    React.createElement("option", { value: "auto" }, detectedAuthor ? "Use my name (" + detectedAuthor + ")" : "Use document author (auto-detect)"),
                    React.createElement("option", { value: "vibe" }, "Vibe AI"),
                    React.createElement("option", { value: "custom" }, "Custom name...")
                ),
                authorMode === "custom" && React.createElement("input", { 
                    type: "text", 
                    value: customAuthor, 
                    onChange: (e) => setCustomAuthor(e.target.value), 
                    style: { width: "100%", padding: "10px", border: "1px solid #ddd", borderRadius: "6px", fontSize: "13px" }, 
                    placeholder: "Enter name for track changes" 
                }),
                React.createElement("div", { style: { fontSize: "11px", color: "#666", marginTop: "6px" } }, 
                    authorMode === "auto" ? "Changes will appear as if you made them" : authorMode === "vibe" ? "Changes will be attributed to 'Vibe AI'" : "Changes will use your custom name"
                ),
            ),
            
            React.createElement("button", { onClick: handleDone, style: { width: "100%", background: "#000", color: "#fff", padding: "12px", border: "none", borderRadius: "6px", cursor: "pointer", fontWeight: "600", fontSize: "13px" } }, "Done"),
        );
    };

    const Chat = ({ messages }) => {
        const bottomRef = React.useRef(null);
        React.useEffect(() => { bottomRef.current?.scrollIntoView({ behavior: "smooth" }); }, [messages]);
        return React.createElement("div", { style: { flexGrow: 1, overflowY: "auto", padding: "20px", display: "flex", flexDirection: "column", gap: "16px", fontFamily: fontStack } },
            messages.map((msg, i) =>
                React.createElement("div", { key: i, style: { alignSelf: msg.role === "user" ? "flex-end" : "flex-start", maxWidth: "90%" } },
                    React.createElement("div", { style: { background: msg.role === "user" ? "#000" : "#f4f4f4", color: msg.role === "user" ? "#fff" : "#111", padding: "10px 14px", borderRadius: "8px", fontSize: "13px", lineHeight: "1.5" }, dangerouslySetInnerHTML: { __html: renderMarkdown(msg.content) } }),
                ),
            ),
            React.createElement("div", { ref: bottomRef }),
        );
    };

    const InputArea = ({ value, onChange, onSend, disabled }) =>
        React.createElement("div", { style: { padding: "16px", background: "#fff", borderTop: "1px solid #e5e5e5", display: "flex", gap: "10px" } },
            React.createElement("input", {
                value: value,
                onChange: (e) => onChange(e.target.value),
                onKeyDown: (e) => { if (e.key === 'Enter' && !disabled) onSend(); },
                placeholder: "Ask or instruct...",
                disabled: disabled,
                style: { flexGrow: 1, padding: "12px", border: "1px solid #ddd", borderRadius: "8px", fontSize: "13px", outline: "none", fontFamily: fontStack }
            }),
            React.createElement("button", {
                onClick: onSend,
                disabled: disabled,
                style: { width: "48px", height: "48px", background: disabled ? "#eee" : "#000", color: "#fff", border: "none", borderRadius: "8px", cursor: "pointer", display: "flex", alignItems: "center", justifyContent: "center" },
            }, disabled ? "..." : "Send"),
        );

    // ==========================================
    // MAIN APP (with Provider Support)
    // ==========================================

    const App = () => {
        const [view, setView] = React.useState("main");
        
        // ENHANCEMENT 2F: Provider-specific state
        const [provider, setProvider] = React.useState<AIProvider>("gemini");
        const [geminiApiKey, setGeminiApiKey] = React.useState("");
        const [claudeApiKey, setClaudeApiKey] = React.useState("");
        const [geminiModel, setGeminiModel] = React.useState("gemini-2.0-flash-exp");
        const [claudeModel, setClaudeModel] = React.useState("claude-sonnet-4-20250514");
        
        const [messages, setMessages] = React.useState([{ role: "bot", content: "**Vibe Legal** ready. Select text and give an instruction, or ask questions about your document." }]);
        const [inputValue, setInputValue] = React.useState("");
        const [isProcessing, setIsProcessing] = React.useState(false);
        const [cacheStatus, setCacheStatus] = React.useState<"loaded" | "loading" | "direct">("direct");
        
        const [processingStage, setProcessingStage] = React.useState<string>("");
        const [focusedSelection, setFocusedSelection] = React.useState<string>("");
        
        const [authorMode, setAuthorMode] = React.useState<AuthorMode>("auto");
        const [customAuthor, setCustomAuthor] = React.useState("");
        const [detectedAuthor, setDetectedAuthor] = React.useState<string | null>(null);

        // ENHANCEMENT 2F: Load provider-specific settings
        React.useEffect(() => {
            const p = localStorage.getItem("vibe_provider") as AIProvider;
            const gKey = localStorage.getItem("vibe_api_key_gemini");
            const cKey = localStorage.getItem("vibe_api_key_claude");
            const gModel = localStorage.getItem("vibe_model_gemini");
            const cModel = localStorage.getItem("vibe_model_claude");
            const am = localStorage.getItem("vibe_author_mode") as AuthorMode;
            const ca = localStorage.getItem("vibe_custom_author");
            
            // Backwards compatibility: check old key format
            const oldKey = localStorage.getItem("vibe_api_key");
            const oldModel = localStorage.getItem("vibe_model");
            
            if (p) setProvider(p);
            if (gKey) setGeminiApiKey(gKey);
            else if (oldKey) setGeminiApiKey(oldKey);
            if (cKey) setClaudeApiKey(cKey);
            if (gModel) setGeminiModel(gModel);
            else if (oldModel) setGeminiModel(oldModel);
            if (cModel) setClaudeModel(cModel);
            if (am) {
                setAuthorMode(am);
                authorSettings.mode = am;
            }
            if (ca) {
                setCustomAuthor(ca);
                authorSettings.customName = ca;
            }
            
            // Update global config
            providerConfig.provider = p || "gemini";
            providerConfig.geminiApiKey = gKey || oldKey || "";
            providerConfig.claudeApiKey = cKey || "";
            providerConfig.geminiModel = gModel || oldModel || "gemini-2.0-flash-exp";
            providerConfig.claudeModel = cModel || "claude-sonnet-4-20250514";
        }, []);

        React.useEffect(() => {
            const checkAuthor = setInterval(() => {
                if (authorSettings.detectedAuthor !== detectedAuthor) {
                    setDetectedAuthor(authorSettings.detectedAuthor);
                }
            }, 500);
            return () => clearInterval(checkAuthor);
        }, [detectedAuthor]);

        React.useEffect(() => {
            const interval = setInterval(() => {
                setCacheStatus(getCacheStatus());
            }, 1000);
            return () => clearInterval(interval);
        }, []);

        const handleRefreshContext = async () => {
            const apiKey = getCurrentApiKey();
            if (!apiKey) return;
            setIsProcessing(true);
            setMessages(p => [...p, { role: "bot", content: "Refreshing document context..." }]);
            
            try {
                await Word.run(async (context) => {
                    const body = context.document.body;
                    body.load("text");
                    await context.sync();
                    
                    const result = await refreshCache(apiKey, getCurrentModel(), body.text);
                    setCacheStatus(getCacheStatus());
                    
                    if (result.error) {
                        setMessages(p => [...p, { role: "bot", content: `Note: ${result.error}` }]);
                    } else if (result.success) {
                        setMessages(p => [...p, { role: "bot", content: "Context refreshed. AI now has updated knowledge of your document." }]);
                    } else {
                        setMessages(p => [...p, { role: "bot", content: "Cache refresh failed. Using Direct Mode." }]);
                    }
                });
            } catch (e) {
                setMessages(p => [...p, { role: "bot", content: "Refresh failed: " + (e as Error).message }]);
            } finally {
                setIsProcessing(false);
            }
        };

        // ENHANCEMENT 2D: Updated handleAction with provider routing
        const handleAction = async () => {
            const apiKey = getCurrentApiKey();
            if (!apiKey) return setView("settings");
            if (!inputValue.trim()) return;

            const currentInput = inputValue;
            setInputValue("");
            setMessages((p) => [...p, { role: "user", content: currentInput }]);
            setIsProcessing(true);
            setProcessingStage("Reading document...");

            try {
                await Word.run(async (context) => {
                    const trackedItems = [];

                    try {
                        if (!authorSettings.detectedAuthor) {
                            await detectDocumentAuthor(context);
                        }

                        const selection = context.document.getSelection();
                        selection.load("text");
                        await context.sync();
                        
                        const rawSelectedText = selection.text?.trim() || "";
                        const hasFocus = rawSelectedText.length > 0;
                        
                        if (hasFocus) {
                            
                            const { text: acceptedSelectionText, oxml: selectionOxml } = await getAcceptedSelectionText(context);
                            
                            setFocusedSelection(acceptedSelectionText.substring(0, 100));
                            
                            if (isQuestionIntent(currentInput)) {
                                setProcessingStage("Analyzing selection...");
                                
                                try {
                                    const answer = await callQuestion(
                                        currentInput + "\n\n[User is asking about this specific clause: \"" + acceptedSelectionText.substring(0, 2000) + "\"]",
                                        acceptedSelectionText,
                                        cacheState.changelog,
                                        null
                                    );
                                    setMessages(p => [...p, { role: "bot", content: answer }]);
                                } catch (e) {
                                    setMessages(p => [...p, { role: "bot", content: "Error: " + (e as Error).message }]);
                                }
                                
                                setProcessingStage("");
                                setFocusedSelection("");
                                return;
                            }
                            
                            setProcessingStage("Generating changes...");
                            
                            try {
                                const newText = await callRedline(
                                    currentInput,
                                    acceptedSelectionText,
                                    null
                                );
                                
                                if (newText !== acceptedSelectionText) {
                                    setProcessingStage("Applying changes...");
                                    
                                    const redlineResult = applyRedlineToOxml(selectionOxml, acceptedSelectionText, newText);
                                    
                                    if (redlineResult.hasChanges) {
                                        selection.insertOoxml(redlineResult.oxml, Word.InsertLocation.replace);
                                        await context.sync();
                                        
                                        logChange("MODIFY", "Selection: " + currentInput.substring(0, 100), newText);
                                        setMessages(p => [...p, { role: "bot", content: "Applied changes to selection." }]);
                                    } else {
                                        setMessages(p => [...p, { role: "bot", content: "No changes needed." }]);
                                    }
                                } else {
                                    setMessages(p => [...p, { role: "bot", content: "No changes suggested." }]);
                                }
                            } catch (e) {
                                console.error("[Vibe] Focus mode redline failed:", e);
                                setMessages(p => [...p, { role: "bot", content: "Error: " + (e as Error).message }]);
                            }
                            
                            setProcessingStage("");
                            setFocusedSelection("");
                            return;
                        }
                        
                        setFocusedSelection("");

                        const body = context.document.body;
                        body.load("text");
                        const paragraphs = context.document.body.paragraphs;
                        paragraphs.load("text, style, styleId, isListItem");
                        await context.sync();

                        const fullDocumentText = body.text;

                        // ==========================================
                        // COMPLEX TRANSFORMATION DETECTION
                        // ==========================================
                        // Instead of full-document rewrite + diff (which corrupts output),
                        // we pass a flag to the router for terminology-aware routing
                        const isComplexTransform = isHolisticTransformation(currentInput);
                        if (isComplexTransform) {
                            setMessages(p => [...p, { role: "bot", content: "Complex transformation detected. Using terminology-aware mode for consistent changes..." }]);
                        }

                        if (isQuestionIntent(currentInput)) {
                            setProcessingStage("Analyzing document...");
                            
                            // ENHANCEMENT 2E: Skip cache for Claude
                            let cacheId: string | null = null;
                            if (providerConfig.provider === "gemini" && fullDocumentText.length >= CACHE_CONFIG.minCacheChars) {
                                const cacheResult = await ensureCache(getCurrentApiKey(), getCurrentModel(), fullDocumentText);
                                cacheId = cacheResult.cacheId;
                                if (cacheResult.error) {
                                    console.warn("[Vibe] Cache unavailable for question:", cacheResult.error);
                                }
                            }
                            
                            try {
                                const answer = await callQuestion(
                                    currentInput,
                                    fullDocumentText,
                                    cacheState.changelog,
                                    cacheId
                                );
                                setMessages(p => [...p, { role: "bot", content: answer }]);
                            } catch (e) {
                                console.error("[Vibe] Question handler failed:", e);
                                setMessages(p => [...p, { role: "bot", content: "Failed to analyze: " + (e as Error).message }]);
                            }
                            
                            return;
                        }

                        // ENHANCEMENT 2E: Skip cache refresh for Claude
                        if (providerConfig.provider === "gemini" && shouldRefreshCache()) {
                            const refreshResult = await refreshCache(getCurrentApiKey(), getCurrentModel(), fullDocumentText);
                            if (refreshResult.error) {
                                setMessages(p => [...p, { role: "bot", content: `Note: ${refreshResult.error}` }]);
                            }
                        }

                        // ENHANCEMENT 2E: Skip cache for Claude
                        let cacheId: string | null = null;
                        if (providerConfig.provider === "gemini") {
                            const cacheResult = await ensureCache(getCurrentApiKey(), getCurrentModel(), fullDocumentText);
                            cacheId = cacheResult.cacheId;
                            
                            if (cacheResult.error) {
                                setMessages(p => [...p, { role: "bot", content: `Note: ${cacheResult.error}` }]);
                            }
                        }

                        const mapLines = [];
                        const lookup = {};

                        for (let i = 0; i < paragraphs.items.length; i++) {
                            const p = paragraphs.items[i];
                            if (p.isListItem) {
                                p.listItem.load("level");
                            }
                        }
                        await context.sync();

                        for (let i = 0; i < paragraphs.items.length; i++) {
                            const p = paragraphs.items[i];
                            const id = i + 1;
                            lookup[id] = p;

                            context.trackedObjects.add(p);
                            trackedItems.push(p);

                            const text = p.text.substring(0, 150).replace(/\n/g, " ");

                            let meta = `{Style: ${p.styleId}}`;
                            if (p.isListItem) {
                                try {
                                    meta += ` {List: Lvl ${p.listItem.level}}`;
                                } catch (e) {
                                    meta += ` {List: true}`;
                                }
                            }

                            if (text.trim().length > 0) {
                                mapLines.push(`[${id}] ${meta} ${text}`);
                            }
                        }

                        await context.sync();

                        const documentMap = mapLines.join("\n");

                        const { styleCache, menu: styleMenu } = await generateStyleMenuAndCache(context, paragraphs);

                        const snapshot = await captureDocumentSnapshot(context, paragraphs, styleCache);

                        setProcessingStage("Generating response...");
                        
                        // ENHANCEMENT 2D + 3: Use unified router with complex transformation support
                        const routerResponse = await callRouter(
                            currentInput, styleMenu, snapshot, cacheId,
                            isComplexTransform, fullDocumentText
                        );
                        
                        // Log terminology if present (for complex transformations)
                        if (routerResponse.terminology) {
                        }

                        if (routerResponse.answer) {
                            setMessages((p) => [...p, { role: "bot", content: routerResponse.answer }]);
                        }

                        if (routerResponse.actions && routerResponse.actions.length > 0) {
                            const actions = routerResponse.actions;

                            const insertActions = actions.filter(a => a.type === "INSERT");
                            const modifyActions = actions.filter(a => a.type === "MODIFY");

                            if (insertActions.length > 0) {
                                for (const action of insertActions) {
                                    const locId = action.location_id;
                                    const refP = lookup[locId];

                                    if (refP) {
                                        try {
                                            if (action.blocks && Array.isArray(action.blocks)) {
                                                await insertBlocks(context, action.blocks, styleCache, refP, routerResponse.analysis);
                                                
                                                const contentPreview = action.blocks.map(b => b.content).join(" ").substring(0, 200);
                                                logChange("INSERT", `Added ${action.blocks.length} block(s) after paragraph ${locId}`, contentPreview);
                                                setMessages((p) => [...p, { role: "bot", content: `Inserted ${action.blocks.length} block(s).` }]);
                                            } else {
                                                console.warn("[Vibe] No blocks found in INSERT content. Using plain text.");
                                                refP.insertParagraph(stripMarkdownFormatting(action.content || ""), Word.InsertLocation.after);
                                                await context.sync();
                                                setMessages((p) => [...p, { role: "bot", content: `Inserted plain text.` }]);
                                                
                                                logChange("INSERT", `Added text after paragraph ${locId}`, action.content?.substring(0, 200));
                                            }
                                        } catch (e) {
                                            console.warn("[Vibe] Insertion failed.", e);
                                            setMessages((p) => [...p, { role: "bot", content: `Insertion failed: ${e.message}` }]);
                                        }
                                    } else {
                                        setMessages((p) => [...p, { role: "bot", content: `Invalid location specified.` }]);
                                    }
                                }
                            }

                            if (modifyActions.length > 0) {
                                // ENHANCEMENT 3: Process sequentially for complex transformations
                                const processingMode = isComplexTransform ? "sequentially" : "in parallel";
                                
                                const modifyTasks = [];

                                for (const action of modifyActions) {
                                    const targetId = action.target_id;
                                    const targetP = lookup[targetId];
                                    if (targetP) {
                                        targetP.load("text");
                                        const oxml = targetP.getOoxml();
                                        modifyTasks.push({ action, targetP, oxml });
                                    } else {
                                        setMessages((p) => [...p, { role: "bot", content: `Invalid Target ID: ${targetId}` }]);
                                    }
                                }

                                if (modifyTasks.length > 0) {
                                    await context.sync();

                                    let results: any[] = [];
                                    
                                    if (isComplexTransform) {
                                        // SEQUENTIAL processing for complex transformations
                                        // This ensures each change is applied cleanly before the next
                                        
                                        // Build terminology context from router response
                                        let terminologyContext = "";
                                        if (routerResponse.terminology) {
                                            const t = routerResponse.terminology;
                                            terminologyContext = `TRANSFORMATION: ${t.notes || 'Complex transformation'}. `;
                                            if (t.find_replace && t.find_replace.length > 0) {
                                                terminologyContext += "REPLACEMENTS: " + t.find_replace.map(
                                                    (fr: any) => `"${fr.find}" -> "${fr.replace}"`
                                                ).join(", ");
                                            }
                                        }
                                        
                                        for (const task of modifyTasks) {
                                            try {
                                                // Enrich instruction with terminology context for complex transformations
                                                let enrichedInstruction = task.action.instruction;
                                                if (terminologyContext) {
                                                    enrichedInstruction = `${terminologyContext}\n\nINSTRUCTION: ${task.action.instruction}`;
                                                }
                                                
                                                const newText = await callRedline(
                                                    enrichedInstruction, task.targetP.text, cacheId
                                                );
                                                results.push({ ...task, newText, success: true });
                                                
                                                // Apply immediately for sequential processing
                                                const redlineResult = applyRedlineToOxml(task.oxml.value, task.targetP.text, newText);
                                                if (redlineResult.hasChanges) {
                                                    task.targetP.insertOoxml(redlineResult.oxml, Word.InsertLocation.replace);
                                                    await context.sync();
                                                    
                                                    logChange("MODIFY", `Modified paragraph ${task.action.target_id}: ${task.action.instruction.substring(0, 100)}`);
                                                    setMessages((p) => [...p, { role: "bot", content: `Modified: ${task.action.description || 'section'}` }]);
                                                }
                                            } catch (e) {
                                                console.error(`[Vibe] Redline failed for ${task.action.target_id}`, e);
                                                results.push({ ...task, error: e.message, success: false });
                                                setMessages((p) => [...p, { role: "bot", content: `Failed to modify: ${e.message}` }]);
                                            }
                                        }
                                        
                                    } else {
                                        // PARALLEL processing for standard modifications
                                        results = await Promise.all(modifyTasks.map(async (task) => {
                                            try {
                                                const newText = await callRedline(
                                                    task.action.instruction, task.targetP.text, cacheId
                                                );
                                                return { ...task, newText, success: true };
                                            } catch (e) {
                                                console.error(`[Vibe] Redline failed for ${task.action.target_id}`, e);
                                                return { ...task, error: e.message, success: false };
                                            }
                                        }));

                                        let changesApplied = 0;
                                        for (const res of results) {
                                            if (res.success) {
                                                const redlineResult = applyRedlineToOxml(res.oxml.value, res.targetP.text, res.newText);
                                                if (redlineResult.hasChanges) {
                                                    res.targetP.insertOoxml(redlineResult.oxml, Word.InsertLocation.replace);
                                                    setMessages((p) => [...p, { role: "bot", content: `Modified section.` }]);
                                                    changesApplied++;
                                                    
                                                    logChange("MODIFY", `Modified paragraph ${res.action.target_id}: ${res.action.instruction.substring(0, 100)}`);
                                                } else {
                                                    setMessages((p) => [...p, { role: "bot", content: `No changes needed.` }]);
                                                }
                                            } else {
                                                setMessages((p) => [...p, { role: "bot", content: `Failed to modify: ${res.error}` }]);
                                            }
                                        }

                                        if (changesApplied > 0) {
                                            await context.sync();
                                        }
                                    }
                                }
                            }
                        }
                    } finally {
                        if (trackedItems && trackedItems.length > 0) {
                            trackedItems.forEach(p => context.trackedObjects.remove(p));
                            await context.sync();
                        }
                    }
                });
            } catch (e) {
                console.error(e);
                setMessages((p) => [...p, { role: "bot", content: "Error: " + e.message }]);
            } finally {
                setIsProcessing(false);
                setProcessingStage("");
                setFocusedSelection("");
            }
        };

        if (view === "settings") {
            return React.createElement(Settings, {
                provider,
                setProvider,
                geminiApiKey,
                setGeminiApiKey,
                claudeApiKey,
                setClaudeApiKey,
                geminiModel,
                setGeminiModel,
                claudeModel,
                setClaudeModel,
                authorMode,
                setAuthorMode,
                customAuthor,
                setCustomAuthor,
                detectedAuthor,
                onBack: () => setView("main")
            });
        }

        return React.createElement("div", { style: { display: "flex", flexDirection: "column", height: "100vh", background: "#fff" } },
            React.createElement(Header, { 
                onSettingsClick: () => setView("settings"), 
                onRefreshContext: handleRefreshContext, 
                cacheStatus: cacheStatus, 
                focusedSelection: focusedSelection, 
                processingStage: processingStage,
                provider: provider
            }),
            React.createElement(Chat, { messages: messages }),
            React.createElement(InputArea, { value: inputValue, onChange: setInputValue, onSend: handleAction, disabled: isProcessing })
        );
    };

    function renderMarkdown(text: string): string {
        if (!text) return "";
        return text
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/\*\*(.*?)\*\*/g, "<strong>$1</strong>")
            .replace(/\*(.*?)\*/g, "<em>$1</em>")
            .replace(/\n/g, "<br>");
    }


    // HELPER FUNCTIONS
    function createTextRun(xmlDoc, text, rPr, isDeleted) {
        const r = xmlDoc.createElement("w:r");
        if (rPr) {
            const newRPr = rPr.cloneNode(true);
            r.appendChild(newRPr);
        }

        if (isDeleted) {
            const delText = xmlDoc.createElement("w:delText");
            delText.textContent = text;
            delText.setAttribute("xml:space", "preserve");
            r.appendChild(delText);
        } else {
            const t = xmlDoc.createElement("w:t");
            t.textContent = text;
            t.setAttribute("xml:space", "preserve");
            r.appendChild(t);
        }
        return r;
    }

    function createTrackChange(xmlDoc, type, run) {
        const wrapper = xmlDoc.createElement(type === 'del' ? "w:del" : "w:ins");
        wrapper.setAttribute("w:id", Math.floor(Math.random() * 10000).toString());
        wrapper.setAttribute("w:author", getTrackChangeAuthor());
        wrapper.setAttribute("w:date", new Date().toISOString());
        wrapper.appendChild(run);
        return wrapper;
    }


    Office.onReady(() => ReactDOM.render(React.createElement(App), document.getElementById("root")));

template:
  content: |
    <div id="root"></div>
style:
  content: |
    body { margin: 0; padding: 0; }
libraries: |
  https://appsforoffice.microsoft.com/lib/1/hosted/office.js
  https://unpkg.com/react@17/umd/react.development.js
  https://unpkg.com/react-dom@17/umd/react-dom.development.js
  https://cdnjs.cloudflare.com/ajax/libs/diff_match_patch/20121119/diff_match_patch.js
